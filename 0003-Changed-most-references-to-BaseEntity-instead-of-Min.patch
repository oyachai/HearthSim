From 67014eb8fe098ae7e1a35e769b50ed8f07bd63f1 Mon Sep 17 00:00:00 2001
From: geoffrey-liu <geoffrey.p.liu@gmail.com>
Date: Mon, 1 Dec 2014 19:09:23 -0500
Subject: [PATCH 3/6] Changed most references to BaseEntity instead of Minion
 and Hero. Need to fix test cases.

Used a NewMinion class as a delegate class to slowly move functionality over to BaseEntity. NewMinion acted as a skeleton class of the Minion class as it needs to be after the refactoring.
This was done in order to maintain the success of the test cases. Changed instantiation of Minion to BaseEntity in many areas. This was done because the previous software architecture had
Hero inherit from Minion. Many classes had instances of Minions which actually acted as Heroes. This was (mostly) fixed in this patch change. Also created a NewHero class to slowly move
behaviour specific to Hero over to the class it belongs in, while slowly removing behaviour commmon to both Minion and Hero.

---
 src/main/java/com/hearthsim/card/Card.java         |   11 +-
 src/main/java/com/hearthsim/card/minion/Hero.java  |   22 +-
 .../java/com/hearthsim/card/minion/Minion.java     |  350 +----
 .../java/com/hearthsim/card/minion/NewMinion.java  | 1016 +++++++++++++++
 .../card/minion/concrete/AbusiveSergeant.java      |    4 +-
 .../card/minion/concrete/AcidicSwampOoze.java      |    4 +-
 .../card/minion/concrete/AcolyteOfPain.java        |    2 +-
 .../card/minion/concrete/AldorPeacekeeper.java     |    4 +-
 .../card/minion/concrete/Alexstrasza.java          |    4 +-
 .../card/minion/concrete/AmaniBerserker.java       |    4 +-
 .../card/minion/concrete/AncientBrewmaster.java    |    4 +-
 .../card/minion/concrete/AncientOfLore.java        |    2 +-
 .../card/minion/concrete/AncientOfWar.java         |    2 +-
 .../card/minion/concrete/AngryChicken.java         |    4 +-
 .../card/minion/concrete/ArathiWeaponsmith.java    |    4 +-
 .../card/minion/concrete/ArcaneGolem.java          |    4 +-
 .../card/minion/concrete/ArchmageAntonidas.java    |    2 +-
 .../card/minion/concrete/ArgentProtector.java      |    4 +-
 .../hearthsim/card/minion/concrete/AzureDrake.java |    4 +-
 .../card/minion/concrete/BigGameHunter.java        |    4 +-
 .../card/minion/concrete/BloodKnight.java          |    4 +-
 .../card/minion/concrete/ColdlightOracle.java      |    4 +-
 .../card/minion/concrete/ColdlightSeer.java        |    4 +-
 .../card/minion/concrete/CrazedAlchemist.java      |    4 +-
 .../card/minion/concrete/CruelTaskmaster.java      |    4 +-
 .../card/minion/concrete/DarkIronDwarf.java        |    4 +-
 .../card/minion/concrete/DarkscaleHealer.java      |    4 +-
 .../card/minion/concrete/DefenderOfArgus.java      |    4 +-
 .../card/minion/concrete/DragonlingMechanic.java   |    4 +-
 .../card/minion/concrete/DreadInfernal.java        |    4 +-
 .../hearthsim/card/minion/concrete/DustDevil.java  |    2 +-
 .../card/minion/concrete/EarthElemental.java       |    2 +-
 .../card/minion/concrete/EarthenRingFarseer.java   |    4 +-
 .../card/minion/concrete/ElvenArcher.java          |    6 +-
 .../hearthsim/card/minion/concrete/Felguard.java   |    4 +-
 .../card/minion/concrete/FireElemental.java        |    4 +-
 .../hearthsim/card/minion/concrete/FlameImp.java   |    4 +-
 .../card/minion/concrete/FrostwolfWarlord.java     |    4 +-
 .../card/minion/concrete/GnomishInventor.java      |    4 +-
 .../card/minion/concrete/GrimscaleOracle.java      |    6 +-
 .../card/minion/concrete/GrommashHellscream.java   |    4 +-
 .../card/minion/concrete/GuardianOfKings.java      |    4 +-
 .../card/minion/concrete/GurubashiBerserker.java   |    4 +-
 .../card/minion/concrete/HealingTotem.java         |    2 +-
 .../card/minion/concrete/Houndmaster.java          |    4 +-
 .../card/minion/concrete/InjuredBlademaster.java   |    4 +-
 .../card/minion/concrete/IronbeakOwl.java          |    4 +-
 .../card/minion/concrete/IronforgeRifleman.java    |    4 +-
 .../com/hearthsim/card/minion/concrete/Leokk.java  |    4 +-
 .../card/minion/concrete/MurlocTidehunter.java     |    4 +-
 .../hearthsim/card/minion/concrete/Nightblade.java |    2 +-
 .../card/minion/concrete/NoviceEngineer.java       |    4 +-
 .../card/minion/concrete/PriestessOfElune.java     |    4 +-
 .../card/minion/concrete/RagingWorgen.java         |    4 +-
 .../hearthsim/card/minion/concrete/RaidLeader.java |    2 +-
 .../card/minion/concrete/RazorfenHunter.java       |    4 +-
 .../card/minion/concrete/ShatteredSunCleric.java   |    4 +-
 .../card/minion/concrete/SilverHandKnight.java     |    4 +-
 .../card/minion/concrete/Spellbreaker.java         |    4 +-
 .../card/minion/concrete/StampedingKodo.java       |    7 +-
 .../card/minion/concrete/StormpikeCommando.java    |    4 +-
 .../card/minion/concrete/StormwindChampion.java    |    2 +-
 .../hearthsim/card/minion/concrete/Succubus.java   |    2 +-
 .../card/minion/concrete/SunfuryProtector.java     |    4 +-
 .../card/minion/concrete/TaurenWarrior.java        |    4 +-
 .../card/minion/concrete/TempleEnforcer.java       |    4 +-
 .../card/minion/concrete/TheBlackKnight.java       |    4 +-
 .../hearthsim/card/minion/concrete/TimberWolf.java |    2 +-
 .../card/minion/concrete/TwilightDrake.java        |    4 +-
 .../card/minion/concrete/VioletTeacher.java        |    2 +-
 .../card/minion/concrete/VoodooDoctor.java         |    4 +-
 .../card/minion/concrete/Windspeaker.java          |    4 +-
 .../card/minion/concrete/YoungPriestess.java       |    2 +-
 .../com/hearthsim/card/minion/heroes/Druid.java    |    4 +-
 .../com/hearthsim/card/minion/heroes/Hunter.java   |    4 +-
 .../com/hearthsim/card/minion/heroes/Mage.java     |    4 +-
 .../com/hearthsim/card/minion/heroes/NewHero.java  |  270 ++++
 .../com/hearthsim/card/minion/heroes/Paladin.java  |    7 +-
 .../com/hearthsim/card/minion/heroes/Priest.java   |    6 +-
 .../com/hearthsim/card/minion/heroes/Rogue.java    |    7 +-
 .../com/hearthsim/card/minion/heroes/Shaman.java   |    9 +-
 .../com/hearthsim/card/minion/heroes/Warlock.java  |    4 +-
 .../com/hearthsim/card/minion/heroes/Warrior.java  |    7 +-
 .../card/spellcard/concrete/AncestralHealing.java  |    3 +-
 .../card/spellcard/concrete/AncestralSpirit.java   |    4 +-
 .../card/spellcard/concrete/AnimalCompanion.java   |    9 +-
 .../card/spellcard/concrete/ArcaneExplosion.java   |    4 +-
 .../card/spellcard/concrete/ArcaneIntellect.java   |    4 +-
 .../card/spellcard/concrete/ArcaneShot.java        |    2 +-
 .../card/spellcard/concrete/Assassinate.java       |    4 +-
 .../card/spellcard/concrete/Backstab.java          |    4 +-
 .../card/spellcard/concrete/BattleRage.java        |    4 +-
 .../hearthsim/card/spellcard/concrete/Bite.java    |    7 +-
 .../card/spellcard/concrete/BlessedChampion.java   |    4 +-
 .../card/spellcard/concrete/BlessingOfKings.java   |    4 +-
 .../card/spellcard/concrete/BlessingOfMight.java   |    4 +-
 .../card/spellcard/concrete/Bloodlust.java         |    4 +-
 .../hearthsim/card/spellcard/concrete/Charge.java  |    4 +-
 .../card/spellcard/concrete/CircleOfHealing.java   |    4 +-
 .../hearthsim/card/spellcard/concrete/Claw.java    |    7 +-
 .../card/spellcard/concrete/Consecration.java      |    4 +-
 .../card/spellcard/concrete/Corruption.java        |    4 +-
 .../card/spellcard/concrete/DeadlyPoison.java      |    7 +-
 .../card/spellcard/concrete/Demonfire.java         |    4 +-
 .../card/spellcard/concrete/DivineFavor.java       |    4 +-
 .../card/spellcard/concrete/DivineSpirit.java      |    4 +-
 .../card/spellcard/concrete/DrainLife.java         |    4 +-
 .../card/spellcard/concrete/Equality.java          |    4 +-
 .../card/spellcard/concrete/ExcessMana.java        |    4 +-
 .../hearthsim/card/spellcard/concrete/Execute.java |    4 +-
 .../card/spellcard/concrete/FanOfKnives.java       |    4 +-
 .../card/spellcard/concrete/Fireball.java          |    2 +-
 .../card/spellcard/concrete/Flamestrike.java       |    4 +-
 .../card/spellcard/concrete/FrostNova.java         |    4 +-
 .../card/spellcard/concrete/FrostShock.java        |    4 +-
 .../card/spellcard/concrete/Frostbolt.java         |    4 +-
 .../card/spellcard/concrete/HammerOfWrath.java     |    4 +-
 .../card/spellcard/concrete/HandOfProtection.java  |    4 +-
 .../card/spellcard/concrete/HealingTouch.java      |    4 +-
 .../card/spellcard/concrete/Hellfire.java          |    4 +-
 .../card/spellcard/concrete/HeroicStrike.java      |    4 +-
 .../com/hearthsim/card/spellcard/concrete/Hex.java |    4 +-
 .../card/spellcard/concrete/HolyFire.java          |    4 +-
 .../card/spellcard/concrete/HolyLight.java         |    4 +-
 .../card/spellcard/concrete/HolyNova.java          |    4 +-
 .../card/spellcard/concrete/HolySmite.java         |    2 +-
 .../card/spellcard/concrete/Humility.java          |    4 +-
 .../card/spellcard/concrete/HuntersMark.java       |    4 +-
 .../card/spellcard/concrete/InnerFire.java         |    4 +-
 .../card/spellcard/concrete/InnerRage.java         |    4 +-
 .../card/spellcard/concrete/Innervate.java         |    4 +-
 .../card/spellcard/concrete/KillCommand.java       |    7 +-
 .../card/spellcard/concrete/LavaBurst.java         |    4 +-
 .../card/spellcard/concrete/LayOnHands.java        |    4 +-
 .../card/spellcard/concrete/LightningBolt.java     |    4 +-
 .../card/spellcard/concrete/MarkOfTheWild.java     |    4 +-
 .../card/spellcard/concrete/MindBlast.java         |    4 +-
 .../card/spellcard/concrete/MindControl.java       |    4 +-
 .../card/spellcard/concrete/MirrorImage.java       |    9 +-
 .../card/spellcard/concrete/Moonfire.java          |    2 +-
 .../card/spellcard/concrete/MortalCoil.java        |    4 +-
 .../card/spellcard/concrete/Polymorph.java         |    4 +-
 .../card/spellcard/concrete/PowerWordShield.java   |    4 +-
 .../card/spellcard/concrete/Pyroblast.java         |    2 +-
 .../card/spellcard/concrete/RockbiterWeapon.java   |    4 +-
 .../card/spellcard/concrete/SacrificialPact.java   |    4 +-
 .../com/hearthsim/card/spellcard/concrete/Sap.java |    4 +-
 .../card/spellcard/concrete/SavageRoar.java        |    4 +-
 .../card/spellcard/concrete/ShadowBolt.java        |    4 +-
 .../card/spellcard/concrete/ShadowWordDeath.java   |    4 +-
 .../card/spellcard/concrete/ShadowWordPain.java    |    4 +-
 .../card/spellcard/concrete/ShieldBlock.java       |    4 +-
 .../hearthsim/card/spellcard/concrete/Shiv.java    |    4 +-
 .../hearthsim/card/spellcard/concrete/Silence.java |    4 +-
 .../card/spellcard/concrete/SinisterStrike.java    |    4 +-
 .../hearthsim/card/spellcard/concrete/Slam.java    |    4 +-
 .../hearthsim/card/spellcard/concrete/Sprint.java  |    4 +-
 .../card/spellcard/concrete/Starfire.java          |    4 +-
 .../hearthsim/card/spellcard/concrete/Swipe.java   |    4 +-
 .../hearthsim/card/spellcard/concrete/TheCoin.java |    6 +-
 .../card/spellcard/concrete/TotemicMight.java      |    4 +-
 .../card/spellcard/concrete/Whirlwind.java         |    4 +-
 .../card/spellcard/concrete/WildGrowth.java        |    4 +-
 .../card/spellcard/concrete/Windfury.java          |    4 +-
 src/main/java/com/hearthsim/entity/BaseEntity.java | 1332 +++++++++++++++++++-
 src/main/java/com/hearthsim/model/BoardModel.java  |   15 +-
 .../com/hearthsim/test/card/TestKillCommand.java   |    9 +-
 .../com/hearthsim/test/heroes/TestBaseEntity.java  |   78 ++
 168 files changed, 3068 insertions(+), 679 deletions(-)
 create mode 100644 src/main/java/com/hearthsim/card/minion/NewMinion.java
 create mode 100644 src/main/java/com/hearthsim/card/minion/heroes/NewHero.java
 create mode 100644 src/test/java/com/hearthsim/test/heroes/TestBaseEntity.java

diff --git a/src/main/java/com/hearthsim/card/Card.java b/src/main/java/com/hearthsim/card/Card.java
index 50f7b1c..0c23def 100644
--- a/src/main/java/com/hearthsim/card/Card.java
+++ b/src/main/java/com/hearthsim/card/Card.java
@@ -2,6 +2,7 @@ package com.hearthsim.card;
 
 import com.hearthsim.card.minion.Hero;
 import com.hearthsim.card.minion.Minion;
+import com.hearthsim.entity.BaseEntity;
 import com.hearthsim.exception.HSException;
 import com.hearthsim.model.BoardModel;
 import com.hearthsim.model.PlayerSide;
@@ -202,7 +203,7 @@ public class Card implements DeepCopyable {
         
 	public final HearthTreeNode useOn(
 			PlayerSide side,
-			Minion targetMinion,
+			BaseEntity targetMinion,
 			HearthTreeNode boardState,
 			Deck deckPlayer0,
 			Deck deckPlayer1)
@@ -229,7 +230,7 @@ public class Card implements DeepCopyable {
 	 */
 	public HearthTreeNode useOn(
 			PlayerSide side,
-			Minion targetMinion,
+			BaseEntity targetMinion,
 			HearthTreeNode boardState,
 			Deck deckPlayer0,
 			Deck deckPlayer1,
@@ -293,7 +294,7 @@ public class Card implements DeepCopyable {
 	 */
 	protected HearthTreeNode use_core(
 			PlayerSide side,
-			Minion targetMinion,
+			BaseEntity targetMinion,
 			HearthTreeNode boardState,
 			Deck deckPlayer0,
 			Deck deckPlayer1,
@@ -354,7 +355,7 @@ public class Card implements DeepCopyable {
         return PlayerSide.WAITING_PLAYER == side;
     }
 
-    protected boolean isNotHero(Minion targetMinion) {
+    protected boolean isNotHero(BaseEntity targetMinion) {
         return !isHero(targetMinion);
     }
 
@@ -362,7 +363,7 @@ public class Card implements DeepCopyable {
         return PlayerSide.CURRENT_PLAYER == side;
     }
 
-    protected boolean isHero(Minion targetMinion) {
+    protected boolean isHero(BaseEntity targetMinion) {
         return targetMinion instanceof Hero;
     }
 }
diff --git a/src/main/java/com/hearthsim/card/minion/Hero.java b/src/main/java/com/hearthsim/card/minion/Hero.java
index dcc220e..7402672 100644
--- a/src/main/java/com/hearthsim/card/minion/Hero.java
+++ b/src/main/java/com/hearthsim/card/minion/Hero.java
@@ -1,21 +1,25 @@
 package com.hearthsim.card.minion;
 
+import org.json.JSONObject;
+
 import com.hearthsim.card.Deck;
+import com.hearthsim.card.minion.Hero;
+import com.hearthsim.card.minion.Minion;
+import com.hearthsim.entity.BaseEntity;
 import com.hearthsim.exception.HSException;
 import com.hearthsim.model.BoardModel;
 import com.hearthsim.model.PlayerSide;
 import com.hearthsim.util.DeepCopyable;
 import com.hearthsim.util.factory.BoardStateFactoryBase;
 import com.hearthsim.util.tree.HearthTreeNode;
-import org.json.JSONObject;
-
-public class Hero extends Minion {
 
+public class Hero extends BaseEntity
+{
 	protected static final byte HERO_ABILITY_COST = 2;  //Assumed to be 2 for all heroes
 	
 	protected byte weaponCharge_;
 	protected byte armor_;
-		
+	
 	public Hero() {
 		this("NoHero", (byte)30);
 	}
@@ -139,7 +143,7 @@ public class Hero extends Minion {
 
 	public final HearthTreeNode useHeroAbility(
 			PlayerSide targetPlayerSide,
-			Minion targetMinion,
+			BaseEntity targetMinion,
 			HearthTreeNode boardState,
 			Deck deckPlayer0,
 			Deck deckPlayer1)
@@ -160,7 +164,7 @@ public class Hero extends Minion {
 	 */
 	public final HearthTreeNode useHeroAbility(
 			PlayerSide targetPlayerSide,
-			Minion targetMinion,
+			BaseEntity targetMinion,
 			HearthTreeNode boardState,
 			Deck deckPlayer0,
 			Deck deckPlayer1,
@@ -179,7 +183,7 @@ public class Hero extends Minion {
 	
 	public HearthTreeNode useHeroAbility_core(
 			PlayerSide targetPlayerSide,
-			Minion targetMinion,
+			BaseEntity targetMinion,
 			HearthTreeNode boardState,
 			Deck deckPlayer0,
 			Deck deckPlayer1,
@@ -250,8 +254,8 @@ public class Hero extends Minion {
 			return false;
 		}
 		Hero hero = (Hero)other;
-		if (weaponCharge_ != hero.weaponCharge_) return false;
-		if (armor_ != hero.armor_) return false;
+		if (weaponCharge_ != hero.getWeaponCharge()) return false;
+		if (armor_ != hero.getArmor()) return false;
 		
 		return true;
 	}
diff --git a/src/main/java/com/hearthsim/card/minion/Minion.java b/src/main/java/com/hearthsim/card/minion/Minion.java
index bccf2eb..54bcfe1 100644
--- a/src/main/java/com/hearthsim/card/minion/Minion.java
+++ b/src/main/java/com/hearthsim/card/minion/Minion.java
@@ -28,40 +28,6 @@ public class Minion extends BaseEntity {
     	FRIENDLY_MURLOCS, ENEMY_MURLOCS
     }
 	
-	protected boolean taunt_;
-	protected boolean divineShield_;
-	protected boolean windFury_;
-	protected boolean charge_;
-	
-	protected boolean hasAttacked_;
-	protected boolean hasWindFuryAttacked_;
-	
-	protected boolean frozen_;
-	protected boolean silenced_;
-	protected boolean stealthed_;
-	protected boolean heroTargetable_;
-	
-	//protected byte health_;
-	protected byte maxHealth_;
-	protected byte baseHealth_;
-	protected byte auraHealth_;
-	
-	//protected byte attack_;
-	protected byte baseAttack_;
-	protected byte extraAttackUntilTurnEnd_;
-	protected byte auraAttack_;
-	
-	protected boolean summoned_;
-	protected boolean transformed_;
-	
-	protected boolean destroyOnTurnStart_;
-	protected boolean destroyOnTurnEnd_;
-
-	protected byte spellDamage_;
-
-	protected DeathrattleAction deathrattleAction_;
-	protected AttackAction attackAction_;
-	
 	//This is a flag to tell the BoardState that it can't cheat on the placement of this minion
 	protected boolean placementImportant_ = false;
 
@@ -131,6 +97,7 @@ public class Minion extends BaseEntity {
 				null,
 				true,
 				false);
+		
 	}
 
 	public Minion(	String name,
@@ -469,6 +436,7 @@ public class Minion extends BaseEntity {
 			boolean handleMinionDeath)
 		throws HSException
 	{
+		Minion m = new Minion();
 		if (!divineShield_) {
 			byte totalDamage = isSpellDamage ? (byte)(damage + boardState.data_.getSpellDamage(attackPlayerSide)) : damage;
 			health_ = (byte)(health_ - totalDamage);
@@ -625,7 +593,7 @@ public class Minion extends BaseEntity {
 	 */
 	public HearthTreeNode useTargetableBattlecry(
 			PlayerSide side,
-			Minion targetMinion,
+			BaseEntity targetMinion,
 			HearthTreeNode boardState,
 			Deck deckPlayer0,
 			Deck deckPlayer1
@@ -662,7 +630,7 @@ public class Minion extends BaseEntity {
 	 */
 	public HearthTreeNode useTargetableBattlecry_core(
 			PlayerSide side,
-			Minion targetMinion,
+			BaseEntity targetMinion,
 			HearthTreeNode boardState,
 			Deck deckPlayer0,
 			Deck deckPlayer1
@@ -726,10 +694,10 @@ public class Minion extends BaseEntity {
      * @return The boardState is manipulated and returned
 	 * @throws HSException 
 	 */
-	@Override
+	
 	protected HearthTreeNode use_core(
 			PlayerSide side,
-			Minion targetMinion,
+			BaseEntity targetMinion,
 			HearthTreeNode boardState,
 			Deck deckPlayer0,
 			Deck deckPlayer1,
@@ -744,7 +712,7 @@ public class Minion extends BaseEntity {
 		if (side == PlayerSide.WAITING_PLAYER)
 			return null;
 		
-		HearthTreeNode toRet = this.summonMinion(side, targetMinion, boardState, deckPlayer0, deckPlayer1, false);
+		HearthTreeNode toRet = this.summonMinion(side, (Minion) targetMinion, boardState, deckPlayer0, deckPlayer1, false);
 		if (toRet != null) { //summon succeeded, now let's use up our mana
 			toRet.data_.getCurrentPlayer().subtractMana(this.mana_);
 			toRet.data_.removeCard_hand(this);
@@ -753,7 +721,7 @@ public class Minion extends BaseEntity {
 			for (BattlecryTargetType btt : this.getBattlecryTargets()) {
 				switch  (btt) {
 				case NO_TARGET:
-					toRet = this.useUntargetableBattlecry(targetMinion, toRet, deckPlayer0, deckPlayer1, singleRealizationOnly);
+					toRet = this.useUntargetableBattlecry((Minion) targetMinion, toRet, deckPlayer0, deckPlayer1, singleRealizationOnly);
 					break;
 				case ENEMY_HERO:
 					toRet = this.useTargetableBattlecry(PlayerSide.WAITING_PLAYER, PlayerSide.WAITING_PLAYER.getPlayer(toRet).getHero(), toRet, deckPlayer0, deckPlayer1);
@@ -841,7 +809,7 @@ public class Minion extends BaseEntity {
 	 */
 	public HearthTreeNode summonMinion(
             PlayerSide targetSide,
-            Minion targetMinion,
+            BaseEntity targetMinion,
             HearthTreeNode boardState,
             Deck deckPlayer0,
             Deck deckPlayer1,
@@ -900,13 +868,14 @@ public class Minion extends BaseEntity {
 	 */
 	protected HearthTreeNode summonMinion_core(
             PlayerSide targetSide,
-			Minion targetMinion,
+			BaseEntity targetMinion,
 			HearthTreeNode boardState,
             Deck deckPlayer0,
             Deck deckPlayer1
 			)
 		throws HSException
 	{		
+		
 		if (boardState.data_.modelForSide(targetSide).getNumMinions() < 7) {
 
 			if (!charge_) {
@@ -1042,303 +1011,6 @@ public class Minion extends BaseEntity {
 	// Hooks for various events
 	//======================================================================================	
 
-	/**
-	 * 
-	 * Called whenever another minion comes on board
-	 *  @param boardState The BoardState before this card has performed its action.  It will be manipulated and returned.
-     *
-     * */
-	public HearthTreeNode minionPlacedEvent(
-            HearthTreeNode boardState)
-		throws HSInvalidPlayerIndexException
-	{
-		return boardState;
-	}
-
-
-	/**
-	 * 
-	 * Called whenever another minion is summoned using a spell
-	 * 
-	 *
-     * @param thisMinionPlayerSide
-     * @param summonedMinionPlayerSide
-     * @param summonedMinion The summoned minion
-     * @param boardState The BoardState before this card has performed its action.  It will be manipulated and returned.
-     * @param deckPlayer0 The deck of player0    @return The boardState is manipulated and returned
-     * */
-	public HearthTreeNode minionSummonedEvent(
-			PlayerSide thisMinionPlayerSide,
-			PlayerSide summonedMinionPlayerSide,
-			Minion summonedMinion,
-			HearthTreeNode boardState,
-			Deck deckPlayer0,
-			Deck deckPlayer1)
-		throws HSInvalidPlayerIndexException
-	{
-		return boardState;
-	}
-	
-	/**
-	 * 
-	 * Called whenever another minion is summoned using a spell
-	 *  @param thisMinionPlayerSide The player index of this minion
-	 * @param transformedMinionPlayerSide
-     * @param transformedMinion The transformed minion (the minion that resulted from a transformation)
-     * @param boardState The BoardState before this card has performed its action.  It will be manipulated and returned.
-     * @param deckPlayer0 The deck of player0    @return The boardState is manipulated and returned
-     * */
-	public HearthTreeNode minionTransformedEvent(
-			PlayerSide thisMinionPlayerSide,
-			PlayerSide transformedMinionPlayerSide,
-			Minion transformedMinion,
-			HearthTreeNode boardState,
-			Deck deckPlayer0,
-			Deck deckPlayer1)
-		throws HSInvalidPlayerIndexException
-	{
-		return boardState;
-	}
 
-	/**
-	 * 
-	 * Called whenever another minion is attacking another character
-	 * 
-	 *  @param boardState The BoardState before this card has performed its action.  It will be manipulated and returned.
-     *
-     * */
-	public HearthTreeNode minionAttackingEvent(
-            HearthTreeNode boardState)
-		throws HSInvalidPlayerIndexException
-	{
-		return boardState;
-	}
-	
-	/**
-	 * 
-	 * Called whenever another minion is damaged
-	 * 
-	 *
-     * @param thisMinionPlayerSide
-     * @param damagedPlayerSide
-     * @param damagedMinion The damaged minion
-     * @param boardState The BoardState before this card has performed its action.  It will be manipulated and returned.
-     * @param deckPlayer0 The deck of player0    @return The boardState is manipulated and returned
-     * */
-	public HearthTreeNode minionDamagedEvent(
-			PlayerSide thisMinionPlayerSide,
-			PlayerSide damagedPlayerSide,
-			Minion damagedMinion,
-			HearthTreeNode boardState,
-			Deck deckPlayer0,
-			Deck deckPlayer1)
-		throws HSInvalidPlayerIndexException
-	{
-		return boardState;
-	}
-	
-	/**
-	 * 
-	 * Called whenever another minion dies
-	 * 
-	 *
-     * @param thisMinionPlayerSide
-     * @param deadMinionPlayerSide
-     * @param deadMinion The dead minion
-     * @param boardState The BoardState before this card has performed its action.  It will be manipulated and returned.
-     * @param deckPlayer0 The deck of player0    @return The boardState is manipulated and returned
-     * */
-	public HearthTreeNode minionDeadEvent(
-			PlayerSide thisMinionPlayerSide,
-			PlayerSide deadMinionPlayerSide,
-			Minion deadMinion,
-			HearthTreeNode boardState,
-			Deck deckPlayer0,
-			Deck deckPlayer1)
-		throws HSInvalidPlayerIndexException
-	{
-		return boardState;
-	}
-	
-	/**
-	 * 
-	 * Called whenever another character (including the hero) is healed
-	 * 
-	 *
-     * @param thisMinionPlayerSide
-     * @param healedMinionPlayerSide
-     * @param healedMinion The healed minion
-     * @param boardState The BoardState before this card has performed its action.  It will be manipulated and returned.
-     * @param deckPlayer0 The deck of player0    @return The boardState is manipulated and returned
-     * */
-	public HearthTreeNode minionHealedEvent(
-			PlayerSide thisMinionPlayerSide,
-			PlayerSide healedMinionPlayerSide,
-			Minion healedMinion,
-			HearthTreeNode boardState,
-			Deck deckPlayer0,
-			Deck deckPlayer1)
-		throws HSInvalidPlayerIndexException
-	{
-		return boardState;
-	}
-
-	
-	@Override
-	public JSONObject toJSON() {
-		JSONObject json = super.toJSON();
-		json.put("attack", attack_);
-		json.put("baseAttack", baseAttack_);
-		json.put("health", health_);
-		json.put("baseHealth", baseHealth_);
-		json.put("maxHealth", maxHealth_);
-		json.put("taunt", taunt_);
-		json.put("divineShield", divineShield_);
-		json.put("windFury", windFury_);
-		json.put("charge", charge_);
-		json.put("frozen", frozen_);
-		json.put("silenced", silenced_);
-		json.put("hasAttacked", hasAttacked_);
-		return json;
-	}
-	
-	/**
-	 * Deep copy of the object
-	 * 
-	 * Note: the event actions are not actually deep copied.
-	 */
-	@Override
-	public Object deepCopy() {
-
-        Minion minion = null;
-        try {
-            minion = getClass().newInstance();
-        } catch (InstantiationException e) {
-            log.error("instantiation error", e);
-        } catch (IllegalAccessException e) {
-            log.error("illegal access error", e);
-        }
-        if (minion == null) {
-            throw new RuntimeException("unable to instantiate minion.");
-        }
-
-
-        minion.name_ = name_;
-        minion.mana_ = mana_;
-        minion.attack_ = attack_;
-        minion.health_ = health_;
-        minion.baseAttack_ = baseAttack_;
-        minion.extraAttackUntilTurnEnd_ = extraAttackUntilTurnEnd_;
-        minion.auraAttack_ = auraAttack_;
-        minion.baseHealth_ = baseHealth_;
-        minion.maxHealth_ = maxHealth_;
-        minion.auraHealth_ = auraHealth_;
-        minion.spellDamage_ = spellDamage_;
-        minion.taunt_ = taunt_;
-        minion.divineShield_ = divineShield_;
-        minion.windFury_ = windFury_;
-        minion.charge_ = charge_;
-        minion.hasAttacked_ = hasAttacked_;
-        minion.hasWindFuryAttacked_ = hasWindFuryAttacked_;
-        minion.frozen_ = frozen_;
-        minion.silenced_ = silenced_;
-        minion.stealthed_ = stealthed_;
-        minion.heroTargetable_ = heroTargetable_;
-        minion.summoned_ = summoned_;
-        minion.transformed_ = transformed_;
-        minion.destroyOnTurnStart_ = destroyOnTurnStart_;
-        minion.destroyOnTurnEnd_ = destroyOnTurnEnd_;
-        minion.deathrattleAction_ = deathrattleAction_;
-        minion.attackAction_ = attackAction_;
-        minion.isInHand_ = isInHand_;
-        minion.hasBeenUsed = hasBeenUsed;
-        //todo: continue here.
-
-
-        return minion;
-    }
-
-    @Override
-	public boolean equals(Object other) {
-		if (!super.equals(other)) {
-			return false;
-		}
-		
-		Minion otherMinion = (Minion)other;
-		if (health_ != otherMinion.health_) return false;
-		if (maxHealth_ != otherMinion.maxHealth_) return false;
-		if (baseHealth_ != otherMinion.baseHealth_) return false;
-		if (auraHealth_ != otherMinion.auraHealth_) return false;
-
-		if (attack_ != otherMinion.attack_) return false;
-		if (baseAttack_ != otherMinion.baseAttack_) return false;
-		if (extraAttackUntilTurnEnd_ != otherMinion.extraAttackUntilTurnEnd_) return false;
-		if (auraAttack_ != otherMinion.auraAttack_) return false;
-
-		if (taunt_ != otherMinion.taunt_) return false;
-		if (divineShield_ != otherMinion.divineShield_) return false;
-		if (windFury_ != otherMinion.windFury_) return false;
-		if (charge_ != otherMinion.charge_) return false;
-		if (stealthed_ != otherMinion.stealthed_) return false;
-		if (hasAttacked_ != otherMinion.hasAttacked_) return false;
-		if (heroTargetable_ != otherMinion.heroTargetable_) return false;
-		if (hasWindFuryAttacked_ != otherMinion.hasWindFuryAttacked_) return false;
-		if (frozen_ != otherMinion.frozen_) return false;
-		if (silenced_ != otherMinion.silenced_) return false;
-		if (summoned_ != otherMinion.summoned_) return false;
-		if (transformed_ != otherMinion.transformed_) return false;
-		if (destroyOnTurnStart_ != otherMinion.destroyOnTurnStart_) return false;
-		if (destroyOnTurnEnd_ != otherMinion.destroyOnTurnEnd_) return false;
-		
-		if (spellDamage_ != otherMinion.spellDamage_) return false;
-
-		//This is checked for reference equality
-		if (deathrattleAction_ != ((Minion)other).deathrattleAction_)
-			return false;
-		
-		//This is checked for reference equality
-		if (attackAction_ != ((Minion)other).attackAction_)
-			return false;
-		
-		return true;
-	}
-
-    @Override
-    public int hashCode() {
-        int result = super.hashCode();
-        result = 31 * result + (taunt_ ? 1 : 0);
-        result = 31 * result + (divineShield_ ? 1 : 0);
-        result = 31 * result + (windFury_ ? 1 : 0);
-        result = 31 * result + (charge_ ? 1 : 0);
-        result = 31 * result + (hasAttacked_ ? 1 : 0);
-        result = 31 * result + (hasWindFuryAttacked_ ? 1 : 0);
-        result = 31 * result + (frozen_ ? 1 : 0);
-        result = 31 * result + (silenced_ ? 1 : 0);
-        result = 31 * result + (stealthed_ ? 1 : 0);
-        result = 31 * result + (heroTargetable_ ? 1 : 0);
-        result = 31 * result + (int) health_;
-        result = 31 * result + (int) maxHealth_;
-        result = 31 * result + (int) baseHealth_;
-        result = 31 * result + (int) auraHealth_;
-        result = 31 * result + (int) attack_;
-        result = 31 * result + (int) baseAttack_;
-        result = 31 * result + (int) extraAttackUntilTurnEnd_;
-        result = 31 * result + (int) auraAttack_;
-        result = 31 * result + (summoned_ ? 1 : 0);
-        result = 31 * result + (transformed_ ? 1 : 0);
-        result = 31 * result + (destroyOnTurnStart_ ? 1 : 0);
-        result = 31 * result + (destroyOnTurnEnd_ ? 1 : 0);
-        result = 31 * result + (int) spellDamage_;
-        result = 31 * result + (deathrattleAction_ != null ? deathrattleAction_.hashCode() : 0);
-        result = 31 * result + (attackAction_ != null ? attackAction_.hashCode() : 0);
-        result = 31 * result + (placementImportant_ ? 1 : 0);
-        return result;
-    }
-
-    public boolean currentPlayerBoardFull(HearthTreeNode boardState) {
-        return PlayerSide.CURRENT_PLAYER.getPlayer(boardState).getNumMinions() >= 7;
-    }
-    
-    
     
 }
diff --git a/src/main/java/com/hearthsim/card/minion/NewMinion.java b/src/main/java/com/hearthsim/card/minion/NewMinion.java
new file mode 100644
index 0000000..a1378de
--- /dev/null
+++ b/src/main/java/com/hearthsim/card/minion/NewMinion.java
@@ -0,0 +1,1016 @@
+package com.hearthsim.card.minion;
+
+import com.hearthsim.card.Card;
+import com.hearthsim.card.Deck;
+import com.hearthsim.card.ImplementedCardList;
+import com.hearthsim.entity.BaseEntity;
+import com.hearthsim.event.attack.AttackAction;
+import com.hearthsim.event.deathrattle.DeathrattleAction;
+import com.hearthsim.exception.HSException;
+import com.hearthsim.exception.HSInvalidPlayerIndexException;
+import com.hearthsim.model.BoardModel;
+import com.hearthsim.model.PlayerSide;
+import com.hearthsim.util.factory.BoardStateFactoryBase;
+import com.hearthsim.util.tree.HearthTreeNode;
+import org.json.JSONObject;
+
+import java.util.EnumSet;
+import java.util.Iterator;
+
+public class NewMinion extends BaseEntity {
+
+	public enum BattlecryTargetType {
+		NO_BATTLECRY,
+		NO_TARGET,
+		FRIENDLY_HERO, ENEMY_HERO,
+    	FRIENDLY_MINIONS, ENEMY_MINIONS,
+    	FRIENDLY_BEASTS, ENEMY_BEASTS,
+    	FRIENDLY_MURLOCS, ENEMY_MURLOCS
+    }
+	
+	//This is a flag to tell the BoardState that it can't cheat on the placement of this minion
+	protected boolean placementImportant_ = false;
+
+    public NewMinion() {
+        super();
+        ImplementedCardList cardList = ImplementedCardList.getInstance();
+        ImplementedCardList.ImplementedCard implementedCard = cardList.getCardForClass(this.getClass());
+        if (implementedCard!=null){
+            // only 'Minion' class is not implemented
+            mana_ = (byte) implementedCard.mana_;
+            name_ = implementedCard.name_;
+            //attack_ = (byte) implementedCard.attack_;
+            baseAttack_ = attack_;
+            //health_ = (byte) implementedCard.health_;
+            maxHealth_ = health_;
+            baseHealth_ = health_;
+            taunt_ = implementedCard.taunt_;
+            divineShield_ = implementedCard.divineShield_;
+            windFury_ = implementedCard.windfury_;
+            charge_ = implementedCard.charge_;
+            stealthed_ = implementedCard.stealth_;
+            isInHand_ = true;
+            //todo: spellpower could be deduced from text quite easily
+        }
+
+    }
+
+    /**
+	 * Simplified constructor
+	 * 
+	 * @param name
+	 * @param mana
+	 * @param attack
+	 * @param health
+	 * @param baseAttack
+	 * @param baseHealth
+	 * @param maxHealth
+	 */
+	public NewMinion(String name, byte mana, byte attack, byte health, byte baseAttack, byte baseHealth, byte maxHealth) {
+		this(
+				name,
+				mana,
+				attack,
+				health,
+				baseAttack,
+				(byte)0,
+				(byte)0,
+				baseHealth,
+				maxHealth,
+				(byte)0,
+				(byte)0,
+				false,
+				false,
+				false,
+				false,
+				false,
+				false,
+				false,
+				false,
+				false,
+				true,
+				false,
+				false,
+				false,
+				false,
+				null,
+				null,
+				true,
+				false);
+		
+	}
+
+	public NewMinion(	String name,
+					byte mana,
+					byte attack,
+					byte health,
+					byte baseAttack,
+					byte extraAttackUntilTurnEnd,
+					byte auraAttack,
+					byte baseHealth,
+					byte maxHealth,
+					byte auraHealth,
+					byte spellDamage,
+					boolean taunt,
+					boolean divineShield,
+					boolean windFury,
+					boolean charge,
+					boolean hasAttacked,
+					boolean hasWindFuryAttacked,
+					boolean frozen,
+					boolean silenced,
+					boolean stealthed,
+					boolean heroTargetable,
+					boolean summoned,
+					boolean transformed,
+					boolean destroyOnTurnStart,
+					boolean destroyOnTurnEnd,
+					DeathrattleAction deathrattleAction,
+					AttackAction attackAction,
+					boolean isInHand,
+					boolean hasBeenUsed) {
+		super(name, mana, hasBeenUsed, isInHand);
+		attack_ = attack;
+		health_ = health;
+		taunt_ = taunt;
+		divineShield_ = divineShield;
+		windFury_ = windFury;
+		charge_ = charge;
+		hasAttacked_ = hasAttacked;
+		baseAttack_ = baseAttack;
+		extraAttackUntilTurnEnd_ = extraAttackUntilTurnEnd;
+		hasWindFuryAttacked_ = hasWindFuryAttacked;
+		frozen_ = frozen;
+		silenced_ = silenced;
+		baseHealth_ = baseHealth;
+		maxHealth_ = maxHealth;
+		summoned_ = summoned;
+		transformed_ = transformed;
+		destroyOnTurnStart_ = destroyOnTurnStart;
+		destroyOnTurnEnd_ = destroyOnTurnEnd;
+		deathrattleAction_ = deathrattleAction;
+		attackAction_ = attackAction;
+
+		auraAttack_ = auraAttack;
+		auraHealth_ = auraHealth;
+
+		spellDamage_ = spellDamage;
+
+		stealthed_ = stealthed;
+		heroTargetable_ = heroTargetable;
+	}
+	
+	public boolean getTaunt() {
+		return taunt_;
+	}
+	
+	public void setTaunt(boolean taunt) {
+		taunt_ = taunt;
+	}
+	
+	public byte getHealth() {
+		return health_;
+	}
+	
+	public void setHealth(byte health) {
+		health_ = health;
+	}
+	
+	public void addHealth(byte value) {
+		health_ += value;
+	}
+	
+	public byte getMaxHealth() {
+		return maxHealth_;
+	}
+	
+	public void setMaxHealth(byte health) {
+		maxHealth_ = health;
+	}
+	
+	public void addMaxHealth(byte value) {
+		maxHealth_ += value;
+	}
+	
+	public byte getBaseHealth() {
+		return baseHealth_;
+	}
+	
+	public void setBaseHealth(byte health) {
+		baseHealth_ = health;
+	}
+	
+	public byte getAttack() {
+		return attack_;
+	}
+	
+	public void setAttack(byte attack) {
+		attack_ = attack;
+	}
+	
+	public void addAttack(byte value) {
+		attack_ += value;
+	}
+	
+	public boolean getDivineShield() {
+		return divineShield_;
+	}
+	
+	public void setDivineShield(boolean divineShield) {
+		divineShield_ = divineShield;
+	}
+	
+	public boolean hasAttacked() {
+		return hasAttacked_;
+	}
+	
+	public void hasAttacked(boolean hasAttacked) {
+		hasAttacked_ = hasAttacked;
+	}
+
+	public boolean hasWindFuryAttacked() {
+		return hasWindFuryAttacked_;
+	}
+	
+	public void hasWindFuryAttacked(boolean hasAttacked) {
+		hasWindFuryAttacked_ = hasAttacked;
+	}
+
+	public boolean getCharge() {
+		return charge_;
+	}
+	
+	public void setCharge(boolean value) {
+		charge_ = value;
+	}
+	
+	public boolean getFrozen() {
+		return frozen_;
+	}
+	
+	public void setFrozen(boolean value) {
+		frozen_ = value;
+	}
+	
+	public boolean getWindfury() {
+		return windFury_;
+	}
+	
+	public void setWindfury(boolean value) {
+		windFury_ = value;
+	}
+	
+	public boolean getSummoned() {
+		return summoned_;
+	}
+	
+	public void setSummoned(boolean value) {
+		summoned_ = value;
+	}
+	
+	public boolean getTransformed() {
+		return transformed_;
+	}
+	
+	public void setTransformed(boolean value) {
+		transformed_ = value;
+	}
+	
+	public byte getExtraAttackUntilTurnEnd() {
+		return extraAttackUntilTurnEnd_;
+	}
+	
+	public void setExtraAttackUntilTurnEnd(byte value) {
+		extraAttackUntilTurnEnd_ = value;
+	}
+	
+	public boolean getDestroyOnTurnStart() {
+		return destroyOnTurnStart_;
+	}
+	
+	public void setDestroyOnTurnStart(boolean value) {
+		destroyOnTurnStart_ = value;
+	}
+
+	public boolean getDestroyOnTurnEnd() {
+		return destroyOnTurnEnd_;
+	}
+	
+	public void setDestroyOnTurnEnd(boolean value) {
+		destroyOnTurnEnd_ = value;
+	}
+	
+	public boolean isSilenced() {
+		return silenced_;
+	}
+	
+	public boolean hasDeathrattle() {
+		return deathrattleAction_ != null;
+	}
+
+	public void setDeathrattle(DeathrattleAction action) {
+		deathrattleAction_ = action;
+	}
+	
+	public byte getAuraAttack() {
+		return auraAttack_;
+	}
+
+	public void setAuraAttack(byte value) {
+		auraAttack_ = value;
+	}
+
+	public byte getAuraHealth() {
+		return auraHealth_;
+	}
+
+	public void setAuraHealth(byte value) {
+		auraHealth_ = value;
+	}
+
+	public byte getTotalAttack() {
+		return (byte)(attack_ + auraAttack_ + extraAttackUntilTurnEnd_);
+	}
+	
+	public byte getTotalHealth() {
+		return (byte)(health_ + auraHealth_);
+	}
+	
+	public byte getTotalMaxHealth() {
+		return (byte)(maxHealth_ + auraHealth_);
+	}
+
+	
+	public void addAuraHealth(byte value) {
+		auraHealth_ += value;
+	}
+	
+	public void removeAuraHealth(byte value) {
+		health_ += value;
+		if (health_ > maxHealth_)
+			health_ = maxHealth_;
+		auraHealth_ -= value;
+	}
+	
+	public boolean getStealthed() {
+		return stealthed_;
+	}
+	
+	public void setStealthed(boolean value) {
+		stealthed_ = value;
+	}
+	
+	public boolean getPlacementImportant() {
+		return placementImportant_;
+	}
+	
+	public void setPlacementImportant(boolean value) {
+		placementImportant_ = value;
+	}
+	
+	public boolean isHeroTargetable() {
+		return heroTargetable_;
+	}
+	
+	public void setHeroTargetable(boolean value) {
+		heroTargetable_ = value;
+	}
+
+
+    /**
+	 * Called at the start of the turn
+	 * 
+	 * This function is called at the start of the turn.  Any derived class must override it to implement whatever
+	 * "start of the turn" effect the card has.
+	 */
+	@Override
+	public HearthTreeNode startTurn(PlayerSide thisMinionPlayerIndex, HearthTreeNode boardModel, Deck deckPlayer0, Deck deckPlayer1) throws HSException {
+		HearthTreeNode toRet = boardModel;
+		if (destroyOnTurnStart_) {
+//			toRet = this.destroyed(thisMinionPlayerIndex, toRet, deckPlayer0, deckPlayer1);
+			this.setHealth((byte)-99);
+		}
+		return toRet;
+	}
+	
+	/**
+	 * End the turn and resets the card state
+	 * 
+	 * This function is called at the end of the turn.  Any derived class must override it and remove any 
+	 * temporary buffs that it has.
+	 * 
+	 * This is not the most efficient implementation... luckily, endTurn only happens once per turn
+	 */
+	@Override
+	public HearthTreeNode endTurn(PlayerSide thisMinionPlayerIndex, HearthTreeNode boardModel, Deck deckPlayer0, Deck deckPlayer1) throws HSException {
+		extraAttackUntilTurnEnd_ = 0;
+		HearthTreeNode toRet = boardModel;
+		if (destroyOnTurnEnd_) {
+//			toRet = this.destroyed(thisMinionPlayerIndex, toRet, deckPlayer0, deckPlayer1);
+			this.setHealth((byte)-99);
+		}
+		return toRet;
+	}
+	
+	/**
+	 * Called when this minion takes damage
+	 * 
+	 * Always use this function to take damage... it properly notifies all others of its damage and possibly of its death
+	 *  @param damage The amount of damage to take
+	 * @param attackPlayerSide The player index of the attacker.  This is needed to do things like +spell damage.
+     * @param thisPlayerSide
+     * @param boardState
+     * @param deckPlayer0 The deck of player0
+     * @param isSpellDamage True if this is a spell damage
+     * @param handleMinionDeath Set this to True if you want the death event to trigger when (if) the minion dies from this damage.  Setting this flag to True will also trigger deathrattle immediately.
+     * @throws HSInvalidPlayerIndexException
+	 */
+	public HearthTreeNode takeDamage(
+			byte damage,
+			PlayerSide attackPlayerSide,
+			PlayerSide thisPlayerSide,
+			HearthTreeNode boardState,
+			Deck deckPlayer0, 
+			Deck deckPlayer1,
+			boolean isSpellDamage,
+			boolean handleMinionDeath)
+		throws HSException
+	{
+		Minion m = new Minion();
+		if (!divineShield_) {
+			byte totalDamage = isSpellDamage ? (byte)(damage + boardState.data_.getSpellDamage(attackPlayerSide)) : damage;
+			health_ = (byte)(health_ - totalDamage);
+			
+			//Notify all that the minion is damaged
+			HearthTreeNode toRet = boardState;
+			toRet = toRet.data_.getCurrentPlayerHero().minionDamagedEvent(PlayerSide.CURRENT_PLAYER, thisPlayerSide, this, toRet, deckPlayer0, deckPlayer1);
+			for (int j = 0; j < PlayerSide.CURRENT_PLAYER.getPlayer(toRet).getNumMinions(); ++j) {
+				if (!PlayerSide.CURRENT_PLAYER.getPlayer(toRet).getMinions().get(j).silenced_)
+					toRet = PlayerSide.CURRENT_PLAYER.getPlayer(toRet).getMinions().get(j).minionDamagedEvent(PlayerSide.CURRENT_PLAYER, thisPlayerSide, this, toRet, deckPlayer0, deckPlayer1);
+			}
+			toRet = toRet.data_.getWaitingPlayerHero().minionDamagedEvent(PlayerSide.WAITING_PLAYER, thisPlayerSide, this, toRet, deckPlayer0, deckPlayer1);
+			for (int j = 0; j < PlayerSide.WAITING_PLAYER.getPlayer(toRet).getNumMinions(); ++j) {
+				if (!PlayerSide.WAITING_PLAYER.getPlayer(toRet).getMinions().get(j).silenced_)
+					toRet = PlayerSide.WAITING_PLAYER.getPlayer(toRet).getMinions().get(j).minionDamagedEvent(PlayerSide.WAITING_PLAYER, thisPlayerSide, this, toRet, deckPlayer0, deckPlayer1);
+			}
+			
+			return toRet;
+		} else {
+			if (damage > 0)
+				divineShield_ = false;
+			return boardState;
+		}
+	}
+	
+	/**
+	 * Called when this minion dies (destroyed)
+	 * 
+	 * Always use this function to "kill" minions
+	 * 
+	 *
+     *
+     * @param thisPlayerSide
+     * @param boardState
+     * @param deckPlayer0
+     * @param deckPlayer1
+     *
+     * @throws HSInvalidPlayerIndexException
+	 */
+	public HearthTreeNode destroyed(PlayerSide thisPlayerSide, HearthTreeNode boardState, Deck deckPlayer0, Deck deckPlayer1) throws HSException {
+
+        health_ = 0;
+        HearthTreeNode toRet = boardState;
+
+        //perform the deathrattle action if there is one
+        if (deathrattleAction_ != null) {
+            toRet =  deathrattleAction_.performAction(this, thisPlayerSide, toRet, deckPlayer0, deckPlayer1);
+        }
+
+        //Notify all that it is dead
+        toRet = toRet.data_.getCurrentPlayerHero().minionDeadEvent(PlayerSide.CURRENT_PLAYER, thisPlayerSide, this, toRet, deckPlayer0, deckPlayer1);
+        for (int j = 0; j < PlayerSide.CURRENT_PLAYER.getPlayer(toRet).getNumMinions(); ++j) {
+            if (!PlayerSide.CURRENT_PLAYER.getPlayer(toRet).getMinions().get(j).silenced_)
+                toRet = PlayerSide.CURRENT_PLAYER.getPlayer(toRet).getMinions().get(j).minionDeadEvent(PlayerSide.CURRENT_PLAYER, thisPlayerSide, this, toRet, deckPlayer0, deckPlayer1);
+        }
+        toRet = toRet.data_.getWaitingPlayerHero().minionDeadEvent(PlayerSide.WAITING_PLAYER, thisPlayerSide, this, toRet, deckPlayer0, deckPlayer1);
+        for (int j = 0; j < PlayerSide.WAITING_PLAYER.getPlayer(toRet).getNumMinions(); ++j) {
+            if (!PlayerSide.WAITING_PLAYER.getPlayer(toRet).getMinions().get(j).silenced_)
+                toRet = PlayerSide.WAITING_PLAYER.getPlayer(toRet).getMinions().get(j).minionDeadEvent(PlayerSide.WAITING_PLAYER, thisPlayerSide, this, toRet, deckPlayer0, deckPlayer1);
+        }
+
+        return toRet;
+
+	}
+
+	
+	public void silenced(PlayerSide thisPlayerSide, HearthTreeNode boardState) throws HSInvalidPlayerIndexException {
+		this.silenced(thisPlayerSide, boardState.data_);
+	}
+	
+	/**
+	 * Called when this minion is silenced
+	 * 
+	 * Always use this function to "silence" minions
+     *
+     * @param thisPlayerSide
+     * @param boardState
+     * @throws HSInvalidPlayerIndexException
+	 */
+	public void silenced(PlayerSide thisPlayerSide, BoardModel boardState) throws HSInvalidPlayerIndexException {
+		if (!silenced_) {
+			boardState.setSpellDamage(PlayerSide.CURRENT_PLAYER, (byte)(boardState.getSpellDamage(PlayerSide.CURRENT_PLAYER) - spellDamage_));
+		}
+
+		divineShield_ = false;
+		taunt_ = false;
+		charge_ = false;
+		frozen_ = false;
+		windFury_ = false;
+		silenced_ = true;
+		deathrattleAction_ = null;
+		stealthed_ = false;
+		heroTargetable_ = true;
+		
+		//Reset the attack and health to base
+		this.attack_ = this.baseAttack_;
+		if (this.maxHealth_ > this.baseHealth_) {
+			this.maxHealth_ = this.baseHealth_;
+			if (this.health_ > this.maxHealth_)
+				this.health_ = this.maxHealth_;
+		}
+	}
+	
+	/**
+	 * Called when this minion is healed
+	 * 
+	 * Always use this function to heal minions
+	 *  @param healAmount The amount of healing to take
+	 * @param thisPlayerSide
+     * @param boardState
+     * @param deckPlayer0 The deck of player0   @throws HSInvalidPlayerIndexException
+     * */
+	public HearthTreeNode takeHeal(byte healAmount, PlayerSide thisPlayerSide, HearthTreeNode boardState, Deck deckPlayer0, Deck deckPlayer1) throws HSInvalidPlayerIndexException {
+		
+		if (health_ < maxHealth_) {
+			if (health_ + healAmount > maxHealth_)
+				health_ = maxHealth_;
+			else
+				health_ = (byte)(health_ + healAmount);
+			
+			//Notify all that it the minion is healed
+			HearthTreeNode toRet = boardState;
+			toRet = toRet.data_.getCurrentPlayerHero().minionHealedEvent(PlayerSide.CURRENT_PLAYER, thisPlayerSide, this, toRet, deckPlayer0, deckPlayer1);
+            for (Minion minion : PlayerSide.CURRENT_PLAYER.getPlayer(toRet).getMinions()) {
+                if (!minion.silenced_)
+                    toRet = minion.minionHealedEvent(PlayerSide.CURRENT_PLAYER, thisPlayerSide, this, toRet, deckPlayer0, deckPlayer1);
+            }
+			toRet = toRet.data_.getWaitingPlayerHero().minionHealedEvent(PlayerSide.WAITING_PLAYER, thisPlayerSide, this, toRet, deckPlayer0, deckPlayer1);
+            for (Minion minion : PlayerSide.WAITING_PLAYER.getPlayer(toRet).getMinions()) {
+                if (!minion.silenced_)
+                    toRet = minion.minionHealedEvent(PlayerSide.WAITING_PLAYER, thisPlayerSide, this, toRet, deckPlayer0, deckPlayer1);
+            }
+			return toRet;
+		}
+		return boardState;
+	}
+	
+	
+	@Override
+    public boolean canBeUsedOn(PlayerSide playerSide, Minion minion, BoardModel boardModel) {
+        return playerSide != PlayerSide.WAITING_PLAYER && !hasBeenUsed;
+    }
+
+	/**
+	 * Use a targetable battlecry.
+	 * 
+	 * @param side
+	 * @param targetMinion
+	 * @param boardState
+	 * @param deckPlayer0
+	 * @param deckPlayer1
+	 * @return
+	 * @throws HSException
+	 */
+	public HearthTreeNode useTargetableBattlecry(
+			PlayerSide side,
+			Minion targetMinion,
+			HearthTreeNode boardState,
+			Deck deckPlayer0,
+			Deck deckPlayer1
+		) throws HSException
+	{
+		HearthTreeNode node = new HearthTreeNode((BoardModel)boardState.data_.deepCopy());
+		int targetMinionIndex = side.getPlayer(boardState).getMinions().indexOf(targetMinion);
+		if (targetMinionIndex >= 0) {
+			node = this.useTargetableBattlecry_core(side, side.getPlayer(node).getMinions().get(targetMinionIndex), node, deckPlayer0, deckPlayer1);
+		} else if (targetMinion instanceof Hero) {
+			node = this.useTargetableBattlecry_core(side, side.getPlayer(node).getHero(), node, deckPlayer0, deckPlayer1);
+		} else {
+			node = null;
+		}
+		if (node != null) {
+			//Check for dead minions
+			node = BoardStateFactoryBase.handleDeadMinions(node, deckPlayer0, deckPlayer1);
+			//add the new node to the tree
+			boardState.addChild(node);
+		}
+		return boardState;
+	}
+
+	/**
+	 * Derived classes should implement this function for targtable battlecries.
+	 * 
+	 * @param side
+	 * @param targetMinion
+	 * @param boardState
+	 * @param deckPlayer0
+	 * @param deckPlayer1
+	 * @return
+	 * @throws HSException
+	 */
+	public HearthTreeNode useTargetableBattlecry_core(
+			PlayerSide side,
+			Minion targetMinion,
+			HearthTreeNode boardState,
+			Deck deckPlayer0,
+			Deck deckPlayer1
+		) throws HSException
+	{
+		return null;
+	}
+	
+	public EnumSet<BattlecryTargetType> getBattlecryTargets() {
+		return EnumSet.of(BattlecryTargetType.NO_BATTLECRY);
+	}
+	
+	
+	/**
+	 * Use an untargetable battlecry.  
+	 * 
+	 * @param minionPlacementTarget
+	 * @param boardState
+	 * @param deckPlayer0
+	 * @param deckPlayer1
+	 * @param singleRealizationOnly
+	 * @return
+	 * @throws HSException
+	 */
+	public HearthTreeNode useUntargetableBattlecry(
+			Minion minionPlacementTarget,
+			HearthTreeNode boardState,
+			Deck deckPlayer0,
+			Deck deckPlayer1,
+			boolean singleRealizationOnly
+		) throws HSException
+	{
+		HearthTreeNode toRet = this.useUntargetableBattlecry_core(minionPlacementTarget, boardState, deckPlayer0, deckPlayer1, singleRealizationOnly);
+		if (toRet != null) {
+			//Check for dead minions
+			toRet = BoardStateFactoryBase.handleDeadMinions(toRet, deckPlayer0, deckPlayer1);
+		}
+		return toRet;
+	}
+	
+	public HearthTreeNode useUntargetableBattlecry_core(
+			Minion minionPlacementTarget,
+			HearthTreeNode boardState,
+			Deck deckPlayer0,
+			Deck deckPlayer1,
+			boolean singleRealizationOnly
+		) throws HSException
+	{
+		return null;
+	}	
+	/**
+	 * 
+	 * Places a minion on the board by using the card in hand
+	 * 
+	 *
+     *
+     * @param side
+     * @param targetMinion The target minion (can be a Hero).  The new minion is always placed to the right of (higher index) the target minion.  If the target minion is a hero, then it is placed at the left-most position.
+     * @param boardState The BoardState before this card has performed its action.  It will be manipulated and returned.
+     * @param deckPlayer0 The deck of player0
+     * @return The boardState is manipulated and returned
+	 * @throws HSException 
+	 */
+	
+	protected HearthTreeNode use_core(
+			PlayerSide side,
+			BaseEntity targetMinion,
+			HearthTreeNode boardState,
+			Deck deckPlayer0,
+			Deck deckPlayer1,
+			boolean singleRealizationOnly)
+		throws HSException
+	{
+		if (hasBeenUsed) {
+			//Card is already used, nothing to do
+			return null;
+		}
+		
+		if (side == PlayerSide.WAITING_PLAYER)
+			return null;
+		
+		HearthTreeNode toRet = this.summonMinion(side, targetMinion, boardState, deckPlayer0, deckPlayer1, false);
+		if (toRet != null) { //summon succeeded, now let's use up our mana
+			toRet.data_.getCurrentPlayer().subtractMana(this.mana_);
+			toRet.data_.removeCard_hand(this);
+
+			//Battlecry if available
+			for (BattlecryTargetType btt : this.getBattlecryTargets()) {
+				switch  (btt) {
+				case NO_TARGET:
+					toRet = this.useUntargetableBattlecry(targetMinion, toRet, deckPlayer0, deckPlayer1, singleRealizationOnly);
+					break;
+				case ENEMY_HERO:
+					toRet = this.useTargetableBattlecry(PlayerSide.WAITING_PLAYER, PlayerSide.WAITING_PLAYER.getPlayer(toRet).getHero(), toRet, deckPlayer0, deckPlayer1);
+					break;
+				case FRIENDLY_HERO:
+					toRet = this.useTargetableBattlecry(PlayerSide.CURRENT_PLAYER, PlayerSide.CURRENT_PLAYER.getPlayer(toRet).getHero(), toRet, deckPlayer0, deckPlayer1);
+					break;
+				case ENEMY_MINIONS:
+					for (Minion minion : PlayerSide.WAITING_PLAYER.getPlayer(toRet).getMinions()) {
+						toRet = this.useTargetableBattlecry(PlayerSide.WAITING_PLAYER, minion, toRet, deckPlayer0, deckPlayer1);
+					}
+					break;
+				case FRIENDLY_MINIONS:
+					for (Minion minion : PlayerSide.CURRENT_PLAYER.getPlayer(toRet).getMinions()) {
+						if (minion != this)
+							toRet = this.useTargetableBattlecry(PlayerSide.CURRENT_PLAYER, minion, toRet, deckPlayer0, deckPlayer1);
+					}
+					break;
+				case ENEMY_BEASTS:
+					for (Minion minion : PlayerSide.WAITING_PLAYER.getPlayer(toRet).getMinions()) {
+						if (minion instanceof Beast)
+							toRet = this.useTargetableBattlecry(PlayerSide.WAITING_PLAYER, minion, toRet, deckPlayer0, deckPlayer1);
+					}
+					break;
+				case FRIENDLY_BEASTS:
+					for (Minion minion : PlayerSide.CURRENT_PLAYER.getPlayer(toRet).getMinions()) {
+						if (minion != this && minion instanceof Beast)
+							toRet = this.useTargetableBattlecry(PlayerSide.CURRENT_PLAYER, minion, toRet, deckPlayer0, deckPlayer1);
+					}
+					break;
+				case ENEMY_MURLOCS:
+					for (Minion minion : PlayerSide.WAITING_PLAYER.getPlayer(toRet).getMinions()) {
+						if (minion instanceof Murloc)
+							toRet = this.useTargetableBattlecry(PlayerSide.WAITING_PLAYER, minion, toRet, deckPlayer0, deckPlayer1);
+					}
+					break;
+				case FRIENDLY_MURLOCS:
+					for (Minion minion : PlayerSide.CURRENT_PLAYER.getPlayer(toRet).getMinions()) {
+						if (minion != this && minion instanceof Murloc)
+							toRet = this.useTargetableBattlecry(PlayerSide.CURRENT_PLAYER, minion, toRet, deckPlayer0, deckPlayer1);
+					}
+					break;
+				default:
+					break;
+				}
+			}
+			
+			
+			//Notify all that a minion is placed
+			toRet = toRet.data_.getCurrentPlayerHero().minionPlacedEvent(toRet);
+			for (Iterator<Minion> iter = toRet.data_.getCurrentPlayer().getMinions().iterator(); iter.hasNext();) {
+				Minion minion = iter.next();
+				if (!minion.silenced_)
+					toRet = minion.minionPlacedEvent(toRet);
+			}
+			toRet = toRet.data_.getWaitingPlayerHero().minionPlacedEvent(toRet);
+			for (Iterator<Minion> iter = toRet.data_.getWaitingPlayer().getMinions().iterator(); iter.hasNext();) {
+				Minion minion = iter.next();
+				if (!minion.silenced_)
+					toRet = minion.minionPlacedEvent(toRet);
+			}
+		
+		}
+		
+		return toRet;
+	}
+	
+	
+	
+	/**
+	 * 
+	 * Places a minion on the board via a summon effect
+	 * 
+	 * This function is meant to be used when summoning minions through means other than a direct card usage.
+	 * 
+	 *
+     * @param targetSide
+     * @param targetMinion The target minion (can be a Hero).  If it is a Hero, then the minion is placed on the last (right most) spot on the board.
+     * @param boardState The BoardState before this card has performed its action.  It will be manipulated and returned.
+     * @param deckPlayer0 The deck of player0
+     * @param deckPlayer1 The deck of player1
+     * @param wasTransformed If the minion was 'summoned' as a result of a transform effect (e.g. Hex, Polymorph), set this to true.
+     *
+     * @return The boardState is manipulated and returned
+	 */
+	public HearthTreeNode summonMinion(
+            PlayerSide targetSide,
+            Minion targetMinion,
+            HearthTreeNode boardState,
+            Deck deckPlayer0,
+            Deck deckPlayer1,
+            boolean wasTransformed)
+		throws HSException
+	{
+		HearthTreeNode toRet = this.summonMinion_core(targetSide, targetMinion, boardState, deckPlayer0, deckPlayer1);
+		
+		if (toRet != null) {
+			toRet.data_.addSpellDamage(targetSide, this.spellDamage_);
+			if (!wasTransformed) {
+				//Notify all that a minion is summoned
+
+				toRet = toRet.data_.getCurrentPlayerHero().minionSummonedEvent(PlayerSide.CURRENT_PLAYER, targetSide, this, toRet, deckPlayer0, deckPlayer1);
+                for (Minion minion : PlayerSide.CURRENT_PLAYER.getPlayer(toRet).getMinions()) {
+                    if (!minion.silenced_)
+                        toRet = minion.minionSummonedEvent(PlayerSide.CURRENT_PLAYER, targetSide, this, toRet, deckPlayer0, deckPlayer1);
+                }
+				toRet = toRet.data_.getWaitingPlayerHero().minionSummonedEvent(PlayerSide.WAITING_PLAYER, targetSide, this, toRet, deckPlayer0, deckPlayer1);
+                for (Minion minion : PlayerSide.WAITING_PLAYER.getPlayer(toRet).getMinions()) {
+                    if (!minion.silenced_)
+                        toRet = minion.minionSummonedEvent(PlayerSide.WAITING_PLAYER, targetSide, this, toRet, deckPlayer0, deckPlayer1);
+                }
+			} else {
+				//Notify all that a minion is transformed
+				toRet = toRet.data_.getCurrentPlayerHero().minionTransformedEvent(PlayerSide.CURRENT_PLAYER, targetSide, this, toRet, deckPlayer0, deckPlayer1);
+                for (Minion minion : PlayerSide.CURRENT_PLAYER.getPlayer(toRet).getMinions()) {
+                    if (!minion.silenced_)
+                        toRet = minion.minionTransformedEvent(PlayerSide.CURRENT_PLAYER, targetSide, this, toRet, deckPlayer0, deckPlayer1);
+                }
+				toRet = toRet.data_.getWaitingPlayerHero().minionTransformedEvent(PlayerSide.WAITING_PLAYER, targetSide, this, toRet, deckPlayer0, deckPlayer1);
+                for (Minion minion : PlayerSide.WAITING_PLAYER.getPlayer(toRet).getMinions()) {
+                    if (!minion.silenced_)
+                        toRet = minion.minionTransformedEvent(PlayerSide.WAITING_PLAYER, targetSide, this, toRet, deckPlayer0, deckPlayer1);
+                }
+			}
+		}
+		
+		return toRet;
+	}
+	
+	/**
+	 * 
+	 * Places a minion on the board via a summon effect
+	 * 
+	 * This function is meant to be used when summoning minions through means other than a direct card usage.
+	 * 
+	 *
+     * @param targetSide
+     * @param targetMinion The target minion (can be a Hero).  The new minion is always placed to the right of (higher index) the target minion.  If the target minion is a hero, then it is placed at the left-most position.
+     * @param boardState The BoardState before this card has performed its action.  It will be manipulated and returned.
+     * @return The boardState is manipulated and returned
+     * @param deckPlayer0 The deck of player0
+     * @param deckPlayer1 The deck of player1
+	 * @throws HSException 
+	 */
+	protected HearthTreeNode summonMinion_core(
+            PlayerSide targetSide,
+			Minion targetMinion,
+			HearthTreeNode boardState,
+            Deck deckPlayer0,
+            Deck deckPlayer1
+			)
+		throws HSException
+	{		
+		
+		if (boardState.data_.modelForSide(targetSide).getNumMinions() < 7) {
+
+			if (!charge_) {
+				hasAttacked_ = true;
+			}
+			hasBeenUsed = true;
+			if (isHero(targetMinion))
+				boardState.data_.placeMinion(targetSide, this, 0);
+			else
+				boardState.data_.placeMinion(targetSide, this, targetSide.getPlayer(boardState).getMinions().indexOf(targetMinion) + 1);
+			return boardState;
+							
+		} else {
+			return null;
+		}
+
+	}
+	/**
+	 * 
+	 * Attack with the minion
+	 * 
+	 *
+     *
+     * @param targetMinionPlayerSide
+     * @param targetMinion The target minion
+     * @param boardState The BoardState before this card has performed its action.  It will be manipulated and returned.
+     * @param deckPlayer0 The deck of player0
+     * @return The boardState is manipulated and returned
+	 */
+	public HearthTreeNode attack(
+			PlayerSide targetMinionPlayerSide,
+			Minion targetMinion,
+			HearthTreeNode boardState,
+			Deck deckPlayer0,
+			Deck deckPlayer1)
+		throws HSException
+	{
+		
+		//can't attack a stealthed target
+		if (targetMinion.getStealthed())
+			return null;
+		
+		if (frozen_) {
+			this.hasAttacked_ = true;
+			this.frozen_ = false;
+			return boardState;
+		}
+		
+		//Notify all that an attack is beginning
+		HearthTreeNode toRet = boardState;
+		if (toRet != null) {
+			//Notify all that a minion is created
+			toRet = toRet.data_.getCurrentPlayerHero().minionAttackingEvent(toRet);
+            for (Minion minion : PlayerSide.CURRENT_PLAYER.getPlayer(toRet).getMinions()) {
+                if (!minion.silenced_)
+                    toRet = minion.minionAttackingEvent(toRet);
+            }
+			toRet = toRet.data_.getWaitingPlayerHero().minionAttackingEvent(toRet);
+            for (Minion minion : PlayerSide.WAITING_PLAYER.getPlayer(toRet).getMinions()) {
+                if (!minion.silenced_)
+                    toRet = minion.minionAttackingEvent(toRet);
+            }
+		}
+		
+		//Do the actual attack
+		toRet = this.attack_core(targetMinionPlayerSide, targetMinion, boardState, deckPlayer0, deckPlayer1);
+		
+		//check for and remove dead minions
+		if (toRet != null) {
+			toRet = BoardStateFactoryBase.handleDeadMinions(toRet, deckPlayer0, deckPlayer1);
+		}
+		
+		//Attacking means you lose stealth
+		if (toRet != null)
+			this.stealthed_ = false;
+		
+		return toRet;
+	}
+
+	/**
+	 * 
+	 * Attack with the minion
+	 * 
+	 *
+     *
+     * @param targetMinionPlayerSide
+     * @param targetMinion The target minion
+     * @param boardState The BoardState before this card has performed its action.  It will be manipulated and returned.
+     * @param deckPlayer0 The deck of player0
+     * @return The boardState is manipulated and returned
+	 */
+	protected HearthTreeNode attack_core(
+			PlayerSide targetMinionPlayerSide,
+			Minion targetMinion,
+			HearthTreeNode boardState,
+			Deck deckPlayer0,
+			Deck deckPlayer1)
+		throws HSException
+	{
+		
+		if (hasAttacked_) {
+			//minion has already attacked
+            log.debug("trying to attack when card has already attacked.");
+			return null;
+		}
+		
+		if (targetMinionPlayerSide == PlayerSide.CURRENT_PLAYER) {
+            log.debug("trying to attack ourself, derp..");
+			return null;
+		}
+		
+		if (this.getTotalAttack() <= 0) {
+            log.debug("unable to attack with zero attack damage.");
+            return null;
+        }
+
+		
+		HearthTreeNode toRet = boardState;
+		byte origAttack = targetMinion.getTotalAttack();
+		toRet = targetMinion.takeDamage(this.getTotalAttack(), PlayerSide.CURRENT_PLAYER, targetMinionPlayerSide, toRet, deckPlayer0, deckPlayer1, false, false);
+		toRet = this.takeDamage(origAttack, targetMinionPlayerSide, PlayerSide.CURRENT_PLAYER, toRet, deckPlayer0, deckPlayer1, false, false);
+		if (windFury_ && !hasWindFuryAttacked_)
+			hasWindFuryAttacked_ = true;
+		else
+			hasAttacked_ = true;
+		return toRet;
+
+	}
+
+
+	
+	//======================================================================================
+	// Hooks for various events
+	//======================================================================================	
+
+
+    
+}
diff --git a/src/main/java/com/hearthsim/card/minion/concrete/AbusiveSergeant.java b/src/main/java/com/hearthsim/card/minion/concrete/AbusiveSergeant.java
index b0afa15..a31f820 100644
--- a/src/main/java/com/hearthsim/card/minion/concrete/AbusiveSergeant.java
+++ b/src/main/java/com/hearthsim/card/minion/concrete/AbusiveSergeant.java
@@ -24,7 +24,7 @@ public class AbusiveSergeant extends Minion {
 	}
 
 	
-	@Override
+	
 	public EnumSet<BattlecryTargetType> getBattlecryTargets() {
 		return EnumSet.of(BattlecryTargetType.FRIENDLY_MINIONS, BattlecryTargetType.ENEMY_MINIONS);
 	}
@@ -32,7 +32,7 @@ public class AbusiveSergeant extends Minion {
 	/**
 	 * Battlecry: Give a minion +2 attack this turn
 	 */
-	@Override
+	
 	public HearthTreeNode useTargetableBattlecry_core(
 			PlayerSide side,
 			Minion targetMinion,
diff --git a/src/main/java/com/hearthsim/card/minion/concrete/AcidicSwampOoze.java b/src/main/java/com/hearthsim/card/minion/concrete/AcidicSwampOoze.java
index e13b65c..f85cab5 100644
--- a/src/main/java/com/hearthsim/card/minion/concrete/AcidicSwampOoze.java
+++ b/src/main/java/com/hearthsim/card/minion/concrete/AcidicSwampOoze.java
@@ -21,7 +21,7 @@ public class AcidicSwampOoze extends Minion {
         summoned_ = SUMMONED;
         transformed_ = TRANSFORMED;
 	}
-	@Override
+	
 	public EnumSet<BattlecryTargetType> getBattlecryTargets() {
 		return EnumSet.of(BattlecryTargetType.NO_TARGET);
 	}
@@ -29,7 +29,7 @@ public class AcidicSwampOoze extends Minion {
 	/**
 	 * Battlecry: Destroy your opponent's weapon
 	 */
-	@Override
+	
 	public HearthTreeNode useUntargetableBattlecry_core(
 			Minion minionPlacementTarget,
 			HearthTreeNode boardState,
diff --git a/src/main/java/com/hearthsim/card/minion/concrete/AcolyteOfPain.java b/src/main/java/com/hearthsim/card/minion/concrete/AcolyteOfPain.java
index 16745d9..cb533d3 100644
--- a/src/main/java/com/hearthsim/card/minion/concrete/AcolyteOfPain.java
+++ b/src/main/java/com/hearthsim/card/minion/concrete/AcolyteOfPain.java
@@ -32,7 +32,7 @@ public class AcolyteOfPain extends Minion {
      * @param boardState
      * @param isSpellDamage True if this is a spell damage   @throws HSException
      * */
-	@Override
+	
 	public HearthTreeNode takeDamage(
 			byte damage,
 			PlayerSide attackPlayerSide,
diff --git a/src/main/java/com/hearthsim/card/minion/concrete/AldorPeacekeeper.java b/src/main/java/com/hearthsim/card/minion/concrete/AldorPeacekeeper.java
index 6336ec3..0b43fbc 100644
--- a/src/main/java/com/hearthsim/card/minion/concrete/AldorPeacekeeper.java
+++ b/src/main/java/com/hearthsim/card/minion/concrete/AldorPeacekeeper.java
@@ -23,7 +23,7 @@ public class AldorPeacekeeper extends Minion {
         transformed_ = TRANSFORMED;
 	}
 
-	@Override
+	
 	public EnumSet<BattlecryTargetType> getBattlecryTargets() {
 		return EnumSet.of(BattlecryTargetType.ENEMY_MINIONS);
 	}
@@ -31,7 +31,7 @@ public class AldorPeacekeeper extends Minion {
 	/**
 	 * Battlecry: Change an enemy minion's attack to 1
 	 */
-	@Override
+	
 	public HearthTreeNode useTargetableBattlecry_core(
 			PlayerSide side,
 			Minion targetMinion,
diff --git a/src/main/java/com/hearthsim/card/minion/concrete/Alexstrasza.java b/src/main/java/com/hearthsim/card/minion/concrete/Alexstrasza.java
index 8dad7a5..67da299 100644
--- a/src/main/java/com/hearthsim/card/minion/concrete/Alexstrasza.java
+++ b/src/main/java/com/hearthsim/card/minion/concrete/Alexstrasza.java
@@ -23,7 +23,7 @@ public class Alexstrasza extends Dragon {
         summoned_ = SUMMONED;
         transformed_ = TRANSFORMED;
 	}
-	@Override
+	
 	public EnumSet<BattlecryTargetType> getBattlecryTargets() {
 		return EnumSet.of(BattlecryTargetType.FRIENDLY_HERO, BattlecryTargetType.ENEMY_HERO);
 	}
@@ -31,7 +31,7 @@ public class Alexstrasza extends Dragon {
 	/**
 	 * Battlecry: Set a hero's remaining health to 15
 	 */
-	@Override
+	
 	public HearthTreeNode useTargetableBattlecry_core(
 			PlayerSide side,
 			Minion targetMinion,
diff --git a/src/main/java/com/hearthsim/card/minion/concrete/AmaniBerserker.java b/src/main/java/com/hearthsim/card/minion/concrete/AmaniBerserker.java
index 87610c8..b7cea13 100644
--- a/src/main/java/com/hearthsim/card/minion/concrete/AmaniBerserker.java
+++ b/src/main/java/com/hearthsim/card/minion/concrete/AmaniBerserker.java
@@ -18,12 +18,12 @@ public class AmaniBerserker extends MinionWithEnrage {
 	}
 	
 
-	@Override
+	
 	public void enrage() {
 		attack_ = (byte)(attack_ + 3);
 	}
 
-	@Override
+	
 	public void pacify() {
 		attack_ = (byte)(attack_ - 3);
 	}
diff --git a/src/main/java/com/hearthsim/card/minion/concrete/AncientBrewmaster.java b/src/main/java/com/hearthsim/card/minion/concrete/AncientBrewmaster.java
index acf3809..27c6457 100644
--- a/src/main/java/com/hearthsim/card/minion/concrete/AncientBrewmaster.java
+++ b/src/main/java/com/hearthsim/card/minion/concrete/AncientBrewmaster.java
@@ -26,7 +26,7 @@ public class AncientBrewmaster extends Minion {
         transformed_ = TRANSFORMED;
 	}
 
-	@Override
+	
 	public EnumSet<BattlecryTargetType> getBattlecryTargets() {
 		return EnumSet.of(BattlecryTargetType.FRIENDLY_MINIONS);
 	}
@@ -34,7 +34,7 @@ public class AncientBrewmaster extends Minion {
 	/**
 	 * Battlecry: Change an enemy minion's attack to 1
 	 */
-	@Override
+	
 	public HearthTreeNode useTargetableBattlecry_core(
 			PlayerSide side,
 			Minion targetMinion,
diff --git a/src/main/java/com/hearthsim/card/minion/concrete/AncientOfLore.java b/src/main/java/com/hearthsim/card/minion/concrete/AncientOfLore.java
index 9f5cffc..136d29d 100644
--- a/src/main/java/com/hearthsim/card/minion/concrete/AncientOfLore.java
+++ b/src/main/java/com/hearthsim/card/minion/concrete/AncientOfLore.java
@@ -36,7 +36,7 @@ public class AncientOfLore extends Minion {
      *
      * @return The boardState is manipulated and returned
 	 */
-	@Override
+	
 	public HearthTreeNode use_core(
 			PlayerSide side,
 			Minion targetMinion,
diff --git a/src/main/java/com/hearthsim/card/minion/concrete/AncientOfWar.java b/src/main/java/com/hearthsim/card/minion/concrete/AncientOfWar.java
index c3aa833..acfb183 100644
--- a/src/main/java/com/hearthsim/card/minion/concrete/AncientOfWar.java
+++ b/src/main/java/com/hearthsim/card/minion/concrete/AncientOfWar.java
@@ -44,7 +44,7 @@ public class AncientOfWar extends Minion {
      *
      * @return The boardState is manipulated and returned
 	 */
-	@Override
+	
 	public HearthTreeNode use_core(
 			PlayerSide side,
 			Minion targetMinion,
diff --git a/src/main/java/com/hearthsim/card/minion/concrete/AngryChicken.java b/src/main/java/com/hearthsim/card/minion/concrete/AngryChicken.java
index c3d53ca..671c18e 100644
--- a/src/main/java/com/hearthsim/card/minion/concrete/AngryChicken.java
+++ b/src/main/java/com/hearthsim/card/minion/concrete/AngryChicken.java
@@ -18,12 +18,12 @@ public class AngryChicken extends MinionWithEnrage {
 	}
 	
 
-	@Override
+	
 	public void enrage() {
 		attack_ = (byte)(attack_ + 5);
 	}
 
-	@Override
+	
 	public void pacify() {
 		attack_ = (byte)(attack_ - 5);
 	}
diff --git a/src/main/java/com/hearthsim/card/minion/concrete/ArathiWeaponsmith.java b/src/main/java/com/hearthsim/card/minion/concrete/ArathiWeaponsmith.java
index 824e55b..f23755b 100644
--- a/src/main/java/com/hearthsim/card/minion/concrete/ArathiWeaponsmith.java
+++ b/src/main/java/com/hearthsim/card/minion/concrete/ArathiWeaponsmith.java
@@ -22,7 +22,7 @@ public class ArathiWeaponsmith extends Minion {
         summoned_ = SUMMONED;
         transformed_ = TRANSFORMED;
 	}
-	@Override
+	
 	public EnumSet<BattlecryTargetType> getBattlecryTargets() {
 		return EnumSet.of(BattlecryTargetType.NO_TARGET);
 	}
@@ -30,7 +30,7 @@ public class ArathiWeaponsmith extends Minion {
 	/**
 	 * Battlecry: Destroy your opponent's weapon
 	 */
-	@Override
+	
 	public HearthTreeNode useUntargetableBattlecry_core(
 			Minion minionPlacementTarget,
 			HearthTreeNode boardState,
diff --git a/src/main/java/com/hearthsim/card/minion/concrete/ArcaneGolem.java b/src/main/java/com/hearthsim/card/minion/concrete/ArcaneGolem.java
index 60649d1..b54303b 100644
--- a/src/main/java/com/hearthsim/card/minion/concrete/ArcaneGolem.java
+++ b/src/main/java/com/hearthsim/card/minion/concrete/ArcaneGolem.java
@@ -22,7 +22,7 @@ public class ArcaneGolem extends Minion {
         transformed_ = TRANSFORMED;
 	}
 
-	@Override
+	
 	public EnumSet<BattlecryTargetType> getBattlecryTargets() {
 		return EnumSet.of(BattlecryTargetType.NO_TARGET);
 	}
@@ -30,7 +30,7 @@ public class ArcaneGolem extends Minion {
 	/**
 	 * Battlecry: Destroy your opponent's weapon
 	 */
-	@Override
+	
 	public HearthTreeNode useUntargetableBattlecry_core(
 			Minion minionPlacementTarget,
 			HearthTreeNode boardState,
diff --git a/src/main/java/com/hearthsim/card/minion/concrete/ArchmageAntonidas.java b/src/main/java/com/hearthsim/card/minion/concrete/ArchmageAntonidas.java
index 49ecd40..8ca14e0 100644
--- a/src/main/java/com/hearthsim/card/minion/concrete/ArchmageAntonidas.java
+++ b/src/main/java/com/hearthsim/card/minion/concrete/ArchmageAntonidas.java
@@ -36,7 +36,7 @@ public class ArchmageAntonidas extends Minion {
      * @param deckPlayer1 The deck of player1
      * @return The boardState is manipulated and returned
 	 */
-	@Override
+	
 	public HearthTreeNode otherCardUsedEvent(
 			PlayerSide thisCardPlayerSide,
 			PlayerSide cardUserPlayerSide,
diff --git a/src/main/java/com/hearthsim/card/minion/concrete/ArgentProtector.java b/src/main/java/com/hearthsim/card/minion/concrete/ArgentProtector.java
index dfa999f..62aa77a 100644
--- a/src/main/java/com/hearthsim/card/minion/concrete/ArgentProtector.java
+++ b/src/main/java/com/hearthsim/card/minion/concrete/ArgentProtector.java
@@ -23,7 +23,7 @@ public class ArgentProtector extends Minion {
         transformed_ = TRANSFORMED;
 	}
 
-	@Override
+	
 	public EnumSet<BattlecryTargetType> getBattlecryTargets() {
 		return EnumSet.of(BattlecryTargetType.FRIENDLY_MINIONS);
 	}
@@ -31,7 +31,7 @@ public class ArgentProtector extends Minion {
 	/**
 	 * Battlecry: Give a friendly minion Divine Shield
 	 */
-	@Override
+	
 	public HearthTreeNode useTargetableBattlecry_core(
 			PlayerSide side,
 			Minion targetMinion,
diff --git a/src/main/java/com/hearthsim/card/minion/concrete/AzureDrake.java b/src/main/java/com/hearthsim/card/minion/concrete/AzureDrake.java
index 9e2816c..3a91ccd 100644
--- a/src/main/java/com/hearthsim/card/minion/concrete/AzureDrake.java
+++ b/src/main/java/com/hearthsim/card/minion/concrete/AzureDrake.java
@@ -23,7 +23,7 @@ public class AzureDrake extends Minion {
         transformed_ = TRANSFORMED;
 	}
 	
-	@Override
+	
 	public EnumSet<BattlecryTargetType> getBattlecryTargets() {
 		return EnumSet.of(BattlecryTargetType.NO_TARGET);
 	}
@@ -31,7 +31,7 @@ public class AzureDrake extends Minion {
 	/**
 	 * Battlecry: Draw one card
 	 */
-	@Override
+	
 	public HearthTreeNode useUntargetableBattlecry_core(
 			Minion minionPlacementTarget,
 			HearthTreeNode boardState,
diff --git a/src/main/java/com/hearthsim/card/minion/concrete/BigGameHunter.java b/src/main/java/com/hearthsim/card/minion/concrete/BigGameHunter.java
index 8234adc..1d1131a 100644
--- a/src/main/java/com/hearthsim/card/minion/concrete/BigGameHunter.java
+++ b/src/main/java/com/hearthsim/card/minion/concrete/BigGameHunter.java
@@ -23,7 +23,7 @@ public class BigGameHunter extends Minion {
         transformed_ = TRANSFORMED;
 	}
 	
-	@Override
+	
 	public EnumSet<BattlecryTargetType> getBattlecryTargets() {
 		return EnumSet.of(BattlecryTargetType.FRIENDLY_MINIONS, BattlecryTargetType.ENEMY_MINIONS);
 	}
@@ -31,7 +31,7 @@ public class BigGameHunter extends Minion {
 	/**
 	 * Battlecry: Destroy a minion with an Attack of 7 or more
 	 */
-	@Override
+	
 	public HearthTreeNode useTargetableBattlecry_core(
 			PlayerSide side,
 			Minion targetMinion,
diff --git a/src/main/java/com/hearthsim/card/minion/concrete/BloodKnight.java b/src/main/java/com/hearthsim/card/minion/concrete/BloodKnight.java
index 0af19d6..eebb4d2 100644
--- a/src/main/java/com/hearthsim/card/minion/concrete/BloodKnight.java
+++ b/src/main/java/com/hearthsim/card/minion/concrete/BloodKnight.java
@@ -23,7 +23,7 @@ public class BloodKnight extends Minion {
         transformed_ = TRANSFORMED;
 	}
 	
-	@Override
+	
 	public EnumSet<BattlecryTargetType> getBattlecryTargets() {
 		return EnumSet.of(BattlecryTargetType.NO_TARGET);
 	}
@@ -31,7 +31,7 @@ public class BloodKnight extends Minion {
 	/**
 	 * Battlecry: All minions lose Divine Shield.  Gain +3/+3 for each Shield lost
 	 */
-	@Override
+	
 	public HearthTreeNode useUntargetableBattlecry_core(
 			Minion minionPlacementTarget,
 			HearthTreeNode boardState,
diff --git a/src/main/java/com/hearthsim/card/minion/concrete/ColdlightOracle.java b/src/main/java/com/hearthsim/card/minion/concrete/ColdlightOracle.java
index 49f8c99..57f27ce 100644
--- a/src/main/java/com/hearthsim/card/minion/concrete/ColdlightOracle.java
+++ b/src/main/java/com/hearthsim/card/minion/concrete/ColdlightOracle.java
@@ -25,7 +25,7 @@ public class ColdlightOracle extends Murloc {
         transformed_ = TRANSFORMED;
 	}
 	
-	@Override
+	
 	public EnumSet<BattlecryTargetType> getBattlecryTargets() {
 		return EnumSet.of(BattlecryTargetType.NO_TARGET);
 	}
@@ -33,7 +33,7 @@ public class ColdlightOracle extends Murloc {
 	/**
 	 * Battlecry: All minions lose Divine Shield.  Gain +3/+3 for each Shield lost
 	 */
-	@Override
+	
 	public HearthTreeNode useUntargetableBattlecry_core(
 			Minion minionPlacementTarget,
 			HearthTreeNode boardState,
diff --git a/src/main/java/com/hearthsim/card/minion/concrete/ColdlightSeer.java b/src/main/java/com/hearthsim/card/minion/concrete/ColdlightSeer.java
index 6cb3f77..0045256 100644
--- a/src/main/java/com/hearthsim/card/minion/concrete/ColdlightSeer.java
+++ b/src/main/java/com/hearthsim/card/minion/concrete/ColdlightSeer.java
@@ -24,7 +24,7 @@ public class ColdlightSeer extends Murloc {
         transformed_ = TRANSFORMED;
 	}
 	
-	@Override
+	
 	public EnumSet<BattlecryTargetType> getBattlecryTargets() {
 		return EnumSet.of(BattlecryTargetType.NO_TARGET);
 	}
@@ -32,7 +32,7 @@ public class ColdlightSeer extends Murloc {
 	/**
 	 * Battlecry: Swap the Attack and Health of a minion
 	 */
-	@Override
+	
 	public HearthTreeNode useUntargetableBattlecry_core(
 			Minion minionPlacementTarget,
 			HearthTreeNode boardState,
diff --git a/src/main/java/com/hearthsim/card/minion/concrete/CrazedAlchemist.java b/src/main/java/com/hearthsim/card/minion/concrete/CrazedAlchemist.java
index de1c1a5..76a14a1 100644
--- a/src/main/java/com/hearthsim/card/minion/concrete/CrazedAlchemist.java
+++ b/src/main/java/com/hearthsim/card/minion/concrete/CrazedAlchemist.java
@@ -23,7 +23,7 @@ public class CrazedAlchemist extends Minion {
         transformed_ = TRANSFORMED;
 	}
 	
-	@Override
+	
 	public EnumSet<BattlecryTargetType> getBattlecryTargets() {
 		return EnumSet.of(BattlecryTargetType.FRIENDLY_MINIONS, BattlecryTargetType.ENEMY_MINIONS);
 	}
@@ -31,7 +31,7 @@ public class CrazedAlchemist extends Minion {
 	/**
 	 * Battlecry: Swap the Attack and Health of a minion
 	 */
-	@Override
+	
 	public HearthTreeNode useTargetableBattlecry_core(
 			PlayerSide side,
 			Minion targetMinion,
diff --git a/src/main/java/com/hearthsim/card/minion/concrete/CruelTaskmaster.java b/src/main/java/com/hearthsim/card/minion/concrete/CruelTaskmaster.java
index 86ee394..dc58d68 100644
--- a/src/main/java/com/hearthsim/card/minion/concrete/CruelTaskmaster.java
+++ b/src/main/java/com/hearthsim/card/minion/concrete/CruelTaskmaster.java
@@ -34,7 +34,7 @@ public class CruelTaskmaster extends Minion {
         transformed_ = TRANSFORMED;
 	}
 	
-	@Override
+	
 	public EnumSet<BattlecryTargetType> getBattlecryTargets() {
 		return EnumSet.of(BattlecryTargetType.FRIENDLY_MINIONS, BattlecryTargetType.ENEMY_MINIONS);
 	}
@@ -42,7 +42,7 @@ public class CruelTaskmaster extends Minion {
 	/**
 	 * Battlecry: Deal 1 damage to a minion and give it +2 Attack
 	 */
-	@Override
+	
 	public HearthTreeNode useTargetableBattlecry_core(
 			PlayerSide side,
 			Minion targetMinion,
diff --git a/src/main/java/com/hearthsim/card/minion/concrete/DarkIronDwarf.java b/src/main/java/com/hearthsim/card/minion/concrete/DarkIronDwarf.java
index 9296bd8..cc655b6 100644
--- a/src/main/java/com/hearthsim/card/minion/concrete/DarkIronDwarf.java
+++ b/src/main/java/com/hearthsim/card/minion/concrete/DarkIronDwarf.java
@@ -34,7 +34,7 @@ public class DarkIronDwarf extends Minion {
         transformed_ = TRANSFORMED;
 	}
 	
-	@Override
+	
 	public EnumSet<BattlecryTargetType> getBattlecryTargets() {
 		return EnumSet.of(BattlecryTargetType.FRIENDLY_MINIONS, BattlecryTargetType.ENEMY_MINIONS);
 	}
@@ -42,7 +42,7 @@ public class DarkIronDwarf extends Minion {
 	/**
 	 * Battlecry: Give a minion +2 attack this turn
 	 */
-	@Override
+	
 	public HearthTreeNode useTargetableBattlecry_core(
 			PlayerSide side,
 			Minion targetMinion,
diff --git a/src/main/java/com/hearthsim/card/minion/concrete/DarkscaleHealer.java b/src/main/java/com/hearthsim/card/minion/concrete/DarkscaleHealer.java
index 7a77eaa..68ee35a 100644
--- a/src/main/java/com/hearthsim/card/minion/concrete/DarkscaleHealer.java
+++ b/src/main/java/com/hearthsim/card/minion/concrete/DarkscaleHealer.java
@@ -23,7 +23,7 @@ public class DarkscaleHealer extends Minion {
         transformed_ = TRANSFORMED;
 	}
 	
-	@Override
+	
 	public EnumSet<BattlecryTargetType> getBattlecryTargets() {
 		return EnumSet.of(BattlecryTargetType.NO_TARGET);
 	}
@@ -31,7 +31,7 @@ public class DarkscaleHealer extends Minion {
 	/**
 	 * Battlecry: Heals friendly characters for 2
 	 */
-	@Override
+	
 	public HearthTreeNode useUntargetableBattlecry_core(
 			Minion minionPlacementTarget,
 			HearthTreeNode boardState,
diff --git a/src/main/java/com/hearthsim/card/minion/concrete/DefenderOfArgus.java b/src/main/java/com/hearthsim/card/minion/concrete/DefenderOfArgus.java
index 1df00ef..da3670e 100644
--- a/src/main/java/com/hearthsim/card/minion/concrete/DefenderOfArgus.java
+++ b/src/main/java/com/hearthsim/card/minion/concrete/DefenderOfArgus.java
@@ -23,7 +23,7 @@ public class DefenderOfArgus extends Minion {
         transformed_ = TRANSFORMED;
 	}
 	
-	@Override
+	
 	public EnumSet<BattlecryTargetType> getBattlecryTargets() {
 		return EnumSet.of(BattlecryTargetType.NO_TARGET);
 	}
@@ -31,7 +31,7 @@ public class DefenderOfArgus extends Minion {
 	/**
 	 * Battlecry: Give adjacent minions +1/+1 and Taunt
 	 */
-	@Override
+	
 	public HearthTreeNode useUntargetableBattlecry_core(
 			Minion minionPlacementTarget,
 			HearthTreeNode boardState,
diff --git a/src/main/java/com/hearthsim/card/minion/concrete/DragonlingMechanic.java b/src/main/java/com/hearthsim/card/minion/concrete/DragonlingMechanic.java
index 62df105..ab995c3 100644
--- a/src/main/java/com/hearthsim/card/minion/concrete/DragonlingMechanic.java
+++ b/src/main/java/com/hearthsim/card/minion/concrete/DragonlingMechanic.java
@@ -23,7 +23,7 @@ public class DragonlingMechanic extends Minion {
         transformed_ = TRANSFORMED;
 	}
 	
-	@Override
+	
 	public EnumSet<BattlecryTargetType> getBattlecryTargets() {
 		return EnumSet.of(BattlecryTargetType.NO_TARGET);
 	}
@@ -31,7 +31,7 @@ public class DragonlingMechanic extends Minion {
 	/**
 	 * Battlecry: Summons a Mechanical Dragonling
 	 */
-	@Override
+	
 	public HearthTreeNode useUntargetableBattlecry_core(
 			Minion minionPlacementTarget,
 			HearthTreeNode boardState,
diff --git a/src/main/java/com/hearthsim/card/minion/concrete/DreadInfernal.java b/src/main/java/com/hearthsim/card/minion/concrete/DreadInfernal.java
index 56c42d3..18d2ead 100644
--- a/src/main/java/com/hearthsim/card/minion/concrete/DreadInfernal.java
+++ b/src/main/java/com/hearthsim/card/minion/concrete/DreadInfernal.java
@@ -24,7 +24,7 @@ public class DreadInfernal extends Demon {
         transformed_ = TRANSFORMED;
 	}
 	
-	@Override
+	
 	public EnumSet<BattlecryTargetType> getBattlecryTargets() {
 		return EnumSet.of(BattlecryTargetType.NO_TARGET);
 	}
@@ -32,7 +32,7 @@ public class DreadInfernal extends Demon {
 	/**
 	 * Battlecry: Deals 1 damage to all characters
 	 */
-	@Override
+	
 	public HearthTreeNode useUntargetableBattlecry_core(
 			Minion minionPlacementTarget,
 			HearthTreeNode boardState,
diff --git a/src/main/java/com/hearthsim/card/minion/concrete/DustDevil.java b/src/main/java/com/hearthsim/card/minion/concrete/DustDevil.java
index 3977227..8f9a0a7 100644
--- a/src/main/java/com/hearthsim/card/minion/concrete/DustDevil.java
+++ b/src/main/java/com/hearthsim/card/minion/concrete/DustDevil.java
@@ -33,7 +33,7 @@ public class DustDevil extends Minion {
      *
      * @return The boardState is manipulated and returned
 	 */
-	@Override
+	
 	public HearthTreeNode use_core(
 			PlayerSide side,
 			Minion targetMinion,
diff --git a/src/main/java/com/hearthsim/card/minion/concrete/EarthElemental.java b/src/main/java/com/hearthsim/card/minion/concrete/EarthElemental.java
index c4e063f..4935c18 100644
--- a/src/main/java/com/hearthsim/card/minion/concrete/EarthElemental.java
+++ b/src/main/java/com/hearthsim/card/minion/concrete/EarthElemental.java
@@ -34,7 +34,7 @@ public class EarthElemental extends Minion {
      *
      * @return The boardState is manipulated and returned
 	 */
-	@Override
+	
 	public HearthTreeNode use_core(
 			PlayerSide side,
 			Minion targetMinion,
diff --git a/src/main/java/com/hearthsim/card/minion/concrete/EarthenRingFarseer.java b/src/main/java/com/hearthsim/card/minion/concrete/EarthenRingFarseer.java
index 3e836d9..1efd06b 100644
--- a/src/main/java/com/hearthsim/card/minion/concrete/EarthenRingFarseer.java
+++ b/src/main/java/com/hearthsim/card/minion/concrete/EarthenRingFarseer.java
@@ -23,7 +23,7 @@ public class EarthenRingFarseer extends Minion {
         transformed_ = TRANSFORMED;
 	}
 	
-	@Override
+	
 	public EnumSet<BattlecryTargetType> getBattlecryTargets() {
 		return EnumSet.of(BattlecryTargetType.FRIENDLY_HERO, BattlecryTargetType.ENEMY_HERO, BattlecryTargetType.FRIENDLY_MINIONS, BattlecryTargetType.ENEMY_MINIONS);
 	}
@@ -31,7 +31,7 @@ public class EarthenRingFarseer extends Minion {
 	/**
 	 * Battlecry: Restore 3 health
 	 */
-	@Override
+	
 	public HearthTreeNode useTargetableBattlecry_core(
 			PlayerSide side,
 			Minion targetMinion,
diff --git a/src/main/java/com/hearthsim/card/minion/concrete/ElvenArcher.java b/src/main/java/com/hearthsim/card/minion/concrete/ElvenArcher.java
index e0e6283..9fc9677 100644
--- a/src/main/java/com/hearthsim/card/minion/concrete/ElvenArcher.java
+++ b/src/main/java/com/hearthsim/card/minion/concrete/ElvenArcher.java
@@ -25,7 +25,7 @@ public class ElvenArcher extends Minion {
 	}
 	
 	
-	@Override
+	
 	public EnumSet<BattlecryTargetType> getBattlecryTargets() {
 		return EnumSet.of(BattlecryTargetType.FRIENDLY_HERO, BattlecryTargetType.ENEMY_HERO, BattlecryTargetType.FRIENDLY_MINIONS, BattlecryTargetType.ENEMY_MINIONS);
 	}
@@ -33,7 +33,7 @@ public class ElvenArcher extends Minion {
 	/**
 	 * Battlecry: Deal 1 damage to a chosen target
 	 */
-	@Override
+	
 	public HearthTreeNode useTargetableBattlecry_core(
 			PlayerSide side,
 			Minion targetMinion,
@@ -60,7 +60,7 @@ public class ElvenArcher extends Minion {
      *
      * @return The boardState is manipulated and returned
 	 */
-//	@Override
+//	
 //	public HearthTreeNode use_core(
 //			PlayerSide side,
 //			Minion targetMinion,
diff --git a/src/main/java/com/hearthsim/card/minion/concrete/Felguard.java b/src/main/java/com/hearthsim/card/minion/concrete/Felguard.java
index b2b86d3..34b341f 100644
--- a/src/main/java/com/hearthsim/card/minion/concrete/Felguard.java
+++ b/src/main/java/com/hearthsim/card/minion/concrete/Felguard.java
@@ -23,7 +23,7 @@ public class Felguard extends Demon {
         transformed_ = TRANSFORMED;
 	}
 
-	@Override
+	
 	public EnumSet<BattlecryTargetType> getBattlecryTargets() {
 		return EnumSet.of(BattlecryTargetType.NO_TARGET);
 	}
@@ -31,7 +31,7 @@ public class Felguard extends Demon {
 	/**
 	 * Taunt.  Battlecry: Destroy one of your Mana Crystals
 	 */
-	@Override
+	
 	public HearthTreeNode useUntargetableBattlecry_core(
 			Minion minionPlacementTarget,
 			HearthTreeNode boardState,
diff --git a/src/main/java/com/hearthsim/card/minion/concrete/FireElemental.java b/src/main/java/com/hearthsim/card/minion/concrete/FireElemental.java
index 35cd2eb..6ad447c 100644
--- a/src/main/java/com/hearthsim/card/minion/concrete/FireElemental.java
+++ b/src/main/java/com/hearthsim/card/minion/concrete/FireElemental.java
@@ -26,7 +26,7 @@ public class FireElemental extends Minion {
         transformed_ = TRANSFORMED;
 	}
 	
-	@Override
+	
 	public EnumSet<BattlecryTargetType> getBattlecryTargets() {
 		return EnumSet.of(BattlecryTargetType.FRIENDLY_HERO, BattlecryTargetType.ENEMY_HERO, BattlecryTargetType.FRIENDLY_MINIONS, BattlecryTargetType.ENEMY_MINIONS);
 	}
@@ -34,7 +34,7 @@ public class FireElemental extends Minion {
 	/**
 	 * Battlecry: Deal 3 damage to a chosen target
 	 */
-	@Override
+	
 	public HearthTreeNode useTargetableBattlecry_core(
 			PlayerSide side,
 			Minion targetMinion,
diff --git a/src/main/java/com/hearthsim/card/minion/concrete/FlameImp.java b/src/main/java/com/hearthsim/card/minion/concrete/FlameImp.java
index 62ee3cd..5f69970 100644
--- a/src/main/java/com/hearthsim/card/minion/concrete/FlameImp.java
+++ b/src/main/java/com/hearthsim/card/minion/concrete/FlameImp.java
@@ -24,7 +24,7 @@ public class FlameImp extends Demon {
         transformed_ = TRANSFORMED;
 	}
 	
-	@Override
+	
 	public EnumSet<BattlecryTargetType> getBattlecryTargets() {
 		return EnumSet.of(BattlecryTargetType.NO_TARGET);
 	}
@@ -32,7 +32,7 @@ public class FlameImp extends Demon {
 	/**
 	 * Battlecry: Deal 3 damage to your hero
 	 */
-	@Override
+	
 	public HearthTreeNode useUntargetableBattlecry_core(
 			Minion minionPlacementTarget,
 			HearthTreeNode boardState,
diff --git a/src/main/java/com/hearthsim/card/minion/concrete/FrostwolfWarlord.java b/src/main/java/com/hearthsim/card/minion/concrete/FrostwolfWarlord.java
index 128a488..948b5bd 100644
--- a/src/main/java/com/hearthsim/card/minion/concrete/FrostwolfWarlord.java
+++ b/src/main/java/com/hearthsim/card/minion/concrete/FrostwolfWarlord.java
@@ -24,7 +24,7 @@ public class FrostwolfWarlord extends Minion {
         transformed_ = TRANSFORMED;
 	}
 	
-	@Override
+	
 	public EnumSet<BattlecryTargetType> getBattlecryTargets() {
 		return EnumSet.of(BattlecryTargetType.NO_TARGET);
 	}
@@ -32,7 +32,7 @@ public class FrostwolfWarlord extends Minion {
 	/**
 	 * Battlecry: gain +1/+1 for each friendly minion on the battlefield
 	 */
-	@Override
+	
 	public HearthTreeNode useUntargetableBattlecry_core(
 			Minion minionPlacementTarget,
 			HearthTreeNode boardState,
diff --git a/src/main/java/com/hearthsim/card/minion/concrete/GnomishInventor.java b/src/main/java/com/hearthsim/card/minion/concrete/GnomishInventor.java
index 48707f9..b1edda3 100644
--- a/src/main/java/com/hearthsim/card/minion/concrete/GnomishInventor.java
+++ b/src/main/java/com/hearthsim/card/minion/concrete/GnomishInventor.java
@@ -24,7 +24,7 @@ public class GnomishInventor extends Minion {
         transformed_ = TRANSFORMED;
 	}
 	
-	@Override
+	
 	public EnumSet<BattlecryTargetType> getBattlecryTargets() {
 		return EnumSet.of(BattlecryTargetType.NO_TARGET);
 	}
@@ -32,7 +32,7 @@ public class GnomishInventor extends Minion {
 	/**
 	 * Battlecry: Draw one card
 	 */
-	@Override
+	
 	public HearthTreeNode useUntargetableBattlecry_core(
 			Minion minionPlacementTarget,
 			HearthTreeNode boardState,
diff --git a/src/main/java/com/hearthsim/card/minion/concrete/GrimscaleOracle.java b/src/main/java/com/hearthsim/card/minion/concrete/GrimscaleOracle.java
index 1972b52..c876ae7 100644
--- a/src/main/java/com/hearthsim/card/minion/concrete/GrimscaleOracle.java
+++ b/src/main/java/com/hearthsim/card/minion/concrete/GrimscaleOracle.java
@@ -80,7 +80,7 @@ public class GrimscaleOracle extends Murloc {
      * @param boardState
      * @throws HSInvalidPlayerIndexException
 	 */
-	@Override
+	
 	public void silenced(PlayerSide thisPlayerSide, BoardModel boardState) throws HSInvalidPlayerIndexException {
 		if (!silenced_) {
 			for (Minion minion : PlayerSide.CURRENT_PLAYER.getPlayer(boardState).getMinions()) {
@@ -120,7 +120,7 @@ public class GrimscaleOracle extends Murloc {
      * @param boardState The BoardState before this card has performed its action.  It will be manipulated and returned.
      * @return The boardState is manipulated and returned
 	 */
-	@Override
+	
 	public HearthTreeNode minionSummonedEvent(
 			PlayerSide thisMinionPlayerSide,
 			PlayerSide summonedMinionPlayerSide,
@@ -142,7 +142,7 @@ public class GrimscaleOracle extends Murloc {
      * @param boardState The BoardState before this card has performed its action.  It will be manipulated and returned.
      * @return The boardState is manipulated and returned
 	 */
-	@Override
+	
 	public HearthTreeNode minionTransformedEvent(
 			PlayerSide thisMinionPlayerSide,
 			PlayerSide transformedMinionPlayerSide,
diff --git a/src/main/java/com/hearthsim/card/minion/concrete/GrommashHellscream.java b/src/main/java/com/hearthsim/card/minion/concrete/GrommashHellscream.java
index f4dba2b..bdaad04 100644
--- a/src/main/java/com/hearthsim/card/minion/concrete/GrommashHellscream.java
+++ b/src/main/java/com/hearthsim/card/minion/concrete/GrommashHellscream.java
@@ -17,12 +17,12 @@ public class GrommashHellscream extends MinionWithEnrage {
         transformed_ = TRANSFORMED;
 	}
 
-	@Override
+	
 	public void enrage() {
 		attack_ = (byte)(attack_ + 6);
 	}
 
-	@Override
+	
 	public void pacify() {
 		attack_ = (byte)(attack_ - 6);
 	}
diff --git a/src/main/java/com/hearthsim/card/minion/concrete/GuardianOfKings.java b/src/main/java/com/hearthsim/card/minion/concrete/GuardianOfKings.java
index 830e8de..75a5341 100644
--- a/src/main/java/com/hearthsim/card/minion/concrete/GuardianOfKings.java
+++ b/src/main/java/com/hearthsim/card/minion/concrete/GuardianOfKings.java
@@ -24,7 +24,7 @@ public class GuardianOfKings extends Minion {
         transformed_ = TRANSFORMED;
 	}
 	
-	@Override
+	
 	public EnumSet<BattlecryTargetType> getBattlecryTargets() {
 		return EnumSet.of(BattlecryTargetType.NO_TARGET);
 	}
@@ -32,7 +32,7 @@ public class GuardianOfKings extends Minion {
 	/**
 	 * Battlecry: Restore 6 Health to your Hero
 	 */
-	@Override
+	
 	public HearthTreeNode useUntargetableBattlecry_core(
 			Minion minionPlacementTarget,
 			HearthTreeNode boardState,
diff --git a/src/main/java/com/hearthsim/card/minion/concrete/GurubashiBerserker.java b/src/main/java/com/hearthsim/card/minion/concrete/GurubashiBerserker.java
index 09d5328..96ee3e4 100644
--- a/src/main/java/com/hearthsim/card/minion/concrete/GurubashiBerserker.java
+++ b/src/main/java/com/hearthsim/card/minion/concrete/GurubashiBerserker.java
@@ -45,7 +45,7 @@ public class GurubashiBerserker extends Minion {
      * @param boardState
      * @param isSpellDamage True if this is a spell damage   @throws HSInvalidPlayerIndexException
      * */
-	@Override
+	
 	public HearthTreeNode takeDamage(
 			byte damage,
 			PlayerSide attackPlayerSide,
@@ -79,7 +79,7 @@ public class GurubashiBerserker extends Minion {
      * @param boardState
      * @throws HSInvalidPlayerIndexException
 	 */
-	@Override
+	
 	public void silenced(PlayerSide thisPlayerSide, BoardModel boardState) throws HSInvalidPlayerIndexException {
 		super.silenced(thisPlayerSide, boardState);
 		this.attack_ = this.baseAttack_;
diff --git a/src/main/java/com/hearthsim/card/minion/concrete/HealingTotem.java b/src/main/java/com/hearthsim/card/minion/concrete/HealingTotem.java
index a778f85..e8bccd3 100644
--- a/src/main/java/com/hearthsim/card/minion/concrete/HealingTotem.java
+++ b/src/main/java/com/hearthsim/card/minion/concrete/HealingTotem.java
@@ -29,7 +29,7 @@ public class HealingTotem extends Totem {
 	 * At the end of your turn, restore 1 Health to all friendly minions
 	 * 
 	 */
-	@Override
+	
 	public HearthTreeNode endTurn(PlayerSide thisMinionPlayerIndex, HearthTreeNode boardModel, Deck deckPlayer0, Deck deckPlayer1) throws HSException {
 		HearthTreeNode tmpState = super.endTurn(thisMinionPlayerIndex, boardModel, deckPlayer0, deckPlayer1);
 		if (isWaitingPlayer(thisMinionPlayerIndex))
diff --git a/src/main/java/com/hearthsim/card/minion/concrete/Houndmaster.java b/src/main/java/com/hearthsim/card/minion/concrete/Houndmaster.java
index b365c3c..db68d0f 100644
--- a/src/main/java/com/hearthsim/card/minion/concrete/Houndmaster.java
+++ b/src/main/java/com/hearthsim/card/minion/concrete/Houndmaster.java
@@ -24,7 +24,7 @@ public class Houndmaster extends Minion {
         transformed_ = TRANSFORMED;
 	}
 	
-	@Override
+	
 	public EnumSet<BattlecryTargetType> getBattlecryTargets() {
 		return EnumSet.of(BattlecryTargetType.FRIENDLY_BEASTS);
 	}
@@ -32,7 +32,7 @@ public class Houndmaster extends Minion {
 	/**
 	 * Battlecry: Give a friendly beast +2/+2 and Taunt
 	 */
-	@Override
+	
 	public HearthTreeNode useTargetableBattlecry_core(
 			PlayerSide side,
 			Minion targetMinion,
diff --git a/src/main/java/com/hearthsim/card/minion/concrete/InjuredBlademaster.java b/src/main/java/com/hearthsim/card/minion/concrete/InjuredBlademaster.java
index 8e2eeab..fcd99e9 100644
--- a/src/main/java/com/hearthsim/card/minion/concrete/InjuredBlademaster.java
+++ b/src/main/java/com/hearthsim/card/minion/concrete/InjuredBlademaster.java
@@ -23,7 +23,7 @@ public class InjuredBlademaster extends Minion {
         transformed_ = TRANSFORMED;
 	}
 	
-	@Override
+	
 	public EnumSet<BattlecryTargetType> getBattlecryTargets() {
 		return EnumSet.of(BattlecryTargetType.NO_TARGET);
 	}
@@ -31,7 +31,7 @@ public class InjuredBlademaster extends Minion {
 	/**
 	 * Battlecry: Deal 4 damage to himself
 	 */
-	@Override
+	
 	public HearthTreeNode useUntargetableBattlecry_core(
 			Minion minionPlacementTarget,
 			HearthTreeNode boardState,
diff --git a/src/main/java/com/hearthsim/card/minion/concrete/IronbeakOwl.java b/src/main/java/com/hearthsim/card/minion/concrete/IronbeakOwl.java
index 437de92..3efe64d 100644
--- a/src/main/java/com/hearthsim/card/minion/concrete/IronbeakOwl.java
+++ b/src/main/java/com/hearthsim/card/minion/concrete/IronbeakOwl.java
@@ -23,7 +23,7 @@ public class IronbeakOwl extends Minion {
         transformed_ = TRANSFORMED;
 	}
 	
-	@Override
+	
 	public EnumSet<BattlecryTargetType> getBattlecryTargets() {
 		return EnumSet.of(BattlecryTargetType.FRIENDLY_MINIONS, BattlecryTargetType.ENEMY_MINIONS);
 	}
@@ -31,7 +31,7 @@ public class IronbeakOwl extends Minion {
 	/**
 	 * Battlecry: Silence a minion
 	 */
-	@Override
+	
 	public HearthTreeNode useTargetableBattlecry_core(
 			PlayerSide side,
 			Minion targetMinion,
diff --git a/src/main/java/com/hearthsim/card/minion/concrete/IronforgeRifleman.java b/src/main/java/com/hearthsim/card/minion/concrete/IronforgeRifleman.java
index f1f0690..d32af7b 100644
--- a/src/main/java/com/hearthsim/card/minion/concrete/IronforgeRifleman.java
+++ b/src/main/java/com/hearthsim/card/minion/concrete/IronforgeRifleman.java
@@ -26,7 +26,7 @@ public class IronforgeRifleman extends Minion {
         transformed_ = TRANSFORMED;
 	}
 	
-	@Override
+	
 	public EnumSet<BattlecryTargetType> getBattlecryTargets() {
 		return EnumSet.of(BattlecryTargetType.FRIENDLY_HERO, BattlecryTargetType.ENEMY_HERO, BattlecryTargetType.FRIENDLY_MINIONS, BattlecryTargetType.ENEMY_MINIONS);
 	}
@@ -34,7 +34,7 @@ public class IronforgeRifleman extends Minion {
 	/**
 	 * Battlecry: Deal 1 damage to a chosen target
 	 */
-	@Override
+	
 	public HearthTreeNode useTargetableBattlecry_core(
 			PlayerSide side,
 			Minion targetMinion,
diff --git a/src/main/java/com/hearthsim/card/minion/concrete/Leokk.java b/src/main/java/com/hearthsim/card/minion/concrete/Leokk.java
index e6e241a..d55c212 100644
--- a/src/main/java/com/hearthsim/card/minion/concrete/Leokk.java
+++ b/src/main/java/com/hearthsim/card/minion/concrete/Leokk.java
@@ -39,7 +39,7 @@ public class Leokk extends Beast {
      *
      * @return The boardState is manipulated and returned
 	 */
-	@Override
+	
 	protected HearthTreeNode summonMinion_core(
             PlayerSide targetSide,
 			Minion targetMinion,
@@ -72,7 +72,7 @@ public class Leokk extends Beast {
      * @param deckPlayer1
      * @throws HSInvalidPlayerIndexException
 	 */
-	@Override
+	
 	public void silenced(PlayerSide thisPlayerSide, BoardModel boardState) throws HSInvalidPlayerIndexException {
 		for (Minion minion : boardState.getMinions(thisPlayerSide)) {
 			if (minion != this) {
diff --git a/src/main/java/com/hearthsim/card/minion/concrete/MurlocTidehunter.java b/src/main/java/com/hearthsim/card/minion/concrete/MurlocTidehunter.java
index b148699..f59b464 100644
--- a/src/main/java/com/hearthsim/card/minion/concrete/MurlocTidehunter.java
+++ b/src/main/java/com/hearthsim/card/minion/concrete/MurlocTidehunter.java
@@ -25,7 +25,7 @@ public class MurlocTidehunter extends Murloc {
         transformed_ = TRANSFORMED;
 	}
 	
-	@Override
+	
 	public EnumSet<BattlecryTargetType> getBattlecryTargets() {
 		return EnumSet.of(BattlecryTargetType.NO_TARGET);
 	}
@@ -33,7 +33,7 @@ public class MurlocTidehunter extends Murloc {
 	/**
 	 * Battlecry: Summon a Murloc Scout
 	 */
-	@Override
+	
 	public HearthTreeNode useUntargetableBattlecry_core(
 			Minion minionPlacementTarget,
 			HearthTreeNode boardState,
diff --git a/src/main/java/com/hearthsim/card/minion/concrete/Nightblade.java b/src/main/java/com/hearthsim/card/minion/concrete/Nightblade.java
index 0bf61a9..f552312 100644
--- a/src/main/java/com/hearthsim/card/minion/concrete/Nightblade.java
+++ b/src/main/java/com/hearthsim/card/minion/concrete/Nightblade.java
@@ -37,7 +37,7 @@ public class Nightblade extends Minion {
      * @param deckPlayer0 The deck of player0
      * @return The boardState is manipulated and returned
 	 */
-	@Override
+	
 	public HearthTreeNode useOn(
 			PlayerSide side,
 			Minion targetMinion,
diff --git a/src/main/java/com/hearthsim/card/minion/concrete/NoviceEngineer.java b/src/main/java/com/hearthsim/card/minion/concrete/NoviceEngineer.java
index 9b71dc9..8f41cb6 100644
--- a/src/main/java/com/hearthsim/card/minion/concrete/NoviceEngineer.java
+++ b/src/main/java/com/hearthsim/card/minion/concrete/NoviceEngineer.java
@@ -24,7 +24,7 @@ public class NoviceEngineer extends Minion {
         transformed_ = TRANSFORMED;
 	}
 	
-	@Override
+	
 	public EnumSet<BattlecryTargetType> getBattlecryTargets() {
 		return EnumSet.of(BattlecryTargetType.NO_TARGET);
 	}
@@ -32,7 +32,7 @@ public class NoviceEngineer extends Minion {
 	/**
 	 * Battlecry: Draw one card
 	 */
-	@Override
+	
 	public HearthTreeNode useUntargetableBattlecry_core(
 			Minion minionPlacementTarget,
 			HearthTreeNode boardState,
diff --git a/src/main/java/com/hearthsim/card/minion/concrete/PriestessOfElune.java b/src/main/java/com/hearthsim/card/minion/concrete/PriestessOfElune.java
index 9dd3c46..473503e 100644
--- a/src/main/java/com/hearthsim/card/minion/concrete/PriestessOfElune.java
+++ b/src/main/java/com/hearthsim/card/minion/concrete/PriestessOfElune.java
@@ -24,7 +24,7 @@ public class PriestessOfElune extends Minion {
         transformed_ = TRANSFORMED;
 	}
 	
-	@Override
+	
 	public EnumSet<BattlecryTargetType> getBattlecryTargets() {
 		return EnumSet.of(BattlecryTargetType.NO_TARGET);
 	}
@@ -32,7 +32,7 @@ public class PriestessOfElune extends Minion {
 	/**
 	 * Battlecry: Restore 4 Health to your Hero
 	 */
-	@Override
+	
 	public HearthTreeNode useUntargetableBattlecry_core(
 			Minion minionPlacementTarget,
 			HearthTreeNode boardState,
diff --git a/src/main/java/com/hearthsim/card/minion/concrete/RagingWorgen.java b/src/main/java/com/hearthsim/card/minion/concrete/RagingWorgen.java
index 4d29997..9d0aa8e 100644
--- a/src/main/java/com/hearthsim/card/minion/concrete/RagingWorgen.java
+++ b/src/main/java/com/hearthsim/card/minion/concrete/RagingWorgen.java
@@ -18,13 +18,13 @@ public class RagingWorgen extends MinionWithEnrage {
 	}
 	
 
-	@Override
+	
 	public void enrage() {
 		attack_ = (byte)(attack_ + 1);
 		windFury_ = true;
 	}
 
-	@Override
+	
 	public void pacify() {
 		attack_ = (byte)(attack_ - 1);
 		windFury_ = false;
diff --git a/src/main/java/com/hearthsim/card/minion/concrete/RaidLeader.java b/src/main/java/com/hearthsim/card/minion/concrete/RaidLeader.java
index 2ce68df..0178550 100644
--- a/src/main/java/com/hearthsim/card/minion/concrete/RaidLeader.java
+++ b/src/main/java/com/hearthsim/card/minion/concrete/RaidLeader.java
@@ -70,7 +70,7 @@ public class RaidLeader extends Minion {
      * @param deckPlayer1
      * @throws HSInvalidPlayerIndexException
 	 */
-	@Override
+	
 	public void silenced(PlayerSide thisPlayerSide, BoardModel boardState) throws HSInvalidPlayerIndexException {
 		for (Minion minion : boardState.getMinions(thisPlayerSide)) {
 			if (minion != this) {
diff --git a/src/main/java/com/hearthsim/card/minion/concrete/RazorfenHunter.java b/src/main/java/com/hearthsim/card/minion/concrete/RazorfenHunter.java
index 18bac36..7ff414c 100644
--- a/src/main/java/com/hearthsim/card/minion/concrete/RazorfenHunter.java
+++ b/src/main/java/com/hearthsim/card/minion/concrete/RazorfenHunter.java
@@ -24,7 +24,7 @@ public class RazorfenHunter extends Minion {
         transformed_ = TRANSFORMED;
 	}
 	
-	@Override
+	
 	public EnumSet<BattlecryTargetType> getBattlecryTargets() {
 		return EnumSet.of(BattlecryTargetType.NO_TARGET);
 	}
@@ -32,7 +32,7 @@ public class RazorfenHunter extends Minion {
 	/**
 	 * Battlecry: Summon a 1/1 Boar
 	 */
-	@Override
+	
 	public HearthTreeNode useUntargetableBattlecry_core(
 			Minion minionPlacementTarget,
 			HearthTreeNode boardState,
diff --git a/src/main/java/com/hearthsim/card/minion/concrete/ShatteredSunCleric.java b/src/main/java/com/hearthsim/card/minion/concrete/ShatteredSunCleric.java
index 4ad6930..c3cd46d 100644
--- a/src/main/java/com/hearthsim/card/minion/concrete/ShatteredSunCleric.java
+++ b/src/main/java/com/hearthsim/card/minion/concrete/ShatteredSunCleric.java
@@ -24,7 +24,7 @@ public class ShatteredSunCleric extends Minion {
         transformed_ = TRANSFORMED;
 	}
 	
-	@Override
+	
 	public EnumSet<BattlecryTargetType> getBattlecryTargets() {
 		return EnumSet.of(BattlecryTargetType.FRIENDLY_MINIONS);
 	}
@@ -32,7 +32,7 @@ public class ShatteredSunCleric extends Minion {
 	/**
 	 * Battlecry: Give a friendly minion +1/+1
 	 */
-	@Override
+	
 	public HearthTreeNode useTargetableBattlecry_core(
 			PlayerSide side,
 			Minion targetMinion,
diff --git a/src/main/java/com/hearthsim/card/minion/concrete/SilverHandKnight.java b/src/main/java/com/hearthsim/card/minion/concrete/SilverHandKnight.java
index d4649cb..096912a 100644
--- a/src/main/java/com/hearthsim/card/minion/concrete/SilverHandKnight.java
+++ b/src/main/java/com/hearthsim/card/minion/concrete/SilverHandKnight.java
@@ -24,7 +24,7 @@ public class SilverHandKnight extends Minion {
         transformed_ = TRANSFORMED;
 	}
 	
-	@Override
+	
 	public EnumSet<BattlecryTargetType> getBattlecryTargets() {
 		return EnumSet.of(BattlecryTargetType.NO_TARGET);
 	}
@@ -32,7 +32,7 @@ public class SilverHandKnight extends Minion {
 	/**
 	 * Battlecry: Summon a Squire
 	 */
-	@Override
+	
 	public HearthTreeNode useUntargetableBattlecry_core(
 			Minion minionPlacementTarget,
 			HearthTreeNode boardState,
diff --git a/src/main/java/com/hearthsim/card/minion/concrete/Spellbreaker.java b/src/main/java/com/hearthsim/card/minion/concrete/Spellbreaker.java
index 684e6a0..e04c39f 100644
--- a/src/main/java/com/hearthsim/card/minion/concrete/Spellbreaker.java
+++ b/src/main/java/com/hearthsim/card/minion/concrete/Spellbreaker.java
@@ -23,7 +23,7 @@ public class Spellbreaker extends Minion {
         transformed_ = TRANSFORMED;
 	}
 	
-	@Override
+	
 	public EnumSet<BattlecryTargetType> getBattlecryTargets() {
 		return EnumSet.of(BattlecryTargetType.FRIENDLY_MINIONS, BattlecryTargetType.ENEMY_MINIONS);
 	}
@@ -31,7 +31,7 @@ public class Spellbreaker extends Minion {
 	/**
 	 * Battlecry: Silence a minion
 	 */
-	@Override
+	
 	public HearthTreeNode useTargetableBattlecry_core(
 			PlayerSide side,
 			Minion targetMinion,
diff --git a/src/main/java/com/hearthsim/card/minion/concrete/StampedingKodo.java b/src/main/java/com/hearthsim/card/minion/concrete/StampedingKodo.java
index 38cac78..b656c63 100644
--- a/src/main/java/com/hearthsim/card/minion/concrete/StampedingKodo.java
+++ b/src/main/java/com/hearthsim/card/minion/concrete/StampedingKodo.java
@@ -4,6 +4,7 @@ import com.hearthsim.card.Deck;
 import com.hearthsim.card.minion.Beast;
 import com.hearthsim.card.minion.Hero;
 import com.hearthsim.card.minion.Minion;
+import com.hearthsim.entity.BaseEntity;
 import com.hearthsim.exception.HSException;
 import com.hearthsim.model.BoardModel;
 import com.hearthsim.model.PlayerModel;
@@ -32,7 +33,7 @@ public class StampedingKodo extends Beast {
         transformed_ = TRANSFORMED;
 	}
 
-	@Override
+	
 	public EnumSet<BattlecryTargetType> getBattlecryTargets() {
 		return EnumSet.of(BattlecryTargetType.NO_TARGET);
 	}
@@ -40,9 +41,9 @@ public class StampedingKodo extends Beast {
 	/**
 	 * Battlecry: Destroy
 	 */
-	@Override
+	
 	public HearthTreeNode useUntargetableBattlecry_core(
-			Minion minionPlacementTarget,
+			BaseEntity minionPlacementTarget,
 			HearthTreeNode boardState,
 			Deck deckPlayer0,
 			Deck deckPlayer1,
diff --git a/src/main/java/com/hearthsim/card/minion/concrete/StormpikeCommando.java b/src/main/java/com/hearthsim/card/minion/concrete/StormpikeCommando.java
index 390cc29..cd7fe59 100644
--- a/src/main/java/com/hearthsim/card/minion/concrete/StormpikeCommando.java
+++ b/src/main/java/com/hearthsim/card/minion/concrete/StormpikeCommando.java
@@ -26,7 +26,7 @@ public class StormpikeCommando extends Minion {
         transformed_ = TRANSFORMED;
 	}
 	
-	@Override
+	
 	public EnumSet<BattlecryTargetType> getBattlecryTargets() {
 		return EnumSet.of(BattlecryTargetType.FRIENDLY_HERO, BattlecryTargetType.ENEMY_HERO, BattlecryTargetType.FRIENDLY_MINIONS, BattlecryTargetType.ENEMY_MINIONS);
 	}
@@ -34,7 +34,7 @@ public class StormpikeCommando extends Minion {
 	/**
 	 * Battlecry: Deal 2 damage to a chosen target
 	 */
-	@Override
+	
 	public HearthTreeNode useTargetableBattlecry_core(
 			PlayerSide side,
 			Minion targetMinion,
diff --git a/src/main/java/com/hearthsim/card/minion/concrete/StormwindChampion.java b/src/main/java/com/hearthsim/card/minion/concrete/StormwindChampion.java
index 9e3fe8e..644905b 100644
--- a/src/main/java/com/hearthsim/card/minion/concrete/StormwindChampion.java
+++ b/src/main/java/com/hearthsim/card/minion/concrete/StormwindChampion.java
@@ -72,7 +72,7 @@ public class StormwindChampion extends Minion {
      * @param deckPlayer1
      * @throws HSInvalidPlayerIndexException
 	 */
-	@Override
+	
 	public void silenced(PlayerSide thisPlayerSide, BoardModel boardState) throws HSInvalidPlayerIndexException {
 		if (!silenced_) {
 			for (Minion minion : boardState.getMinions(thisPlayerSide)) {
diff --git a/src/main/java/com/hearthsim/card/minion/concrete/Succubus.java b/src/main/java/com/hearthsim/card/minion/concrete/Succubus.java
index c011382..38f32f8 100644
--- a/src/main/java/com/hearthsim/card/minion/concrete/Succubus.java
+++ b/src/main/java/com/hearthsim/card/minion/concrete/Succubus.java
@@ -36,7 +36,7 @@ public class Succubus extends Demon {
      *
      * @return The boardState is manipulated and returned
 	 */
-	@Override
+	
 	public HearthTreeNode use_core(
 			PlayerSide side,
 			Minion targetMinion,
diff --git a/src/main/java/com/hearthsim/card/minion/concrete/SunfuryProtector.java b/src/main/java/com/hearthsim/card/minion/concrete/SunfuryProtector.java
index 24dbadf..835bf56 100644
--- a/src/main/java/com/hearthsim/card/minion/concrete/SunfuryProtector.java
+++ b/src/main/java/com/hearthsim/card/minion/concrete/SunfuryProtector.java
@@ -23,7 +23,7 @@ public class SunfuryProtector extends Minion {
         transformed_ = TRANSFORMED;
 	}
 	
-	@Override
+	
 	public EnumSet<BattlecryTargetType> getBattlecryTargets() {
 		return EnumSet.of(BattlecryTargetType.NO_TARGET);
 	}
@@ -31,7 +31,7 @@ public class SunfuryProtector extends Minion {
 	/**
 	 * Battlecry: Give adjacent minions Taunt
 	 */
-	@Override
+	
 	public HearthTreeNode useUntargetableBattlecry_core(
 			Minion minionPlacementTarget,
 			HearthTreeNode boardState,
diff --git a/src/main/java/com/hearthsim/card/minion/concrete/TaurenWarrior.java b/src/main/java/com/hearthsim/card/minion/concrete/TaurenWarrior.java
index a7ca15b..9e1d70f 100644
--- a/src/main/java/com/hearthsim/card/minion/concrete/TaurenWarrior.java
+++ b/src/main/java/com/hearthsim/card/minion/concrete/TaurenWarrior.java
@@ -18,12 +18,12 @@ public class TaurenWarrior extends MinionWithEnrage {
 	}
 	
 
-	@Override
+	
 	public void enrage() {
 		attack_ = (byte)(attack_ + 3);
 	}
 
-	@Override
+	
 	public void pacify() {
 		attack_ = (byte)(attack_ - 3);
 	}
diff --git a/src/main/java/com/hearthsim/card/minion/concrete/TempleEnforcer.java b/src/main/java/com/hearthsim/card/minion/concrete/TempleEnforcer.java
index cabc669..c69163d 100644
--- a/src/main/java/com/hearthsim/card/minion/concrete/TempleEnforcer.java
+++ b/src/main/java/com/hearthsim/card/minion/concrete/TempleEnforcer.java
@@ -23,7 +23,7 @@ public class TempleEnforcer extends Minion {
         transformed_ = TRANSFORMED;
 	}
 	
-	@Override
+	
 	public EnumSet<BattlecryTargetType> getBattlecryTargets() {
 		return EnumSet.of(BattlecryTargetType.FRIENDLY_MINIONS);
 	}
@@ -31,7 +31,7 @@ public class TempleEnforcer extends Minion {
 	/**
 	 * Battlecry: Give a friendly minion +3 Health
 	 */
-	@Override
+	
 	public HearthTreeNode useTargetableBattlecry_core(
 			PlayerSide side,
 			Minion targetMinion,
diff --git a/src/main/java/com/hearthsim/card/minion/concrete/TheBlackKnight.java b/src/main/java/com/hearthsim/card/minion/concrete/TheBlackKnight.java
index 220c84b..bc4e2c1 100644
--- a/src/main/java/com/hearthsim/card/minion/concrete/TheBlackKnight.java
+++ b/src/main/java/com/hearthsim/card/minion/concrete/TheBlackKnight.java
@@ -23,7 +23,7 @@ public class TheBlackKnight extends Minion {
         transformed_ = TRANSFORMED;
 	}
 	
-	@Override
+	
 	public EnumSet<BattlecryTargetType> getBattlecryTargets() {
 		return EnumSet.of(BattlecryTargetType.ENEMY_MINIONS);
 	}
@@ -31,7 +31,7 @@ public class TheBlackKnight extends Minion {
 	/**
 	 * Battlecry: Destroy a minion with an Attack of 7 or more
 	 */
-	@Override
+	
 	public HearthTreeNode useTargetableBattlecry_core(
 			PlayerSide side,
 			Minion targetMinion,
diff --git a/src/main/java/com/hearthsim/card/minion/concrete/TimberWolf.java b/src/main/java/com/hearthsim/card/minion/concrete/TimberWolf.java
index 274fa33..3ba9bcb 100644
--- a/src/main/java/com/hearthsim/card/minion/concrete/TimberWolf.java
+++ b/src/main/java/com/hearthsim/card/minion/concrete/TimberWolf.java
@@ -69,7 +69,7 @@ public class TimberWolf extends Beast {
      * @param boardState
      * @throws HSInvalidPlayerIndexException
 	 */
-	@Override
+	
 	public void silenced(PlayerSide thisPlayerSide, BoardModel boardState) throws HSInvalidPlayerIndexException {
 		if (!silenced_) {
 			for (Minion minion : boardState.getMinions(thisPlayerSide)) {
diff --git a/src/main/java/com/hearthsim/card/minion/concrete/TwilightDrake.java b/src/main/java/com/hearthsim/card/minion/concrete/TwilightDrake.java
index 1aac37d..d4fda3b 100644
--- a/src/main/java/com/hearthsim/card/minion/concrete/TwilightDrake.java
+++ b/src/main/java/com/hearthsim/card/minion/concrete/TwilightDrake.java
@@ -24,7 +24,7 @@ public class TwilightDrake extends Dragon {
         transformed_ = TRANSFORMED;
 	}
 	
-	@Override
+	
 	public EnumSet<BattlecryTargetType> getBattlecryTargets() {
 		return EnumSet.of(BattlecryTargetType.NO_TARGET);
 	}
@@ -32,7 +32,7 @@ public class TwilightDrake extends Dragon {
 	/**
 	 * Battlecry: Gain +1 Health for each card in your hand.
 	 */
-	@Override
+	
 	public HearthTreeNode useUntargetableBattlecry_core(
 			Minion minionPlacementTarget,
 			HearthTreeNode boardState,
diff --git a/src/main/java/com/hearthsim/card/minion/concrete/VioletTeacher.java b/src/main/java/com/hearthsim/card/minion/concrete/VioletTeacher.java
index b9a6fdb..5680531 100644
--- a/src/main/java/com/hearthsim/card/minion/concrete/VioletTeacher.java
+++ b/src/main/java/com/hearthsim/card/minion/concrete/VioletTeacher.java
@@ -37,7 +37,7 @@ public class VioletTeacher extends Minion {
      * @return The boardState is manipulated and returned
 	 * @throws HSException 
 	 */
-	@Override
+	
 	public HearthTreeNode otherCardUsedEvent(PlayerSide thisCardPlayerSide, PlayerSide cardUserPlayerSide, Card usedCard, HearthTreeNode boardState, Deck deckPlayer0, Deck deckPlayer1) throws HSException {
 		HearthTreeNode toRet = super.otherCardUsedEvent(thisCardPlayerSide, cardUserPlayerSide, usedCard, boardState, deckPlayer0, deckPlayer1);
 		if (thisCardPlayerSide != PlayerSide.CURRENT_PLAYER)
diff --git a/src/main/java/com/hearthsim/card/minion/concrete/VoodooDoctor.java b/src/main/java/com/hearthsim/card/minion/concrete/VoodooDoctor.java
index bbe5a1c..bc6fb92 100644
--- a/src/main/java/com/hearthsim/card/minion/concrete/VoodooDoctor.java
+++ b/src/main/java/com/hearthsim/card/minion/concrete/VoodooDoctor.java
@@ -25,7 +25,7 @@ public class VoodooDoctor extends Minion {
         transformed_ = TRANSFORMED;
 	}
 	
-	@Override
+	
 	public EnumSet<BattlecryTargetType> getBattlecryTargets() {
 		return EnumSet.of(BattlecryTargetType.FRIENDLY_HERO, BattlecryTargetType.ENEMY_HERO, BattlecryTargetType.FRIENDLY_MINIONS, BattlecryTargetType.ENEMY_MINIONS);
 	}
@@ -33,7 +33,7 @@ public class VoodooDoctor extends Minion {
 	/**
 	 * Battlecry: Restore 2 health
 	 */
-	@Override
+	
 	public HearthTreeNode useTargetableBattlecry_core(
 			PlayerSide side,
 			Minion targetMinion,
diff --git a/src/main/java/com/hearthsim/card/minion/concrete/Windspeaker.java b/src/main/java/com/hearthsim/card/minion/concrete/Windspeaker.java
index 69fea65..40ac2be 100644
--- a/src/main/java/com/hearthsim/card/minion/concrete/Windspeaker.java
+++ b/src/main/java/com/hearthsim/card/minion/concrete/Windspeaker.java
@@ -24,7 +24,7 @@ public class Windspeaker extends Minion {
         transformed_ = TRANSFORMED;
 	}
 	
-	@Override
+	
 	public EnumSet<BattlecryTargetType> getBattlecryTargets() {
 		return EnumSet.of(BattlecryTargetType.FRIENDLY_MINIONS);
 	}
@@ -32,7 +32,7 @@ public class Windspeaker extends Minion {
 	/**
 	 * Battlecry: Give a friendly minion +3 Health
 	 */
-	@Override
+	
 	public HearthTreeNode useTargetableBattlecry_core(
 			PlayerSide side,
 			Minion targetMinion,
diff --git a/src/main/java/com/hearthsim/card/minion/concrete/YoungPriestess.java b/src/main/java/com/hearthsim/card/minion/concrete/YoungPriestess.java
index e206779..400544e 100644
--- a/src/main/java/com/hearthsim/card/minion/concrete/YoungPriestess.java
+++ b/src/main/java/com/hearthsim/card/minion/concrete/YoungPriestess.java
@@ -25,7 +25,7 @@ public class YoungPriestess extends Minion {
 	/**
 	 * At the end of your turn, give another random friendly minion +1 Health
 	 */
-	@Override
+	
 	public HearthTreeNode endTurn(PlayerSide thisMinionPlayerIndex, HearthTreeNode boardModel, Deck deckPlayer0, Deck deckPlayer1) throws HSException {
 		HearthTreeNode toRet = super.endTurn(thisMinionPlayerIndex, boardModel, deckPlayer0, deckPlayer1);
 		if (toRet != null && thisMinionPlayerIndex == PlayerSide.CURRENT_PLAYER) {
diff --git a/src/main/java/com/hearthsim/card/minion/heroes/Druid.java b/src/main/java/com/hearthsim/card/minion/heroes/Druid.java
index 1949c79..b57d392 100644
--- a/src/main/java/com/hearthsim/card/minion/heroes/Druid.java
+++ b/src/main/java/com/hearthsim/card/minion/heroes/Druid.java
@@ -34,7 +34,7 @@ public class Druid extends Hero {
 		super(name, attack, extraAttackUntilTurnEnd, health, armor, weaponCharge, windFury, hasAttacked, hasWindFuryAttacked, frozen, hasBeenUsed);
 	}
 	
-	@Override
+	
 	public DeepCopyable deepCopy() {
 		return new Druid(
 				this.name_, 
@@ -66,7 +66,7 @@ public class Druid extends Hero {
      *
      * @return
 	 */
-	@Override
+	
 	public HearthTreeNode useHeroAbility_core(
 			PlayerSide targetPlayerSide,
 			Minion targetMinion,
diff --git a/src/main/java/com/hearthsim/card/minion/heroes/Hunter.java b/src/main/java/com/hearthsim/card/minion/heroes/Hunter.java
index bb962b4..e0307db 100644
--- a/src/main/java/com/hearthsim/card/minion/heroes/Hunter.java
+++ b/src/main/java/com/hearthsim/card/minion/heroes/Hunter.java
@@ -34,7 +34,7 @@ public class Hunter extends Hero {
 		super(name, attack, extraAttackUntilTurnEnd, health, armor, weaponCharge, windFury, hasAttacked, hasWindFuryAttacked, frozen, hasBeenUsed);
 	}
 	
-	@Override
+	
 	public DeepCopyable deepCopy() {
 		return new Hunter(
 				this.name_, 
@@ -66,7 +66,7 @@ public class Hunter extends Hero {
      *
      * @return
 	 */
-	@Override
+	
 	public HearthTreeNode useHeroAbility_core(
 			PlayerSide targetPlayerSide,
 			Minion targetMinion,
diff --git a/src/main/java/com/hearthsim/card/minion/heroes/Mage.java b/src/main/java/com/hearthsim/card/minion/heroes/Mage.java
index c4ef316..0625c77 100644
--- a/src/main/java/com/hearthsim/card/minion/heroes/Mage.java
+++ b/src/main/java/com/hearthsim/card/minion/heroes/Mage.java
@@ -34,7 +34,7 @@ public class Mage extends Hero {
 		super(name, attack, extraAttackUntilTurnEnd, health, armor, weaponCharge, windFury, hasAttacked, hasWindFuryAttacked, frozen, hasBeenUsed);
 	}
 	
-	@Override
+	
 	public DeepCopyable deepCopy() {
 		return new Mage(
 				this.name_, 
@@ -66,7 +66,7 @@ public class Mage extends Hero {
      *
      * @return
 	 */
-	@Override
+	
 	public HearthTreeNode useHeroAbility_core(
 			PlayerSide targetPlayerSide,
 			Minion targetMinion,
diff --git a/src/main/java/com/hearthsim/card/minion/heroes/NewHero.java b/src/main/java/com/hearthsim/card/minion/heroes/NewHero.java
new file mode 100644
index 0000000..6863d18
--- /dev/null
+++ b/src/main/java/com/hearthsim/card/minion/heroes/NewHero.java
@@ -0,0 +1,270 @@
+package com.hearthsim.card.minion.heroes;
+
+import org.json.JSONObject;
+
+import com.hearthsim.card.Deck;
+import com.hearthsim.card.minion.Hero;
+import com.hearthsim.card.minion.Minion;
+import com.hearthsim.entity.BaseEntity;
+import com.hearthsim.exception.HSException;
+import com.hearthsim.model.BoardModel;
+import com.hearthsim.model.PlayerSide;
+import com.hearthsim.util.DeepCopyable;
+import com.hearthsim.util.factory.BoardStateFactoryBase;
+import com.hearthsim.util.tree.HearthTreeNode;
+
+public class NewHero extends BaseEntity
+{
+	protected static final byte HERO_ABILITY_COST = 2;  //Assumed to be 2 for all heroes
+	
+	protected byte weaponCharge_;
+	protected byte armor_;
+	
+	public NewHero() {
+		this("NoHero", (byte)30);
+	}
+
+	public NewHero(String name, byte health) {
+		this(name, (byte)0, (byte)0, health, (byte)0, (byte)0, false, false, false, false, false);
+	}
+	
+	public NewHero(
+			String name,
+			byte attack,
+			byte extraAttackUntilTurnEnd,
+			byte health,
+			byte armor,
+			byte weaponCharge,
+			boolean windFury,
+			boolean hasAttacked,
+			boolean hasWindFuryAttacked,
+			boolean frozen,
+			boolean hasBeenUsed) {
+	
+		super(name, (byte)0, attack, health, (byte)0, extraAttackUntilTurnEnd, (byte)0, (byte)30, (byte)30, (byte)0, (byte)0, false, false, windFury, false, hasAttacked, hasWindFuryAttacked, frozen, false, false, true, false, false, false, false, null, null, false, hasBeenUsed);
+		armor_ = armor;
+		weaponCharge_ = weaponCharge;
+	}
+
+
+	public byte getWeaponCharge() {
+		return weaponCharge_;
+	}
+	
+	public void setWeaponCharge(byte weaponCharge) {
+		weaponCharge_ = weaponCharge;
+	}
+	
+	public byte getArmor() {
+		return armor_;
+	}
+	
+	public void setArmor(byte armor) {
+		armor_ = armor;
+	}
+	
+	
+	public DeepCopyable deepCopy() {
+		return new Hero(
+				this.name_, 
+				this.attack_,
+				this.extraAttackUntilTurnEnd_,
+				this.health_,
+				this.armor_,
+				this.weaponCharge_,
+				this.windFury_,
+				this.hasAttacked_,
+				this.hasWindFuryAttacked_,
+				this.frozen_,
+				this.hasBeenUsed
+				);
+	}
+	
+	
+	/**
+	 * 
+	 * Attack with the hero
+	 * 
+	 * A hero can only attack if it has a temporary buff, such as weapons
+	 * 
+	 *
+     *
+     * @param targetMinionPlayerSide
+     * @param targetMinion The target minion
+     * @param boardState The BoardState before this card has performed its action.  It will be manipulated and returned.
+     * @param deckPlayer0 The deck of player0
+     * @return The boardState is manipulated and returned
+	 */
+	
+	public HearthTreeNode attack(
+			PlayerSide targetMinionPlayerSide,
+			Minion targetMinion,
+			HearthTreeNode boardState,
+			Deck deckPlayer0,
+			Deck deckPlayer1)
+		throws HSException
+	{
+		
+		if (attack_ + extraAttackUntilTurnEnd_ == 0) {
+			return null;
+		}
+
+		if (this.weaponCharge_ == 0 && this.extraAttackUntilTurnEnd_ == 0) {
+			return null;
+		}
+		
+		//this is somewhat redundant, but it must be done here...
+		if (frozen_) {
+			this.hasAttacked_ = true;
+			this.frozen_ = false;
+			return boardState;
+		}
+		
+		
+		HearthTreeNode toRet = super.attack(targetMinionPlayerSide, targetMinion, boardState, deckPlayer0, deckPlayer1);
+
+        if (toRet != null && this.weaponCharge_ > 0) {
+            this.weaponCharge_ -= 1;
+            if (this.weaponCharge_ == 0) {
+                this.attack_ = 0;
+            }
+        }
+        return toRet;
+	}
+	
+	
+    public boolean canBeUsedOn(PlayerSide playerSide, Minion minion, BoardModel boardModel) {
+		if (hasBeenUsed)
+			return false;
+		if (!minion.isHeroTargetable())
+			return false;
+		return true;
+    }
+
+	public final HearthTreeNode useHeroAbility(
+			PlayerSide targetPlayerSide,
+			Minion targetMinion,
+			HearthTreeNode boardState,
+			Deck deckPlayer0,
+			Deck deckPlayer1)
+		throws HSException
+	{
+		return this.useHeroAbility(targetPlayerSide, targetMinion, boardState, deckPlayer0, deckPlayer1, false);
+	}
+	/**
+	 * Use the hero ability on a given target
+	 * 
+	 *
+     *
+     * @param targetPlayerSide
+     * @param targetMinion The target minion
+     * @param boardState
+     * @param deckPlayer0 The deck of player0
+     * @return
+	 */
+	public final HearthTreeNode useHeroAbility(
+			PlayerSide targetPlayerSide,
+			Minion targetMinion,
+			HearthTreeNode boardState,
+			Deck deckPlayer0,
+			Deck deckPlayer1,
+			boolean singleRealizationOnly)
+		throws HSException
+	{
+		if (boardState.data_.getCurrentPlayer().getMana() < HERO_ABILITY_COST)
+			return null;
+		
+		HearthTreeNode toRet = this.useHeroAbility_core(targetPlayerSide, targetMinion, boardState, deckPlayer0, deckPlayer1, singleRealizationOnly);
+		if (toRet != null) {
+			toRet = BoardStateFactoryBase.handleDeadMinions(toRet, deckPlayer0, deckPlayer1);
+		}
+		return toRet;
+	}
+	
+	public HearthTreeNode useHeroAbility_core(
+			PlayerSide targetPlayerSide,
+			Minion targetMinion,
+			HearthTreeNode boardState,
+			Deck deckPlayer0,
+			Deck deckPlayer1,
+			boolean singleRealizationOnly)
+		throws HSException
+	{
+		return null;
+	}
+	
+	/**
+	 * Called when this minion takes damage
+	 * 
+	 * Overridden from Minion.  Need to handle armor.
+	 *  @param damage The amount of damage to take
+	 * @param attackPlayerSide The player index of the attacker.  This is needed to do things like +spell damage.
+     * @param thisPlayerSide
+     * @param boardState
+     * @param deckPlayer0 The deck of player0
+     * @param isSpellDamage
+     * @throws HSInvalidPlayerIndexException
+	 */
+	
+	public HearthTreeNode takeDamage(
+			byte damage,
+			PlayerSide attackPlayerSide,
+			PlayerSide thisPlayerSide,
+			HearthTreeNode boardState,
+			Deck deckPlayer0, 
+			Deck deckPlayer1,
+			boolean isSpellDamage,
+			boolean handleMinionDeath)
+		throws HSException
+	{
+		HearthTreeNode toRet = boardState;
+		byte damageRemaining = (byte)(damage - armor_);
+		if (damageRemaining > 0) {
+			armor_ = 0;
+			toRet = super.takeDamage(damageRemaining, attackPlayerSide, thisPlayerSide, toRet, deckPlayer0, deckPlayer1, isSpellDamage, handleMinionDeath);
+		} else {
+			armor_ = (byte)(armor_ - damage);
+		}
+		return toRet;
+	}
+	
+	
+	/**
+	 * End the turn and resets the card state
+	 * 
+	 * This function is called at the end of the turn.  Any derived class must override it and remove any 
+	 * temporary buffs that it has.
+	 */
+	
+	public HearthTreeNode endTurn(PlayerSide thisMinionPlayerIndex, HearthTreeNode boardModel, Deck deckPlayer0, Deck deckPlayer1) throws HSException {
+		this.extraAttackUntilTurnEnd_ = 0;
+		return boardModel;
+	}
+
+	public JSONObject toJSON() {
+		JSONObject json = super.toJSON();
+		json.put("armor", this.armor_);
+		json.put("weaponCharge", this.weaponCharge_);
+		return json;
+	}
+	
+	
+	public boolean equals(Object other) {
+		if (!super.equals(other)) {
+			return false;
+		}
+		Hero hero = (Hero)other;
+		if (weaponCharge_ != hero.getWeaponCharge()) return false;
+		if (armor_ != hero.getArmor()) return false;
+		
+		return true;
+	}
+	
+    
+    public int hashCode() {
+    	int hash = super.hashCode();
+    	hash = 31 * hash + (int) weaponCharge_;
+    	hash = 31 * hash + (int) armor_;
+    	return hash;
+    }
+}
diff --git a/src/main/java/com/hearthsim/card/minion/heroes/Paladin.java b/src/main/java/com/hearthsim/card/minion/heroes/Paladin.java
index 3b4e0eb..2d10aed 100644
--- a/src/main/java/com/hearthsim/card/minion/heroes/Paladin.java
+++ b/src/main/java/com/hearthsim/card/minion/heroes/Paladin.java
@@ -4,6 +4,7 @@ import com.hearthsim.card.Deck;
 import com.hearthsim.card.minion.Hero;
 import com.hearthsim.card.minion.Minion;
 import com.hearthsim.card.minion.concrete.SilverHandRecruit;
+import com.hearthsim.entity.BaseEntity;
 import com.hearthsim.exception.HSException;
 import com.hearthsim.model.PlayerSide;
 import com.hearthsim.util.DeepCopyable;
@@ -35,7 +36,7 @@ public class Paladin extends Hero {
 		super(name, attack, extraAttackUntilTurnEnd, health, armor, weaponCharge, windFury, hasAttacked, hasWindFuryAttacked, frozen, hasBeenUsed);
 	}
 	
-	@Override
+	
 	public DeepCopyable deepCopy() {
 		return new Paladin(
 				this.name_, 
@@ -63,7 +64,7 @@ public class Paladin extends Hero {
      * @param boardState
      * @return
 	 */
-	@Override
+	
 	public HearthTreeNode useHeroAbility_core(
 			PlayerSide targetPlayerSide,
 			Minion targetMinion,
@@ -82,7 +83,7 @@ public class Paladin extends Hero {
 			this.hasBeenUsed = true;
 			toRet.data_.getCurrentPlayer().subtractMana(HERO_ABILITY_COST);
 			Minion theRecruit = new SilverHandRecruit();
-			Minion targetLocation = toRet.data_.getCharacter(PlayerSide.CURRENT_PLAYER, PlayerSide.CURRENT_PLAYER.getPlayer(toRet).getNumMinions());
+			BaseEntity targetLocation = toRet.data_.getCharacter(PlayerSide.CURRENT_PLAYER, PlayerSide.CURRENT_PLAYER.getPlayer(toRet).getNumMinions());
 			toRet = theRecruit.summonMinion(targetPlayerSide, targetLocation, toRet, deckPlayer0, deckPlayer1, false);
 		} else {
 			return null;
diff --git a/src/main/java/com/hearthsim/card/minion/heroes/Priest.java b/src/main/java/com/hearthsim/card/minion/heroes/Priest.java
index 468aa79..23124cc 100644
--- a/src/main/java/com/hearthsim/card/minion/heroes/Priest.java
+++ b/src/main/java/com/hearthsim/card/minion/heroes/Priest.java
@@ -35,7 +35,7 @@ public class Priest extends Hero {
 		super(name, attack, extraAttackUntilTurnEnd, health, armor, weaponCharge, windFury, hasAttacked, hasWindFuryAttacked, frozen, hasBeenUsed);
 	}
 	
-	@Override
+	
 	public DeepCopyable deepCopy() {
 		return new Priest(
 				this.name_, 
@@ -52,7 +52,7 @@ public class Priest extends Hero {
 				);
 	}
 
-	@Override
+	
     public boolean canBeUsedOn(PlayerSide playerSide, Minion minion, BoardModel boardModel) {
 		return super.canBeUsedOn(playerSide, minion, boardModel) && minion.getTotalHealth() < minion.getTotalMaxHealth();
     }
@@ -68,7 +68,7 @@ public class Priest extends Hero {
      * @param boardState
      * @return
 	 */
-	@Override
+	
 	public HearthTreeNode useHeroAbility_core(
 			PlayerSide targetPlayerSide,
 			Minion targetMinion,
diff --git a/src/main/java/com/hearthsim/card/minion/heroes/Rogue.java b/src/main/java/com/hearthsim/card/minion/heroes/Rogue.java
index f0fa720..acfadbc 100644
--- a/src/main/java/com/hearthsim/card/minion/heroes/Rogue.java
+++ b/src/main/java/com/hearthsim/card/minion/heroes/Rogue.java
@@ -3,6 +3,7 @@ package com.hearthsim.card.minion.heroes;
 import com.hearthsim.card.Deck;
 import com.hearthsim.card.minion.Hero;
 import com.hearthsim.card.minion.Minion;
+import com.hearthsim.entity.BaseEntity;
 import com.hearthsim.exception.HSException;
 import com.hearthsim.model.PlayerSide;
 import com.hearthsim.util.DeepCopyable;
@@ -34,7 +35,7 @@ public class Rogue extends Hero {
 		super(name, attack, extraAttackUntilTurnEnd, health, armor, weaponCharge, windFury, hasAttacked, hasWindFuryAttacked, frozen, hasBeenUsed);
 	}
 	
-	@Override
+	
 	public DeepCopyable deepCopy() {
 		return new Rogue(
 				this.name_, 
@@ -62,10 +63,10 @@ public class Rogue extends Hero {
      * @param boardState
      * @return
 	 */
-	@Override
+	
 	public HearthTreeNode useHeroAbility_core(
 			PlayerSide targetPlayerSide,
-			Minion targetMinion,
+			BaseEntity targetMinion,
 			HearthTreeNode boardState,
 			Deck deckPlayer0,
 			Deck deckPlayer1,
diff --git a/src/main/java/com/hearthsim/card/minion/heroes/Shaman.java b/src/main/java/com/hearthsim/card/minion/heroes/Shaman.java
index dcba538..9ab66db 100644
--- a/src/main/java/com/hearthsim/card/minion/heroes/Shaman.java
+++ b/src/main/java/com/hearthsim/card/minion/heroes/Shaman.java
@@ -7,6 +7,7 @@ import com.hearthsim.card.minion.concrete.HealingTotem;
 import com.hearthsim.card.minion.concrete.SearingTotem;
 import com.hearthsim.card.minion.concrete.StoneclawTotem;
 import com.hearthsim.card.minion.concrete.WrathOfAirTotem;
+import com.hearthsim.entity.BaseEntity;
 import com.hearthsim.exception.HSException;
 import com.hearthsim.model.BoardModel;
 import com.hearthsim.model.PlayerSide;
@@ -41,7 +42,7 @@ public class Shaman extends Hero {
 		super(name, attack, extraAttackUntilTurnEnd, health, armor, weaponCharge, windFury, hasAttacked, hasWindFuryAttacked, frozen, hasBeenUsed);
 	}
 	
-	@Override
+	
 	public DeepCopyable deepCopy() {
 		return new Shaman(
 				this.name_, 
@@ -73,7 +74,7 @@ public class Shaman extends Hero {
      *
      * @return
 	 */
-	@Override
+	
 	public HearthTreeNode useHeroAbility_core(
 			PlayerSide targetPlayerSide,
 			Minion targetMinion,
@@ -117,7 +118,7 @@ public class Shaman extends Hero {
 				return null;
 			this.hasBeenUsed = true;
 			toRet.data_.getCurrentPlayer().subtractMana(HERO_ABILITY_COST);
-			Minion summonTarget = toRet.data_.getCharacter(targetPlayerSide, numMinions);
+			BaseEntity summonTarget = toRet.data_.getCharacter(targetPlayerSide, numMinions);
 			toRet = minionToSummon.summonMinion(targetPlayerSide, summonTarget, toRet, deckPlayer0, deckPlayer1, false);
 			return toRet;
 		}
@@ -139,7 +140,7 @@ public class Shaman extends Hero {
 
 					HearthTreeNode newState = toRet.addChild(new HearthTreeNode((BoardModel) toRet.data_.deepCopy()));
 
-					Minion summonTarget = newState.data_.getCharacter(targetPlayerSide, numMinions);
+					BaseEntity summonTarget = newState.data_.getCharacter(targetPlayerSide, numMinions);
 					newState.data_.getCurrentPlayer().subtractMana(HERO_ABILITY_COST);
 					newState.data_.getCurrentPlayerHero().hasBeenUsed(true);
 
diff --git a/src/main/java/com/hearthsim/card/minion/heroes/Warlock.java b/src/main/java/com/hearthsim/card/minion/heroes/Warlock.java
index 218308a..03a04b5 100644
--- a/src/main/java/com/hearthsim/card/minion/heroes/Warlock.java
+++ b/src/main/java/com/hearthsim/card/minion/heroes/Warlock.java
@@ -35,7 +35,7 @@ public class Warlock extends Hero {
 		super(name, attack, extraAttackUntilTurnEnd, health, armor, weaponCharge, windFury, hasAttacked, hasWindFuryAttacked, frozen, hasBeenUsed);
 	}
 	
-	@Override
+	
 	public DeepCopyable deepCopy() {
 		return new Warlock(
 				this.name_, 
@@ -67,7 +67,7 @@ public class Warlock extends Hero {
      *
      * @return
 	 */
-	@Override
+	
 	public HearthTreeNode useHeroAbility_core(
 			PlayerSide targetPlayerSide,
 			Minion targetMinion,
diff --git a/src/main/java/com/hearthsim/card/minion/heroes/Warrior.java b/src/main/java/com/hearthsim/card/minion/heroes/Warrior.java
index 6d3b522..de839f6 100644
--- a/src/main/java/com/hearthsim/card/minion/heroes/Warrior.java
+++ b/src/main/java/com/hearthsim/card/minion/heroes/Warrior.java
@@ -3,6 +3,7 @@ package com.hearthsim.card.minion.heroes;
 import com.hearthsim.card.Deck;
 import com.hearthsim.card.minion.Hero;
 import com.hearthsim.card.minion.Minion;
+import com.hearthsim.entity.BaseEntity;
 import com.hearthsim.exception.HSException;
 import com.hearthsim.model.PlayerSide;
 import com.hearthsim.util.DeepCopyable;
@@ -34,7 +35,7 @@ public class Warrior extends Hero {
 		super(name, attack, extraAttackUntilTurnEnd, health, armor, weaponCharge, windFury, hasAttacked, hasWindFuryAttacked, frozen, hasBeenUsed);
 	}
 	
-	@Override
+	
 	public DeepCopyable deepCopy() {
 		return new Warrior(
 				this.name_, 
@@ -62,10 +63,10 @@ public class Warrior extends Hero {
      * @param boardState
      * @return
 	 */
-	@Override
+	
 	public HearthTreeNode useHeroAbility_core(
 			PlayerSide targetPlayerSide,
-			Minion targetMinion,
+			BaseEntity targetMinion,
 			HearthTreeNode boardState,
 			Deck deckPlayer0,
 			Deck deckPlayer1,
diff --git a/src/main/java/com/hearthsim/card/spellcard/concrete/AncestralHealing.java b/src/main/java/com/hearthsim/card/spellcard/concrete/AncestralHealing.java
index 676911d..f9a185f 100644
--- a/src/main/java/com/hearthsim/card/spellcard/concrete/AncestralHealing.java
+++ b/src/main/java/com/hearthsim/card/spellcard/concrete/AncestralHealing.java
@@ -27,7 +27,7 @@ public class AncestralHealing extends SpellCard {
 		this(false);
 	}
 
-	@Override
+	
 	public Object deepCopy() {
 		return new AncestralHealing(this.hasBeenUsed);
 	}
@@ -45,7 +45,6 @@ public class AncestralHealing extends SpellCard {
      *
      * @return The boardState is manipulated and returned
 	 */
-	@Override
 	protected HearthTreeNode use_core(
 			PlayerSide side,
 			Minion targetMinion,
diff --git a/src/main/java/com/hearthsim/card/spellcard/concrete/AncestralSpirit.java b/src/main/java/com/hearthsim/card/spellcard/concrete/AncestralSpirit.java
index 2e6dc26..8e11a56 100644
--- a/src/main/java/com/hearthsim/card/spellcard/concrete/AncestralSpirit.java
+++ b/src/main/java/com/hearthsim/card/spellcard/concrete/AncestralSpirit.java
@@ -27,7 +27,7 @@ public class AncestralSpirit extends SpellCard {
 		this(false);
 	}
 
-	@Override
+	
 	public Object deepCopy() {
 		return new AncestralSpirit(this.hasBeenUsed);
 	}
@@ -45,7 +45,7 @@ public class AncestralSpirit extends SpellCard {
      *
      * @return The boardState is manipulated and returned
 	 */
-	@Override
+
 	protected HearthTreeNode use_core(
 			PlayerSide side,
 			Minion targetMinion,
diff --git a/src/main/java/com/hearthsim/card/spellcard/concrete/AnimalCompanion.java b/src/main/java/com/hearthsim/card/spellcard/concrete/AnimalCompanion.java
index fdff9da..9ef39ad 100644
--- a/src/main/java/com/hearthsim/card/spellcard/concrete/AnimalCompanion.java
+++ b/src/main/java/com/hearthsim/card/spellcard/concrete/AnimalCompanion.java
@@ -6,6 +6,7 @@ import com.hearthsim.card.minion.concrete.Huffer;
 import com.hearthsim.card.minion.concrete.Leokk;
 import com.hearthsim.card.minion.concrete.Misha;
 import com.hearthsim.card.spellcard.SpellCard;
+import com.hearthsim.entity.BaseEntity;
 import com.hearthsim.exception.HSException;
 import com.hearthsim.model.BoardModel;
 import com.hearthsim.model.PlayerSide;
@@ -34,7 +35,7 @@ public class AnimalCompanion extends SpellCard {
 		this(false);
 	}
 
-	@Override
+	
 	public Object deepCopy() {
 		return new AnimalCompanion(this.hasBeenUsed);
 	}
@@ -53,7 +54,7 @@ public class AnimalCompanion extends SpellCard {
      *
      * @return The boardState is manipulated and returned
 	 */
-	@Override
+	
 	protected HearthTreeNode use_core(
 			PlayerSide side,
 			Minion targetMinion,
@@ -85,7 +86,7 @@ public class AnimalCompanion extends SpellCard {
 				} else {
 					minion = new Misha();
 				}
-            	Minion placementTarget = toRet.data_.getCharacter(side, toRet.data_.getMinions(side).size()); //this minion can't be a hero
+            	BaseEntity placementTarget = toRet.data_.getCharacter(side, toRet.data_.getMinions(side).size()); //this minion can't be a hero
             	toRet = minion.summonMinion(side, placementTarget, toRet, deckPlayer0, deckPlayer1, false);					
 			}
 		} else {
@@ -95,7 +96,7 @@ public class AnimalCompanion extends SpellCard {
 				for (Minion minion : new Minion[]{ new Huffer(), new Leokk(), new Misha()}) {
 					HearthTreeNode newState = toRet.addChild(new HearthTreeNode((BoardModel) toRet.data_.deepCopy()));
 					newState = super.use_core(side, side.getPlayer(newState).getHero(), newState, deckPlayer0, deckPlayer1, singleRealizationOnly);
-	            	Minion placementTarget = newState.data_.getCharacter(side, newState.data_.getMinions(side).size()); //this minion can't be a hero
+					BaseEntity placementTarget = newState.data_.getCharacter(side, newState.data_.getMinions(side).size()); //this minion can't be a hero
 	            	newState = minion.summonMinion(side, placementTarget, newState, deckPlayer0, deckPlayer1, false);					
 					newState.data_.getCurrentPlayer().subtractMana(this.mana_);
 					side.getPlayer(newState).getHand().remove(thisCardIndex);
diff --git a/src/main/java/com/hearthsim/card/spellcard/concrete/ArcaneExplosion.java b/src/main/java/com/hearthsim/card/spellcard/concrete/ArcaneExplosion.java
index dfdd28b..4f58987 100644
--- a/src/main/java/com/hearthsim/card/spellcard/concrete/ArcaneExplosion.java
+++ b/src/main/java/com/hearthsim/card/spellcard/concrete/ArcaneExplosion.java
@@ -27,7 +27,7 @@ public class ArcaneExplosion extends SpellCard {
 		this(false);
 	}
 
-	@Override
+	
 	public Object deepCopy() {
 		return new ArcaneExplosion(this.hasBeenUsed);
 	}
@@ -45,7 +45,7 @@ public class ArcaneExplosion extends SpellCard {
      *
      * @return The boardState is manipulated and returned
 	 */
-	@Override
+	
 	protected HearthTreeNode use_core(
 			PlayerSide side,
 			Minion targetMinion,
diff --git a/src/main/java/com/hearthsim/card/spellcard/concrete/ArcaneIntellect.java b/src/main/java/com/hearthsim/card/spellcard/concrete/ArcaneIntellect.java
index d10b3bf..158acd8 100644
--- a/src/main/java/com/hearthsim/card/spellcard/concrete/ArcaneIntellect.java
+++ b/src/main/java/com/hearthsim/card/spellcard/concrete/ArcaneIntellect.java
@@ -28,7 +28,7 @@ public class ArcaneIntellect extends SpellCard {
 		this(false);
 	}
 
-	@Override
+	
 	public Object deepCopy() {
 		return new ArcaneIntellect(this.hasBeenUsed);
 	}
@@ -46,7 +46,7 @@ public class ArcaneIntellect extends SpellCard {
      *
      * @return The boardState is manipulated and returned
 	 */
-	@Override
+	
 	protected HearthTreeNode use_core(
 			PlayerSide side,
 			Minion targetMinion,
diff --git a/src/main/java/com/hearthsim/card/spellcard/concrete/ArcaneShot.java b/src/main/java/com/hearthsim/card/spellcard/concrete/ArcaneShot.java
index 2b024e1..3d16665 100644
--- a/src/main/java/com/hearthsim/card/spellcard/concrete/ArcaneShot.java
+++ b/src/main/java/com/hearthsim/card/spellcard/concrete/ArcaneShot.java
@@ -12,7 +12,7 @@ public class ArcaneShot extends SpellDamage {
 		super((byte)1, (byte)2, hasBeenUsed);
 	}
 	
-	@Override
+	
 	public Object deepCopy() {
 		return new ArcaneShot(this.hasBeenUsed);
 	}
diff --git a/src/main/java/com/hearthsim/card/spellcard/concrete/Assassinate.java b/src/main/java/com/hearthsim/card/spellcard/concrete/Assassinate.java
index 2a53473..ef745f2 100644
--- a/src/main/java/com/hearthsim/card/spellcard/concrete/Assassinate.java
+++ b/src/main/java/com/hearthsim/card/spellcard/concrete/Assassinate.java
@@ -27,7 +27,7 @@ public class Assassinate extends SpellCard {
 		this(false);
 	}
 	
-	@Override
+	
 	public Object deepCopy() {
 		return new Assassinate(this.hasBeenUsed);
 	}
@@ -45,7 +45,7 @@ public class Assassinate extends SpellCard {
      *
      * @return The boardState is manipulated and returned
 	 */
-	@Override
+	
 	protected HearthTreeNode use_core(
 			PlayerSide side,
 			Minion targetMinion,
diff --git a/src/main/java/com/hearthsim/card/spellcard/concrete/Backstab.java b/src/main/java/com/hearthsim/card/spellcard/concrete/Backstab.java
index b19d8d7..9281d07 100644
--- a/src/main/java/com/hearthsim/card/spellcard/concrete/Backstab.java
+++ b/src/main/java/com/hearthsim/card/spellcard/concrete/Backstab.java
@@ -17,7 +17,7 @@ public class Backstab extends SpellDamage {
 		super((byte)0, (byte)2, hasBeenUsed);
 	}
 	
-	@Override
+	
 	public Object deepCopy() {
 		return new Backstab(this.hasBeenUsed);
 	}
@@ -35,7 +35,7 @@ public class Backstab extends SpellDamage {
      *
      * @return The boardState is manipulated and returned
 	 */
-	@Override
+	
 	protected HearthTreeNode use_core(
 			PlayerSide side,
 			Minion targetMinion,
diff --git a/src/main/java/com/hearthsim/card/spellcard/concrete/BattleRage.java b/src/main/java/com/hearthsim/card/spellcard/concrete/BattleRage.java
index db90a36..292bd99 100644
--- a/src/main/java/com/hearthsim/card/spellcard/concrete/BattleRage.java
+++ b/src/main/java/com/hearthsim/card/spellcard/concrete/BattleRage.java
@@ -32,7 +32,7 @@ public class BattleRage extends SpellCard {
 		this(false);
 	}
 
-	@Override
+	
 	public Object deepCopy() {
 		return new BattleRage(this.hasBeenUsed);
 	}
@@ -50,7 +50,7 @@ public class BattleRage extends SpellCard {
 	 * 
 	 * @return The boardState is manipulated and returned
 	 */
-	@Override
+	
 	protected HearthTreeNode use_core(
 			PlayerSide targetPlayerSide,
 			Minion targetMinion,
diff --git a/src/main/java/com/hearthsim/card/spellcard/concrete/Bite.java b/src/main/java/com/hearthsim/card/spellcard/concrete/Bite.java
index f50a76e..92b88b0 100644
--- a/src/main/java/com/hearthsim/card/spellcard/concrete/Bite.java
+++ b/src/main/java/com/hearthsim/card/spellcard/concrete/Bite.java
@@ -4,6 +4,7 @@ import com.hearthsim.card.Deck;
 import com.hearthsim.card.minion.Hero;
 import com.hearthsim.card.minion.Minion;
 import com.hearthsim.card.spellcard.SpellCard;
+import com.hearthsim.entity.BaseEntity;
 import com.hearthsim.exception.HSException;
 import com.hearthsim.model.PlayerSide;
 import com.hearthsim.util.tree.HearthTreeNode;
@@ -28,7 +29,7 @@ public class Bite extends SpellCard {
 		this(false);
 	}
 
-	@Override
+	
 	public Object deepCopy() {
 		return new Bite(this.hasBeenUsed);
 	}
@@ -46,10 +47,10 @@ public class Bite extends SpellCard {
      *
      * @return The boardState is manipulated and returned
 	 */
-	@Override
+	
 	protected HearthTreeNode use_core(
 			PlayerSide side,
-			Minion targetMinion,
+			BaseEntity targetMinion,
 			HearthTreeNode boardState,
 			Deck deckPlayer0,
 			Deck deckPlayer1,
diff --git a/src/main/java/com/hearthsim/card/spellcard/concrete/BlessedChampion.java b/src/main/java/com/hearthsim/card/spellcard/concrete/BlessedChampion.java
index 63da0b5..d705bb9 100644
--- a/src/main/java/com/hearthsim/card/spellcard/concrete/BlessedChampion.java
+++ b/src/main/java/com/hearthsim/card/spellcard/concrete/BlessedChampion.java
@@ -27,7 +27,7 @@ public class BlessedChampion extends SpellCard {
 		this(false);
 	}
 
-	@Override
+	
 	public Object deepCopy() {
 		return new BlessedChampion(this.hasBeenUsed);
 	}
@@ -45,7 +45,7 @@ public class BlessedChampion extends SpellCard {
      *
      * @return The boardState is manipulated and returned
 	 */
-	@Override
+	
 	protected HearthTreeNode use_core(
 			PlayerSide side,
 			Minion targetMinion,
diff --git a/src/main/java/com/hearthsim/card/spellcard/concrete/BlessingOfKings.java b/src/main/java/com/hearthsim/card/spellcard/concrete/BlessingOfKings.java
index ee284ad..abaede9 100644
--- a/src/main/java/com/hearthsim/card/spellcard/concrete/BlessingOfKings.java
+++ b/src/main/java/com/hearthsim/card/spellcard/concrete/BlessingOfKings.java
@@ -27,7 +27,7 @@ public class BlessingOfKings extends SpellCard {
 		this(false);
 	}
 
-	@Override
+	
 	public Object deepCopy() {
 		return new BlessingOfKings(this.hasBeenUsed);
 	}
@@ -45,7 +45,7 @@ public class BlessingOfKings extends SpellCard {
      *
      * @return The boardState is manipulated and returned
 	 */
-	@Override
+	
 	protected HearthTreeNode use_core(
 			PlayerSide side,
 			Minion targetMinion,
diff --git a/src/main/java/com/hearthsim/card/spellcard/concrete/BlessingOfMight.java b/src/main/java/com/hearthsim/card/spellcard/concrete/BlessingOfMight.java
index de5d18f..2925daf 100644
--- a/src/main/java/com/hearthsim/card/spellcard/concrete/BlessingOfMight.java
+++ b/src/main/java/com/hearthsim/card/spellcard/concrete/BlessingOfMight.java
@@ -26,7 +26,7 @@ public class BlessingOfMight extends SpellCard {
 		this(false);
 	}
 	
-	@Override
+	
 	public Object deepCopy() {
 		return new BlessingOfMight(this.hasBeenUsed);
 	}
@@ -44,7 +44,7 @@ public class BlessingOfMight extends SpellCard {
      *
      * @return The boardState is manipulated and returned
 	 */
-	@Override
+	
 	protected HearthTreeNode use_core(
 			PlayerSide side,
 			Minion targetMinion,
diff --git a/src/main/java/com/hearthsim/card/spellcard/concrete/Bloodlust.java b/src/main/java/com/hearthsim/card/spellcard/concrete/Bloodlust.java
index a1fe2b3..85ad335 100644
--- a/src/main/java/com/hearthsim/card/spellcard/concrete/Bloodlust.java
+++ b/src/main/java/com/hearthsim/card/spellcard/concrete/Bloodlust.java
@@ -17,7 +17,7 @@ public class Bloodlust extends SpellCard {
 		super((byte)5, hasBeenUsed);
 	}
 	
-	@Override
+	
 	public Object deepCopy() {
 		return new Bloodlust(this.hasBeenUsed);
 	}
@@ -35,7 +35,7 @@ public class Bloodlust extends SpellCard {
      *
      * @return The boardState is manipulated and returned
 	 */
-	@Override
+	
 	protected HearthTreeNode use_core(
 			PlayerSide side,
 			Minion targetMinion,
diff --git a/src/main/java/com/hearthsim/card/spellcard/concrete/Charge.java b/src/main/java/com/hearthsim/card/spellcard/concrete/Charge.java
index 6903699..7c970d8 100644
--- a/src/main/java/com/hearthsim/card/spellcard/concrete/Charge.java
+++ b/src/main/java/com/hearthsim/card/spellcard/concrete/Charge.java
@@ -27,7 +27,7 @@ public class Charge extends SpellCard {
 		this(false);
 	}
 	
-	@Override
+	
 	public Object deepCopy() {
 		return new Charge(this.hasBeenUsed);
 	}
@@ -45,7 +45,7 @@ public class Charge extends SpellCard {
      *
      * @return The boardState is manipulated and returned
 	 */
-	@Override
+	
 	protected HearthTreeNode use_core(
 			PlayerSide side,
 			Minion targetMinion,
diff --git a/src/main/java/com/hearthsim/card/spellcard/concrete/CircleOfHealing.java b/src/main/java/com/hearthsim/card/spellcard/concrete/CircleOfHealing.java
index 8f0ffca..7a6819f 100644
--- a/src/main/java/com/hearthsim/card/spellcard/concrete/CircleOfHealing.java
+++ b/src/main/java/com/hearthsim/card/spellcard/concrete/CircleOfHealing.java
@@ -29,7 +29,7 @@ public class CircleOfHealing extends SpellCard {
 		this(false);
 	}
 	
-	@Override
+	
 	public Object deepCopy() {
 		return new CircleOfHealing(this.hasBeenUsed);
 	}
@@ -48,7 +48,7 @@ public class CircleOfHealing extends SpellCard {
      *
      * @return The boardState is manipulated and returned
 	 */
-	@Override
+	
 	protected HearthTreeNode use_core(
 			PlayerSide side,
 			Minion targetMinion,
diff --git a/src/main/java/com/hearthsim/card/spellcard/concrete/Claw.java b/src/main/java/com/hearthsim/card/spellcard/concrete/Claw.java
index 6ff4662..ef3e984 100644
--- a/src/main/java/com/hearthsim/card/spellcard/concrete/Claw.java
+++ b/src/main/java/com/hearthsim/card/spellcard/concrete/Claw.java
@@ -4,6 +4,7 @@ import com.hearthsim.card.Deck;
 import com.hearthsim.card.minion.Hero;
 import com.hearthsim.card.minion.Minion;
 import com.hearthsim.card.spellcard.SpellCard;
+import com.hearthsim.entity.BaseEntity;
 import com.hearthsim.exception.HSException;
 import com.hearthsim.model.PlayerSide;
 import com.hearthsim.util.tree.HearthTreeNode;
@@ -31,7 +32,7 @@ public class Claw extends SpellCard {
 		this(false);
 	}
 	
-	@Override
+	
 	public Object deepCopy() {
 		return new Claw(this.hasBeenUsed);
 	}
@@ -48,10 +49,10 @@ public class Claw extends SpellCard {
      *
      * @return The boardState is manipulated and returned
 	 */
-	@Override
+	
 	protected HearthTreeNode use_core(
 			PlayerSide side,
-			Minion targetMinion,
+			BaseEntity targetMinion,
 			HearthTreeNode boardState,
 			Deck deckPlayer0,
 			Deck deckPlayer1,
diff --git a/src/main/java/com/hearthsim/card/spellcard/concrete/Consecration.java b/src/main/java/com/hearthsim/card/spellcard/concrete/Consecration.java
index c20be4a..20d6255 100644
--- a/src/main/java/com/hearthsim/card/spellcard/concrete/Consecration.java
+++ b/src/main/java/com/hearthsim/card/spellcard/concrete/Consecration.java
@@ -29,7 +29,7 @@ public class Consecration extends SpellCard {
 		this(false);
 	}
 	
-	@Override
+	
 	public Object deepCopy() {
 		return new Consecration(this.hasBeenUsed);
 	}
@@ -47,7 +47,7 @@ public class Consecration extends SpellCard {
      *
      * @return The boardState is manipulated and returned
 	 */
-	@Override
+	
 	protected HearthTreeNode use_core(
 			PlayerSide side,
 			Minion targetMinion,
diff --git a/src/main/java/com/hearthsim/card/spellcard/concrete/Corruption.java b/src/main/java/com/hearthsim/card/spellcard/concrete/Corruption.java
index 2708b0d..8e09d97 100644
--- a/src/main/java/com/hearthsim/card/spellcard/concrete/Corruption.java
+++ b/src/main/java/com/hearthsim/card/spellcard/concrete/Corruption.java
@@ -27,7 +27,7 @@ public class Corruption extends SpellCard {
 		this(false);
 	}
 	
-	@Override
+	
 	public Object deepCopy() {
 		return new Corruption(this.hasBeenUsed);
 	}
@@ -45,7 +45,7 @@ public class Corruption extends SpellCard {
      *
      * @return The boardState is manipulated and returned
 	 */
-	@Override
+	
 	protected HearthTreeNode use_core(
 			PlayerSide side,
 			Minion targetMinion,
diff --git a/src/main/java/com/hearthsim/card/spellcard/concrete/DeadlyPoison.java b/src/main/java/com/hearthsim/card/spellcard/concrete/DeadlyPoison.java
index 568aeb3..0fb2b6b 100644
--- a/src/main/java/com/hearthsim/card/spellcard/concrete/DeadlyPoison.java
+++ b/src/main/java/com/hearthsim/card/spellcard/concrete/DeadlyPoison.java
@@ -4,6 +4,7 @@ import com.hearthsim.card.Deck;
 import com.hearthsim.card.minion.Hero;
 import com.hearthsim.card.minion.Minion;
 import com.hearthsim.card.spellcard.SpellCard;
+import com.hearthsim.entity.BaseEntity;
 import com.hearthsim.exception.HSException;
 import com.hearthsim.model.PlayerSide;
 import com.hearthsim.util.tree.HearthTreeNode;
@@ -29,7 +30,7 @@ public class DeadlyPoison extends SpellCard {
 		this(false);
 	}
 	
-	@Override
+	
 	public Object deepCopy() {
 		return new DeadlyPoison(this.hasBeenUsed);
 	}
@@ -45,10 +46,10 @@ public class DeadlyPoison extends SpellCard {
      *
      * @return The boardState is manipulated and returned
 	 */
-	@Override
+
 	protected HearthTreeNode use_core(
 			PlayerSide side,
-			Minion targetMinion,
+			BaseEntity targetMinion,
 			HearthTreeNode boardState,
 			Deck deckPlayer0,
 			Deck deckPlayer1,
diff --git a/src/main/java/com/hearthsim/card/spellcard/concrete/Demonfire.java b/src/main/java/com/hearthsim/card/spellcard/concrete/Demonfire.java
index b946830..d5c051b 100644
--- a/src/main/java/com/hearthsim/card/spellcard/concrete/Demonfire.java
+++ b/src/main/java/com/hearthsim/card/spellcard/concrete/Demonfire.java
@@ -28,7 +28,7 @@ public class Demonfire extends SpellCard {
 		this(false);
 	}
 
-	@Override
+	
 	public Object deepCopy() {
 		return new Demonfire(this.hasBeenUsed);
 	}
@@ -48,7 +48,7 @@ public class Demonfire extends SpellCard {
      *
      * @return The boardState is manipulated and returned
 	 */
-	@Override
+	
 	protected HearthTreeNode use_core(
 			PlayerSide side,
 			Minion targetMinion,
diff --git a/src/main/java/com/hearthsim/card/spellcard/concrete/DivineFavor.java b/src/main/java/com/hearthsim/card/spellcard/concrete/DivineFavor.java
index 62e624f..3248471 100644
--- a/src/main/java/com/hearthsim/card/spellcard/concrete/DivineFavor.java
+++ b/src/main/java/com/hearthsim/card/spellcard/concrete/DivineFavor.java
@@ -27,7 +27,7 @@ public class DivineFavor extends SpellCard {
 		this(false);
 	}
 
-	@Override
+	
 	public Object deepCopy() {
 		return new DivineFavor(this.hasBeenUsed);
 	}
@@ -45,7 +45,7 @@ public class DivineFavor extends SpellCard {
      *
      * @return The boardState is manipulated and returned
 	 */
-	@Override
+	
 	protected HearthTreeNode use_core(
 			PlayerSide side,
 			Minion targetMinion,
diff --git a/src/main/java/com/hearthsim/card/spellcard/concrete/DivineSpirit.java b/src/main/java/com/hearthsim/card/spellcard/concrete/DivineSpirit.java
index 28a31fb..6ad577c 100644
--- a/src/main/java/com/hearthsim/card/spellcard/concrete/DivineSpirit.java
+++ b/src/main/java/com/hearthsim/card/spellcard/concrete/DivineSpirit.java
@@ -28,7 +28,7 @@ public class DivineSpirit extends SpellCard {
 		this(false);
 	}
 	
-	@Override
+	
 	public Object deepCopy() {
 		return new DivineSpirit(this.hasBeenUsed);
 	}
@@ -46,7 +46,7 @@ public class DivineSpirit extends SpellCard {
      *
      * @return The boardState is manipulated and returned
 	 */
-	@Override
+	
 	protected HearthTreeNode use_core(
 			PlayerSide side,
 			Minion targetMinion,
diff --git a/src/main/java/com/hearthsim/card/spellcard/concrete/DrainLife.java b/src/main/java/com/hearthsim/card/spellcard/concrete/DrainLife.java
index 9ee35ae..fae6dbb 100644
--- a/src/main/java/com/hearthsim/card/spellcard/concrete/DrainLife.java
+++ b/src/main/java/com/hearthsim/card/spellcard/concrete/DrainLife.java
@@ -17,7 +17,7 @@ public class DrainLife extends SpellDamage {
 		super((byte)3, (byte)2, hasBeenUsed);
 	}
 
-	@Override
+	
 	public Object deepCopy() {
 		return new DrainLife(this.hasBeenUsed);
 	}
@@ -35,7 +35,7 @@ public class DrainLife extends SpellDamage {
      *
      * @return The boardState is manipulated and returned
 	 */
-	@Override
+	
 	protected HearthTreeNode use_core(
 			PlayerSide side,
 			Minion targetMinion,
diff --git a/src/main/java/com/hearthsim/card/spellcard/concrete/Equality.java b/src/main/java/com/hearthsim/card/spellcard/concrete/Equality.java
index 70731bb..de34722 100644
--- a/src/main/java/com/hearthsim/card/spellcard/concrete/Equality.java
+++ b/src/main/java/com/hearthsim/card/spellcard/concrete/Equality.java
@@ -27,7 +27,7 @@ public class Equality extends SpellCard {
 		this(false);
 	}
 	
-	@Override
+	
 	public Object deepCopy() {
 		return new Equality(this.hasBeenUsed);
 	}
@@ -41,7 +41,7 @@ public class Equality extends SpellCard {
      *
      * @return The boardState is manipulated and returned
 	 */
-	@Override
+	
 	protected HearthTreeNode use_core(
 			PlayerSide side,
 			Minion targetMinion,
diff --git a/src/main/java/com/hearthsim/card/spellcard/concrete/ExcessMana.java b/src/main/java/com/hearthsim/card/spellcard/concrete/ExcessMana.java
index 32efab0..39e72fa 100644
--- a/src/main/java/com/hearthsim/card/spellcard/concrete/ExcessMana.java
+++ b/src/main/java/com/hearthsim/card/spellcard/concrete/ExcessMana.java
@@ -28,7 +28,7 @@ public class ExcessMana extends SpellCard {
 		this(false);
 	}
 
-	@Override
+	
 	public Object deepCopy() {
 		return new ExcessMana(this.hasBeenUsed);
 	}
@@ -46,7 +46,7 @@ public class ExcessMana extends SpellCard {
      *
      * @return The boardState is manipulated and returned
 	 */
-	@Override
+	
 	protected HearthTreeNode use_core(
 			PlayerSide side,
 			Minion targetMinion,
diff --git a/src/main/java/com/hearthsim/card/spellcard/concrete/Execute.java b/src/main/java/com/hearthsim/card/spellcard/concrete/Execute.java
index 8e0ae20..c7ef09d 100644
--- a/src/main/java/com/hearthsim/card/spellcard/concrete/Execute.java
+++ b/src/main/java/com/hearthsim/card/spellcard/concrete/Execute.java
@@ -27,7 +27,7 @@ public class Execute extends SpellCard {
 		this(false);
 	}
 	
-	@Override
+	
 	public Object deepCopy() {
 		return new Execute(this.hasBeenUsed);
 	}
@@ -45,7 +45,7 @@ public class Execute extends SpellCard {
      *
      * @return The boardState is manipulated and returned
 	 */
-	@Override
+	
 	protected HearthTreeNode use_core(
 			PlayerSide side,
 			Minion targetMinion,
diff --git a/src/main/java/com/hearthsim/card/spellcard/concrete/FanOfKnives.java b/src/main/java/com/hearthsim/card/spellcard/concrete/FanOfKnives.java
index b34cad2..2a39792 100644
--- a/src/main/java/com/hearthsim/card/spellcard/concrete/FanOfKnives.java
+++ b/src/main/java/com/hearthsim/card/spellcard/concrete/FanOfKnives.java
@@ -29,7 +29,7 @@ public class FanOfKnives extends SpellCard {
 		this(false);
 	}
 
-	@Override
+	
 	public Object deepCopy() {
 		return new FanOfKnives(this.hasBeenUsed);
 	}
@@ -47,7 +47,7 @@ public class FanOfKnives extends SpellCard {
      *
      * @return The boardState is manipulated and returned
 	 */
-	@Override
+	
 	protected HearthTreeNode use_core(
 			PlayerSide side,
 			Minion targetMinion,
diff --git a/src/main/java/com/hearthsim/card/spellcard/concrete/Fireball.java b/src/main/java/com/hearthsim/card/spellcard/concrete/Fireball.java
index 10f8195..8d8973f 100644
--- a/src/main/java/com/hearthsim/card/spellcard/concrete/Fireball.java
+++ b/src/main/java/com/hearthsim/card/spellcard/concrete/Fireball.java
@@ -12,7 +12,7 @@ public class Fireball extends SpellDamage {
 		super((byte)4, (byte)6, hasBeenUsed);
 	}
 
-	@Override
+	
 	public Object deepCopy() {
 		return new Fireball(this.hasBeenUsed);
 	}
diff --git a/src/main/java/com/hearthsim/card/spellcard/concrete/Flamestrike.java b/src/main/java/com/hearthsim/card/spellcard/concrete/Flamestrike.java
index 2ec69cc..7044dd2 100644
--- a/src/main/java/com/hearthsim/card/spellcard/concrete/Flamestrike.java
+++ b/src/main/java/com/hearthsim/card/spellcard/concrete/Flamestrike.java
@@ -27,7 +27,7 @@ public class Flamestrike extends SpellCard {
 		this(false);
 	}
 
-	@Override
+	
 	public Object deepCopy() {
 		return new Flamestrike(this.hasBeenUsed);
 	}
@@ -45,7 +45,7 @@ public class Flamestrike extends SpellCard {
      *
      * @return The boardState is manipulated and returned
 	 */
-	@Override
+	
 	protected HearthTreeNode use_core(
 			PlayerSide side,
 			Minion targetMinion,
diff --git a/src/main/java/com/hearthsim/card/spellcard/concrete/FrostNova.java b/src/main/java/com/hearthsim/card/spellcard/concrete/FrostNova.java
index dec6297..d3d7b3c 100644
--- a/src/main/java/com/hearthsim/card/spellcard/concrete/FrostNova.java
+++ b/src/main/java/com/hearthsim/card/spellcard/concrete/FrostNova.java
@@ -26,7 +26,7 @@ public class FrostNova extends SpellCard {
 		this(false);
 	}
 
-	@Override
+	
 	public Object deepCopy() {
 		return new Flamestrike(this.hasBeenUsed);
 	}
@@ -44,7 +44,7 @@ public class FrostNova extends SpellCard {
      *
      * @return The boardState is manipulated and returned
 	 */
-	@Override
+	
 	protected HearthTreeNode use_core(
 			PlayerSide side,
 			Minion targetMinion,
diff --git a/src/main/java/com/hearthsim/card/spellcard/concrete/FrostShock.java b/src/main/java/com/hearthsim/card/spellcard/concrete/FrostShock.java
index 9389aa4..589e6ce 100644
--- a/src/main/java/com/hearthsim/card/spellcard/concrete/FrostShock.java
+++ b/src/main/java/com/hearthsim/card/spellcard/concrete/FrostShock.java
@@ -17,7 +17,7 @@ public class FrostShock extends SpellDamage {
 		super((byte)1, (byte)1, hasBeenUsed);
 	}
 
-	@Override
+	
 	public Object deepCopy() {
 		return new FrostShock(this.hasBeenUsed);
 	}
@@ -35,7 +35,7 @@ public class FrostShock extends SpellDamage {
      *
      * @return The boardState is manipulated and returned
 	 */
-	@Override
+	
 	protected HearthTreeNode use_core(
 			PlayerSide side,
 			Minion targetMinion,
diff --git a/src/main/java/com/hearthsim/card/spellcard/concrete/Frostbolt.java b/src/main/java/com/hearthsim/card/spellcard/concrete/Frostbolt.java
index 6e484a8..e32194e 100644
--- a/src/main/java/com/hearthsim/card/spellcard/concrete/Frostbolt.java
+++ b/src/main/java/com/hearthsim/card/spellcard/concrete/Frostbolt.java
@@ -17,7 +17,7 @@ public class Frostbolt extends SpellDamage {
 		super((byte)2, (byte)3, hasBeenUsed);
 	}
 	
-	@Override
+	
 	public Object deepCopy() {
 		return new Frostbolt(this.hasBeenUsed);
 	}
@@ -35,7 +35,7 @@ public class Frostbolt extends SpellDamage {
      *
      * @return The boardState is manipulated and returned
 	 */
-	@Override
+	
 	protected HearthTreeNode use_core(
 			PlayerSide side,
 			Minion targetMinion,
diff --git a/src/main/java/com/hearthsim/card/spellcard/concrete/HammerOfWrath.java b/src/main/java/com/hearthsim/card/spellcard/concrete/HammerOfWrath.java
index 0d3b9bb..0d6d1e6 100644
--- a/src/main/java/com/hearthsim/card/spellcard/concrete/HammerOfWrath.java
+++ b/src/main/java/com/hearthsim/card/spellcard/concrete/HammerOfWrath.java
@@ -18,7 +18,7 @@ public class HammerOfWrath extends SpellDamage {
 		super((byte)4, (byte)3, hasBeenUsed);
 	}
 
-	@Override
+	
 	public Object deepCopy() {
 		return new HammerOfWrath(this.hasBeenUsed);
 	}
@@ -36,7 +36,7 @@ public class HammerOfWrath extends SpellDamage {
      *
      * @return The boardState is manipulated and returned
 	 */
-	@Override
+	
 	protected HearthTreeNode use_core(
 			PlayerSide side,
 			Minion targetMinion,
diff --git a/src/main/java/com/hearthsim/card/spellcard/concrete/HandOfProtection.java b/src/main/java/com/hearthsim/card/spellcard/concrete/HandOfProtection.java
index 7bd562d..a7c971f 100644
--- a/src/main/java/com/hearthsim/card/spellcard/concrete/HandOfProtection.java
+++ b/src/main/java/com/hearthsim/card/spellcard/concrete/HandOfProtection.java
@@ -27,7 +27,7 @@ public class HandOfProtection extends SpellCard {
 		this(false);
 	}
 	
-	@Override
+	
 	public Object deepCopy() {
 		return new HandOfProtection(this.hasBeenUsed);
 	}
@@ -45,7 +45,7 @@ public class HandOfProtection extends SpellCard {
      *
      * @return The boardState is manipulated and returned
 	 */
-	@Override
+	
 	protected HearthTreeNode use_core(
 			PlayerSide side,
 			Minion targetMinion,
diff --git a/src/main/java/com/hearthsim/card/spellcard/concrete/HealingTouch.java b/src/main/java/com/hearthsim/card/spellcard/concrete/HealingTouch.java
index a7ee866..3c49d7f 100644
--- a/src/main/java/com/hearthsim/card/spellcard/concrete/HealingTouch.java
+++ b/src/main/java/com/hearthsim/card/spellcard/concrete/HealingTouch.java
@@ -29,7 +29,7 @@ public class HealingTouch extends SpellCard {
 		this(false);
 	}
 	
-	@Override
+	
 	public Object deepCopy() {
 		return new HealingTouch(this.hasBeenUsed);
 	}
@@ -47,7 +47,7 @@ public class HealingTouch extends SpellCard {
      *
      * @return The boardState is manipulated and returned
 	 */
-	@Override
+	
 	protected HearthTreeNode use_core(
 			PlayerSide side,
 			Minion targetMinion,
diff --git a/src/main/java/com/hearthsim/card/spellcard/concrete/Hellfire.java b/src/main/java/com/hearthsim/card/spellcard/concrete/Hellfire.java
index cb53556..6b9e019 100644
--- a/src/main/java/com/hearthsim/card/spellcard/concrete/Hellfire.java
+++ b/src/main/java/com/hearthsim/card/spellcard/concrete/Hellfire.java
@@ -29,7 +29,7 @@ public class Hellfire extends SpellCard {
 		this(false);
 	}
 	
-	@Override
+	
 	public Object deepCopy() {
 		return new Hellfire(this.hasBeenUsed);
 	}
@@ -47,7 +47,7 @@ public class Hellfire extends SpellCard {
      *
      * @return The boardState is manipulated and returned
 	 */
-	@Override
+	
 	protected HearthTreeNode use_core(
 			PlayerSide side,
 			Minion targetMinion,
diff --git a/src/main/java/com/hearthsim/card/spellcard/concrete/HeroicStrike.java b/src/main/java/com/hearthsim/card/spellcard/concrete/HeroicStrike.java
index 90a373a..2e21708 100644
--- a/src/main/java/com/hearthsim/card/spellcard/concrete/HeroicStrike.java
+++ b/src/main/java/com/hearthsim/card/spellcard/concrete/HeroicStrike.java
@@ -29,7 +29,7 @@ public class HeroicStrike extends SpellCard {
 		this(false);
 	}
 	
-	@Override
+	
 	public Object deepCopy() {
 		return new HeroicStrike(this.hasBeenUsed);
 	}
@@ -46,7 +46,7 @@ public class HeroicStrike extends SpellCard {
      *
      * @return The boardState is manipulated and returned
 	 */
-	@Override
+	
 	protected HearthTreeNode use_core(
 			PlayerSide side,
 			Minion targetMinion,
diff --git a/src/main/java/com/hearthsim/card/spellcard/concrete/Hex.java b/src/main/java/com/hearthsim/card/spellcard/concrete/Hex.java
index 3c8ea00..76db13c 100644
--- a/src/main/java/com/hearthsim/card/spellcard/concrete/Hex.java
+++ b/src/main/java/com/hearthsim/card/spellcard/concrete/Hex.java
@@ -28,7 +28,7 @@ public class Hex extends SpellCard {
 		this(false);
 	}
 	
-	@Override
+	
 	public Object deepCopy() {
 		return new Hex(this.hasBeenUsed);
 	}
@@ -46,7 +46,7 @@ public class Hex extends SpellCard {
      *
      * @return The boardState is manipulated and returned
 	 */
-	@Override
+	
 	protected HearthTreeNode use_core(
 			PlayerSide side,
 			Minion targetMinion,
diff --git a/src/main/java/com/hearthsim/card/spellcard/concrete/HolyFire.java b/src/main/java/com/hearthsim/card/spellcard/concrete/HolyFire.java
index 30b716e..390a945 100644
--- a/src/main/java/com/hearthsim/card/spellcard/concrete/HolyFire.java
+++ b/src/main/java/com/hearthsim/card/spellcard/concrete/HolyFire.java
@@ -18,7 +18,7 @@ public class HolyFire extends SpellDamage {
 		super((byte)6, (byte)5, hasBeenUsed);
 	}
 
-	@Override
+	
 	public Object deepCopy() {
 		return new HolyFire(this.hasBeenUsed);
 	}
@@ -36,7 +36,7 @@ public class HolyFire extends SpellDamage {
      *
      * @return The boardState is manipulated and returned
 	 */
-	@Override
+	
 	protected HearthTreeNode use_core(
 			PlayerSide side,
 			Minion targetMinion,
diff --git a/src/main/java/com/hearthsim/card/spellcard/concrete/HolyLight.java b/src/main/java/com/hearthsim/card/spellcard/concrete/HolyLight.java
index 378c93d..90b6821 100644
--- a/src/main/java/com/hearthsim/card/spellcard/concrete/HolyLight.java
+++ b/src/main/java/com/hearthsim/card/spellcard/concrete/HolyLight.java
@@ -29,7 +29,7 @@ public class HolyLight extends SpellCard {
 		this(false);
 	}
 	
-	@Override
+	
 	public Object deepCopy() {
 		return new HolyLight(this.hasBeenUsed);
 	}
@@ -47,7 +47,7 @@ public class HolyLight extends SpellCard {
      *
      * @return The boardState is manipulated and returned
 	 */
-	@Override
+	
 	protected HearthTreeNode use_core(
 			PlayerSide side,
 			Minion targetMinion,
diff --git a/src/main/java/com/hearthsim/card/spellcard/concrete/HolyNova.java b/src/main/java/com/hearthsim/card/spellcard/concrete/HolyNova.java
index 94cf892..a39dade 100644
--- a/src/main/java/com/hearthsim/card/spellcard/concrete/HolyNova.java
+++ b/src/main/java/com/hearthsim/card/spellcard/concrete/HolyNova.java
@@ -28,7 +28,7 @@ public class HolyNova extends SpellCard {
 		this(false);
 	}
 
-	@Override
+	
 	public Object deepCopy() {
 		return new HolyNova(this.hasBeenUsed);
 	}
@@ -46,7 +46,7 @@ public class HolyNova extends SpellCard {
      *
      * @return The boardState is manipulated and returned
 	 */
-	@Override
+	
 	protected HearthTreeNode use_core(
 			PlayerSide side,
 			Minion targetMinion,
diff --git a/src/main/java/com/hearthsim/card/spellcard/concrete/HolySmite.java b/src/main/java/com/hearthsim/card/spellcard/concrete/HolySmite.java
index 8499245..9fbba3a 100644
--- a/src/main/java/com/hearthsim/card/spellcard/concrete/HolySmite.java
+++ b/src/main/java/com/hearthsim/card/spellcard/concrete/HolySmite.java
@@ -12,7 +12,7 @@ public class HolySmite extends SpellDamage {
 		super((byte)1, (byte)2, hasBeenUsed);
 	}
 	
-	@Override
+	
 	public Object deepCopy() {
 		return new HolySmite(this.hasBeenUsed);
 	}
diff --git a/src/main/java/com/hearthsim/card/spellcard/concrete/Humility.java b/src/main/java/com/hearthsim/card/spellcard/concrete/Humility.java
index b5c3987..1e358fe 100644
--- a/src/main/java/com/hearthsim/card/spellcard/concrete/Humility.java
+++ b/src/main/java/com/hearthsim/card/spellcard/concrete/Humility.java
@@ -29,7 +29,7 @@ public class Humility extends SpellCard {
 		this(false);
 	}
 
-	@Override
+	
 	public Object deepCopy() {
 		return new Humility(this.hasBeenUsed);
 	}
@@ -47,7 +47,7 @@ public class Humility extends SpellCard {
      *
      * @return The boardState is manipulated and returned
 	 */
-	@Override
+	
 	protected HearthTreeNode use_core(
 			PlayerSide side,
 			Minion targetMinion,
diff --git a/src/main/java/com/hearthsim/card/spellcard/concrete/HuntersMark.java b/src/main/java/com/hearthsim/card/spellcard/concrete/HuntersMark.java
index 7746a95..70a48f1 100644
--- a/src/main/java/com/hearthsim/card/spellcard/concrete/HuntersMark.java
+++ b/src/main/java/com/hearthsim/card/spellcard/concrete/HuntersMark.java
@@ -26,7 +26,7 @@ public class HuntersMark extends SpellCard {
 		this(false);
 	}
 
-	@Override
+	
 	public Object deepCopy() {
 		return new HuntersMark(this.hasBeenUsed);
 	}
@@ -44,7 +44,7 @@ public class HuntersMark extends SpellCard {
      *
      * @return The boardState is manipulated and returned
 	 */
-	@Override
+	
 	protected HearthTreeNode use_core(
 			PlayerSide side,
 			Minion targetMinion,
diff --git a/src/main/java/com/hearthsim/card/spellcard/concrete/InnerFire.java b/src/main/java/com/hearthsim/card/spellcard/concrete/InnerFire.java
index 136f85c..8704e32 100644
--- a/src/main/java/com/hearthsim/card/spellcard/concrete/InnerFire.java
+++ b/src/main/java/com/hearthsim/card/spellcard/concrete/InnerFire.java
@@ -27,7 +27,7 @@ public class InnerFire extends SpellCard {
 		this(false);
 	}
 
-	@Override
+	
 	public Object deepCopy() {
 		return new InnerFire(this.hasBeenUsed);
 	}
@@ -45,7 +45,7 @@ public class InnerFire extends SpellCard {
      *
      * @return The boardState is manipulated and returned
 	 */
-	@Override
+	
 	protected HearthTreeNode use_core(
 			PlayerSide side,
 			Minion targetMinion,
diff --git a/src/main/java/com/hearthsim/card/spellcard/concrete/InnerRage.java b/src/main/java/com/hearthsim/card/spellcard/concrete/InnerRage.java
index 65f8120..8068315 100644
--- a/src/main/java/com/hearthsim/card/spellcard/concrete/InnerRage.java
+++ b/src/main/java/com/hearthsim/card/spellcard/concrete/InnerRage.java
@@ -27,7 +27,7 @@ public class InnerRage extends SpellCard {
 		this(false);
 	}
 
-	@Override
+	
 	public Object deepCopy() {
 		return new InnerRage(this.hasBeenUsed);
 	}
@@ -45,7 +45,7 @@ public class InnerRage extends SpellCard {
      *
      * @return The boardState is manipulated and returned
 	 */
-	@Override
+	
 	protected HearthTreeNode use_core(
 			PlayerSide side,
 			Minion targetMinion,
diff --git a/src/main/java/com/hearthsim/card/spellcard/concrete/Innervate.java b/src/main/java/com/hearthsim/card/spellcard/concrete/Innervate.java
index 22e688a..b8fc843 100644
--- a/src/main/java/com/hearthsim/card/spellcard/concrete/Innervate.java
+++ b/src/main/java/com/hearthsim/card/spellcard/concrete/Innervate.java
@@ -27,7 +27,7 @@ public class Innervate extends SpellCard {
 		this(false);
 	}
 
-	@Override
+	
 	public Object deepCopy() {
 		return new Innervate(this.hasBeenUsed);
 	}
@@ -45,7 +45,7 @@ public class Innervate extends SpellCard {
      *
      * @return The boardState is manipulated and returned
 	 */
-	@Override
+	
 	protected HearthTreeNode use_core(
 			PlayerSide side,
 			Minion targetMinion,
diff --git a/src/main/java/com/hearthsim/card/spellcard/concrete/KillCommand.java b/src/main/java/com/hearthsim/card/spellcard/concrete/KillCommand.java
index adc75fb..a4a7bce 100644
--- a/src/main/java/com/hearthsim/card/spellcard/concrete/KillCommand.java
+++ b/src/main/java/com/hearthsim/card/spellcard/concrete/KillCommand.java
@@ -4,6 +4,7 @@ import com.hearthsim.card.Deck;
 import com.hearthsim.card.minion.Beast;
 import com.hearthsim.card.minion.Minion;
 import com.hearthsim.card.spellcard.SpellDamage;
+import com.hearthsim.entity.BaseEntity;
 import com.hearthsim.exception.HSException;
 import com.hearthsim.model.PlayerSide;
 import com.hearthsim.util.tree.HearthTreeNode;
@@ -18,7 +19,7 @@ public class KillCommand extends SpellDamage {
 		super((byte)3, (byte)3, hasBeenUsed);
 	}
 
-	@Override
+	
 	public Object deepCopy() {
 		return new KillCommand(this.hasBeenUsed);
 	}
@@ -36,10 +37,10 @@ public class KillCommand extends SpellDamage {
      *
      * @return The boardState is manipulated and returned
 	 */
-	@Override
+	
 	protected HearthTreeNode use_core(
 			PlayerSide side,
-			Minion targetMinion,
+			BaseEntity targetMinion,
 			HearthTreeNode boardState,
 			Deck deckPlayer0,
 			Deck deckPlayer1,
diff --git a/src/main/java/com/hearthsim/card/spellcard/concrete/LavaBurst.java b/src/main/java/com/hearthsim/card/spellcard/concrete/LavaBurst.java
index e54a34f..16c7a86 100644
--- a/src/main/java/com/hearthsim/card/spellcard/concrete/LavaBurst.java
+++ b/src/main/java/com/hearthsim/card/spellcard/concrete/LavaBurst.java
@@ -17,7 +17,7 @@ public class LavaBurst extends SpellDamage {
 		super((byte)3, (byte)5, hasBeenUsed);
 	}
 
-	@Override
+	
 	public Object deepCopy() {
 		return new LavaBurst(this.hasBeenUsed);
 	}
@@ -35,7 +35,7 @@ public class LavaBurst extends SpellDamage {
      *
      * @return The boardState is manipulated and returned
 	 */
-	@Override
+	
 	protected HearthTreeNode use_core(
 			PlayerSide side,
 			Minion targetMinion,
diff --git a/src/main/java/com/hearthsim/card/spellcard/concrete/LayOnHands.java b/src/main/java/com/hearthsim/card/spellcard/concrete/LayOnHands.java
index 4cebca6..fb8a276 100644
--- a/src/main/java/com/hearthsim/card/spellcard/concrete/LayOnHands.java
+++ b/src/main/java/com/hearthsim/card/spellcard/concrete/LayOnHands.java
@@ -28,7 +28,7 @@ public class LayOnHands extends SpellCard {
 		this(false);
 	}
 
-	@Override
+	
 	public Object deepCopy() {
 		return new LayOnHands(this.hasBeenUsed);
 	}
@@ -46,7 +46,7 @@ public class LayOnHands extends SpellCard {
      *
      * @return The boardState is manipulated and returned
 	 */
-	@Override
+	
 	protected HearthTreeNode use_core(
 			PlayerSide side,
 			Minion targetMinion,
diff --git a/src/main/java/com/hearthsim/card/spellcard/concrete/LightningBolt.java b/src/main/java/com/hearthsim/card/spellcard/concrete/LightningBolt.java
index 0981f0a..ca0d729 100644
--- a/src/main/java/com/hearthsim/card/spellcard/concrete/LightningBolt.java
+++ b/src/main/java/com/hearthsim/card/spellcard/concrete/LightningBolt.java
@@ -17,7 +17,7 @@ public class LightningBolt extends SpellDamage {
 		super((byte)1, (byte)3, hasBeenUsed);
 	}
 
-	@Override
+	
 	public Object deepCopy() {
 		return new LightningBolt(this.hasBeenUsed);
 	}
@@ -35,7 +35,7 @@ public class LightningBolt extends SpellDamage {
      *
      * @return The boardState is manipulated and returned
 	 */
-	@Override
+	
 	protected HearthTreeNode use_core(
 			PlayerSide side,
 			Minion targetMinion,
diff --git a/src/main/java/com/hearthsim/card/spellcard/concrete/MarkOfTheWild.java b/src/main/java/com/hearthsim/card/spellcard/concrete/MarkOfTheWild.java
index ebaa795..84bf3cd 100644
--- a/src/main/java/com/hearthsim/card/spellcard/concrete/MarkOfTheWild.java
+++ b/src/main/java/com/hearthsim/card/spellcard/concrete/MarkOfTheWild.java
@@ -28,7 +28,7 @@ public class MarkOfTheWild extends SpellCard {
 		this(false);
 	}
 
-	@Override
+	
 	public Object deepCopy() {
 		return new MarkOfTheWild(this.hasBeenUsed);
 	}
@@ -46,7 +46,7 @@ public class MarkOfTheWild extends SpellCard {
      *
      * @return The boardState is manipulated and returned
 	 */
-	@Override
+	
 	protected HearthTreeNode use_core(
 			PlayerSide side,
 			Minion targetMinion,
diff --git a/src/main/java/com/hearthsim/card/spellcard/concrete/MindBlast.java b/src/main/java/com/hearthsim/card/spellcard/concrete/MindBlast.java
index f63a65d..802157a 100644
--- a/src/main/java/com/hearthsim/card/spellcard/concrete/MindBlast.java
+++ b/src/main/java/com/hearthsim/card/spellcard/concrete/MindBlast.java
@@ -17,7 +17,7 @@ public class MindBlast extends SpellDamage {
 		super((byte)2, (byte)5, hasBeenUsed);
 	}
 
-	@Override
+	
 	public Object deepCopy() {
 		return new MindBlast(this.hasBeenUsed);
 	}
@@ -35,7 +35,7 @@ public class MindBlast extends SpellDamage {
      *
      * @return The boardState is manipulated and returned
 	 */
-	@Override
+	
 	protected HearthTreeNode use_core(
 			PlayerSide side,
 			Minion targetMinion,
diff --git a/src/main/java/com/hearthsim/card/spellcard/concrete/MindControl.java b/src/main/java/com/hearthsim/card/spellcard/concrete/MindControl.java
index 1e9d973..f603376 100644
--- a/src/main/java/com/hearthsim/card/spellcard/concrete/MindControl.java
+++ b/src/main/java/com/hearthsim/card/spellcard/concrete/MindControl.java
@@ -27,7 +27,7 @@ public class MindControl extends SpellCard {
 		this(false);
 	}
 
-	@Override
+	
 	public Object deepCopy() {
 		return new MindControl(this.hasBeenUsed);
 	}
@@ -45,7 +45,7 @@ public class MindControl extends SpellCard {
      *
      * @return The boardState is manipulated and returned
 	 */
-	@Override
+	
 	protected HearthTreeNode use_core(
 			PlayerSide side,
 			Minion targetMinion,
diff --git a/src/main/java/com/hearthsim/card/spellcard/concrete/MirrorImage.java b/src/main/java/com/hearthsim/card/spellcard/concrete/MirrorImage.java
index a866020..1dc5193 100644
--- a/src/main/java/com/hearthsim/card/spellcard/concrete/MirrorImage.java
+++ b/src/main/java/com/hearthsim/card/spellcard/concrete/MirrorImage.java
@@ -4,6 +4,7 @@ import com.hearthsim.card.Deck;
 import com.hearthsim.card.minion.Minion;
 import com.hearthsim.card.minion.concrete.MirrorImageMinion;
 import com.hearthsim.card.spellcard.SpellCard;
+import com.hearthsim.entity.BaseEntity;
 import com.hearthsim.exception.HSException;
 import com.hearthsim.model.PlayerSide;
 import com.hearthsim.util.tree.HearthTreeNode;
@@ -29,7 +30,7 @@ public class MirrorImage extends SpellCard {
 		this(false);
 	}
 
-	@Override
+	
 	public Object deepCopy() {
 		return new MirrorImage(this.hasBeenUsed);
 	}
@@ -47,7 +48,7 @@ public class MirrorImage extends SpellCard {
      *
      * @return The boardState is manipulated and returned
 	 */
-	@Override
+	
 	protected HearthTreeNode use_core(
 			PlayerSide side,
 			Minion targetMinion,
@@ -68,12 +69,12 @@ public class MirrorImage extends SpellCard {
 		HearthTreeNode toRet = super.use_core(side, targetMinion, boardState, deckPlayer0, deckPlayer1, singleRealizationOnly);
 		if (toRet != null) {
 			Minion mi0 = new MirrorImageMinion();
-			Minion placementTarget = toRet.data_.getCharacter(PlayerSide.CURRENT_PLAYER, numMinions);
+			BaseEntity placementTarget = toRet.data_.getCharacter(PlayerSide.CURRENT_PLAYER, numMinions);
 			toRet = mi0.summonMinion(side, placementTarget, toRet, deckPlayer0, deckPlayer1, false);
 			
 			if (numMinions < 6) {
 				Minion mi1 = new MirrorImageMinion();
-				Minion placementTarget2 = toRet.data_.getCharacter(PlayerSide.CURRENT_PLAYER, numMinions + 1);
+				BaseEntity placementTarget2 = toRet.data_.getCharacter(PlayerSide.CURRENT_PLAYER, numMinions + 1);
 				toRet = mi1.summonMinion(side, placementTarget2, toRet, deckPlayer0, deckPlayer1, false);
 			}
 		}		
diff --git a/src/main/java/com/hearthsim/card/spellcard/concrete/Moonfire.java b/src/main/java/com/hearthsim/card/spellcard/concrete/Moonfire.java
index b54ad15..b5f3f7c 100644
--- a/src/main/java/com/hearthsim/card/spellcard/concrete/Moonfire.java
+++ b/src/main/java/com/hearthsim/card/spellcard/concrete/Moonfire.java
@@ -12,7 +12,7 @@ public class Moonfire extends SpellDamage {
 		super((byte)0, (byte)1, hasBeenUsed);
 	}
 
-	@Override
+	
 	public Object deepCopy() {
 		return new Moonfire(this.hasBeenUsed);
 	}
diff --git a/src/main/java/com/hearthsim/card/spellcard/concrete/MortalCoil.java b/src/main/java/com/hearthsim/card/spellcard/concrete/MortalCoil.java
index 3d4b07a..b8c0d12 100644
--- a/src/main/java/com/hearthsim/card/spellcard/concrete/MortalCoil.java
+++ b/src/main/java/com/hearthsim/card/spellcard/concrete/MortalCoil.java
@@ -18,7 +18,7 @@ public class MortalCoil extends SpellDamage {
 		super((byte)1, (byte)1, hasBeenUsed);
 	}
 
-	@Override
+	
 	public Object deepCopy() {
 		return new MortalCoil(this.hasBeenUsed);
 	}
@@ -36,7 +36,7 @@ public class MortalCoil extends SpellDamage {
      *
      * @return The boardState is manipulated and returned
 	 */
-	@Override
+	
 	protected HearthTreeNode use_core(
 			PlayerSide side,
 			Minion targetMinion,
diff --git a/src/main/java/com/hearthsim/card/spellcard/concrete/Polymorph.java b/src/main/java/com/hearthsim/card/spellcard/concrete/Polymorph.java
index 7d25ea8..560f7e7 100644
--- a/src/main/java/com/hearthsim/card/spellcard/concrete/Polymorph.java
+++ b/src/main/java/com/hearthsim/card/spellcard/concrete/Polymorph.java
@@ -28,7 +28,7 @@ public class Polymorph extends SpellCard {
 		this(false);
 	}
 	
-	@Override
+	
 	public Object deepCopy() {
 		return new Polymorph(this.hasBeenUsed);
 	}
@@ -46,7 +46,7 @@ public class Polymorph extends SpellCard {
      *
      * @return The boardState is manipulated and returned
 	 */
-	@Override
+	
 	protected HearthTreeNode use_core(
 			PlayerSide side,
 			Minion targetMinion,
diff --git a/src/main/java/com/hearthsim/card/spellcard/concrete/PowerWordShield.java b/src/main/java/com/hearthsim/card/spellcard/concrete/PowerWordShield.java
index 388cc71..401d3af 100644
--- a/src/main/java/com/hearthsim/card/spellcard/concrete/PowerWordShield.java
+++ b/src/main/java/com/hearthsim/card/spellcard/concrete/PowerWordShield.java
@@ -28,7 +28,7 @@ public class PowerWordShield extends SpellCard {
 		this(false);
 	}
 
-	@Override
+	
 	public Object deepCopy() {
 		return new PowerWordShield(this.hasBeenUsed);
 	}
@@ -46,7 +46,7 @@ public class PowerWordShield extends SpellCard {
      *
      * @return The boardState is manipulated and returned
 	 */
-	@Override
+	
 	protected HearthTreeNode use_core(
 			PlayerSide side,
 			Minion targetMinion,
diff --git a/src/main/java/com/hearthsim/card/spellcard/concrete/Pyroblast.java b/src/main/java/com/hearthsim/card/spellcard/concrete/Pyroblast.java
index c524066..62d3022 100644
--- a/src/main/java/com/hearthsim/card/spellcard/concrete/Pyroblast.java
+++ b/src/main/java/com/hearthsim/card/spellcard/concrete/Pyroblast.java
@@ -12,7 +12,7 @@ public class Pyroblast extends SpellDamage {
 		super((byte)10, (byte)10, hasBeenUsed);
 	}
 	
-	@Override
+	
 	public Object deepCopy() {
 		return new Pyroblast(this.hasBeenUsed);
 	}
diff --git a/src/main/java/com/hearthsim/card/spellcard/concrete/RockbiterWeapon.java b/src/main/java/com/hearthsim/card/spellcard/concrete/RockbiterWeapon.java
index 17b4a81..38a9c4f 100644
--- a/src/main/java/com/hearthsim/card/spellcard/concrete/RockbiterWeapon.java
+++ b/src/main/java/com/hearthsim/card/spellcard/concrete/RockbiterWeapon.java
@@ -27,7 +27,7 @@ public class RockbiterWeapon extends SpellCard {
 		this(false);
 	}
 
-	@Override
+	
 	public Object deepCopy() {
 		return new RockbiterWeapon(this.hasBeenUsed);
 	}
@@ -45,7 +45,7 @@ public class RockbiterWeapon extends SpellCard {
      *
      * @return The boardState is manipulated and returned
 	 */
-	@Override
+	
 	protected HearthTreeNode use_core(
 			PlayerSide side,
 			Minion targetMinion,
diff --git a/src/main/java/com/hearthsim/card/spellcard/concrete/SacrificialPact.java b/src/main/java/com/hearthsim/card/spellcard/concrete/SacrificialPact.java
index d9ef55d..8aa4600 100644
--- a/src/main/java/com/hearthsim/card/spellcard/concrete/SacrificialPact.java
+++ b/src/main/java/com/hearthsim/card/spellcard/concrete/SacrificialPact.java
@@ -28,7 +28,7 @@ public class SacrificialPact extends SpellCard {
 		this(false);
 	}
 
-	@Override
+	
 	public Object deepCopy() {
 		return new SacrificialPact(this.hasBeenUsed);
 	}
@@ -46,7 +46,7 @@ public class SacrificialPact extends SpellCard {
      *
      * @return The boardState is manipulated and returned
 	 */
-	@Override
+	
 	protected HearthTreeNode use_core(
 			PlayerSide side,
 			Minion targetMinion,
diff --git a/src/main/java/com/hearthsim/card/spellcard/concrete/Sap.java b/src/main/java/com/hearthsim/card/spellcard/concrete/Sap.java
index 8a07809..0b47b2f 100644
--- a/src/main/java/com/hearthsim/card/spellcard/concrete/Sap.java
+++ b/src/main/java/com/hearthsim/card/spellcard/concrete/Sap.java
@@ -32,7 +32,7 @@ public class Sap extends SpellCard {
 		this(false);
 	}
 
-	@Override
+	
 	public Object deepCopy() {
 		return new Sap(this.hasBeenUsed);
 	}
@@ -50,7 +50,7 @@ public class Sap extends SpellCard {
      *
      * @return The boardState is manipulated and returned
 	 */
-	@Override
+	
 	protected HearthTreeNode use_core(
 			PlayerSide side,
 			Minion targetMinion,
diff --git a/src/main/java/com/hearthsim/card/spellcard/concrete/SavageRoar.java b/src/main/java/com/hearthsim/card/spellcard/concrete/SavageRoar.java
index d0f4533..512b33b 100644
--- a/src/main/java/com/hearthsim/card/spellcard/concrete/SavageRoar.java
+++ b/src/main/java/com/hearthsim/card/spellcard/concrete/SavageRoar.java
@@ -29,7 +29,7 @@ public class SavageRoar extends SpellCard {
 		this(false);
 	}
 
-	@Override
+	
 	public Object deepCopy() {
 		return new SavageRoar(this.hasBeenUsed);
 	}
@@ -47,7 +47,7 @@ public class SavageRoar extends SpellCard {
      *
      * @return The boardState is manipulated and returned
 	 */
-	@Override
+	
 	protected HearthTreeNode use_core(
 			PlayerSide side,
 			Minion targetMinion,
diff --git a/src/main/java/com/hearthsim/card/spellcard/concrete/ShadowBolt.java b/src/main/java/com/hearthsim/card/spellcard/concrete/ShadowBolt.java
index 614f93b..fb635ec 100644
--- a/src/main/java/com/hearthsim/card/spellcard/concrete/ShadowBolt.java
+++ b/src/main/java/com/hearthsim/card/spellcard/concrete/ShadowBolt.java
@@ -17,7 +17,7 @@ public class ShadowBolt extends SpellDamage {
 		super((byte)3, (byte)4, hasBeenUsed);
 	}
 	
-	@Override
+	
 	public Object deepCopy() {
 		return new ShadowBolt(this.hasBeenUsed);
 	}
@@ -36,7 +36,7 @@ public class ShadowBolt extends SpellDamage {
      *
      * @return The boardState is manipulated and returned
 	 */
-	@Override
+	
 	protected HearthTreeNode use_core(
 			PlayerSide side,
 			Minion targetMinion,
diff --git a/src/main/java/com/hearthsim/card/spellcard/concrete/ShadowWordDeath.java b/src/main/java/com/hearthsim/card/spellcard/concrete/ShadowWordDeath.java
index ad4990c..25f93c6 100644
--- a/src/main/java/com/hearthsim/card/spellcard/concrete/ShadowWordDeath.java
+++ b/src/main/java/com/hearthsim/card/spellcard/concrete/ShadowWordDeath.java
@@ -27,7 +27,7 @@ public class ShadowWordDeath extends SpellCard {
 		this(false);
 	}
 
-	@Override
+	
 	public Object deepCopy() {
 		return new ShadowWordDeath(this.hasBeenUsed);
 	}
@@ -45,7 +45,7 @@ public class ShadowWordDeath extends SpellCard {
      *
      * @return The boardState is manipulated and returned
 	 */
-	@Override
+	
 	protected HearthTreeNode use_core(
 			PlayerSide side,
 			Minion targetMinion,
diff --git a/src/main/java/com/hearthsim/card/spellcard/concrete/ShadowWordPain.java b/src/main/java/com/hearthsim/card/spellcard/concrete/ShadowWordPain.java
index 4986e95..89bb2e2 100644
--- a/src/main/java/com/hearthsim/card/spellcard/concrete/ShadowWordPain.java
+++ b/src/main/java/com/hearthsim/card/spellcard/concrete/ShadowWordPain.java
@@ -27,7 +27,7 @@ public class ShadowWordPain extends SpellCard {
 		this(false);
 	}
 
-	@Override
+	
 	public Object deepCopy() {
 		return new ShadowWordPain(this.hasBeenUsed);
 	}
@@ -45,7 +45,7 @@ public class ShadowWordPain extends SpellCard {
      *
      * @return The boardState is manipulated and returned
 	 */
-	@Override
+	
 	protected HearthTreeNode use_core(
 			PlayerSide side,
 			Minion targetMinion,
diff --git a/src/main/java/com/hearthsim/card/spellcard/concrete/ShieldBlock.java b/src/main/java/com/hearthsim/card/spellcard/concrete/ShieldBlock.java
index d939fa2..25f6bff 100644
--- a/src/main/java/com/hearthsim/card/spellcard/concrete/ShieldBlock.java
+++ b/src/main/java/com/hearthsim/card/spellcard/concrete/ShieldBlock.java
@@ -29,7 +29,7 @@ public class ShieldBlock extends SpellCard {
 		this(false);
 	}
 
-	@Override
+	
 	public Object deepCopy() {
 		return new ShieldBlock(this.hasBeenUsed);
 	}
@@ -47,7 +47,7 @@ public class ShieldBlock extends SpellCard {
      *
      * @return The boardState is manipulated and returned
 	 */
-	@Override
+	
 	protected HearthTreeNode use_core(
 			PlayerSide side,
 			Minion targetMinion,
diff --git a/src/main/java/com/hearthsim/card/spellcard/concrete/Shiv.java b/src/main/java/com/hearthsim/card/spellcard/concrete/Shiv.java
index f47a550..a72ce79 100644
--- a/src/main/java/com/hearthsim/card/spellcard/concrete/Shiv.java
+++ b/src/main/java/com/hearthsim/card/spellcard/concrete/Shiv.java
@@ -19,7 +19,7 @@ public class Shiv extends SpellDamage {
 		super((byte)2, (byte)1, hasBeenUsed);
 	}
 
-	@Override
+	
 	public Object deepCopy() {
 		return new Shiv(this.hasBeenUsed);
 	}
@@ -37,7 +37,7 @@ public class Shiv extends SpellDamage {
      *
      * @return The boardState is manipulated and returned
 	 */
-	@Override
+	
 	protected HearthTreeNode use_core(
 			PlayerSide side,
 			Minion targetMinion,
diff --git a/src/main/java/com/hearthsim/card/spellcard/concrete/Silence.java b/src/main/java/com/hearthsim/card/spellcard/concrete/Silence.java
index 3bdefdc..3956f2a 100644
--- a/src/main/java/com/hearthsim/card/spellcard/concrete/Silence.java
+++ b/src/main/java/com/hearthsim/card/spellcard/concrete/Silence.java
@@ -18,7 +18,7 @@ public class Silence extends SpellCard {
 		super((byte)0, hasBeenUsed);
 	}
 
-	@Override
+	
 	public Object deepCopy() {
 		return new Silence(this.hasBeenUsed);
 	}
@@ -36,7 +36,7 @@ public class Silence extends SpellCard {
      *
      * @return The boardState is manipulated and returned
 	 */
-	@Override
+	
 	protected HearthTreeNode use_core(
 			PlayerSide side,
 			Minion targetMinion,
diff --git a/src/main/java/com/hearthsim/card/spellcard/concrete/SinisterStrike.java b/src/main/java/com/hearthsim/card/spellcard/concrete/SinisterStrike.java
index 4757c36..dfa13bb 100644
--- a/src/main/java/com/hearthsim/card/spellcard/concrete/SinisterStrike.java
+++ b/src/main/java/com/hearthsim/card/spellcard/concrete/SinisterStrike.java
@@ -17,7 +17,7 @@ public class SinisterStrike extends SpellDamage {
 		super((byte)1, (byte)3, hasBeenUsed);
 	}
 
-	@Override
+	
 	public Object deepCopy() {
 		return new 	SinisterStrike(this.hasBeenUsed);
 	}
@@ -35,7 +35,7 @@ public class SinisterStrike extends SpellDamage {
      *
      * @return The boardState is manipulated and returned
 	 */
-	@Override
+	
 	protected HearthTreeNode use_core(
 			PlayerSide side,
 			Minion targetMinion,
diff --git a/src/main/java/com/hearthsim/card/spellcard/concrete/Slam.java b/src/main/java/com/hearthsim/card/spellcard/concrete/Slam.java
index 103a2c4..80a08b5 100644
--- a/src/main/java/com/hearthsim/card/spellcard/concrete/Slam.java
+++ b/src/main/java/com/hearthsim/card/spellcard/concrete/Slam.java
@@ -18,7 +18,7 @@ public class Slam extends SpellDamage {
 		super((byte)2, (byte)2, hasBeenUsed);
 	}
 
-	@Override
+	
 	public Object deepCopy() {
 		return new Slam(this.hasBeenUsed);
 	}
@@ -36,7 +36,7 @@ public class Slam extends SpellDamage {
      *
      * @return The boardState is manipulated and returned
 	 */
-	@Override
+	
 	protected HearthTreeNode use_core(
 			PlayerSide side,
 			Minion targetMinion,
diff --git a/src/main/java/com/hearthsim/card/spellcard/concrete/Sprint.java b/src/main/java/com/hearthsim/card/spellcard/concrete/Sprint.java
index 96d047e..167d7dc 100644
--- a/src/main/java/com/hearthsim/card/spellcard/concrete/Sprint.java
+++ b/src/main/java/com/hearthsim/card/spellcard/concrete/Sprint.java
@@ -29,7 +29,7 @@ public class Sprint extends SpellCard {
 		this(false);
 	}
 
-	@Override
+	
 	public Object deepCopy() {
 		return new Sprint(this.hasBeenUsed);
 	}
@@ -47,7 +47,7 @@ public class Sprint extends SpellCard {
      *
      * @return The boardState is manipulated and returned
 	 */
-	@Override
+	
 	protected HearthTreeNode use_core(
 			PlayerSide side,
 			Minion targetMinion,
diff --git a/src/main/java/com/hearthsim/card/spellcard/concrete/Starfire.java b/src/main/java/com/hearthsim/card/spellcard/concrete/Starfire.java
index f0bde89..63089a8 100644
--- a/src/main/java/com/hearthsim/card/spellcard/concrete/Starfire.java
+++ b/src/main/java/com/hearthsim/card/spellcard/concrete/Starfire.java
@@ -19,7 +19,7 @@ public class Starfire extends SpellDamage {
 		super((byte)6, (byte)5, hasBeenUsed);
 	}
 
-	@Override
+	
 	public Object deepCopy() {
 		return new Starfire(this.hasBeenUsed);
 	}
@@ -37,7 +37,7 @@ public class Starfire extends SpellDamage {
      *
      * @return The boardState is manipulated and returned
 	 */
-	@Override
+	
 	protected HearthTreeNode use_core(
 			PlayerSide side,
 			Minion targetMinion,
diff --git a/src/main/java/com/hearthsim/card/spellcard/concrete/Swipe.java b/src/main/java/com/hearthsim/card/spellcard/concrete/Swipe.java
index 56433d7..25661a0 100644
--- a/src/main/java/com/hearthsim/card/spellcard/concrete/Swipe.java
+++ b/src/main/java/com/hearthsim/card/spellcard/concrete/Swipe.java
@@ -28,7 +28,7 @@ public class Swipe extends SpellCard {
 		this(false);
 	}
 
-	@Override
+	
 	public Object deepCopy() {
 		return new Swipe(this.hasBeenUsed);
 	}
@@ -46,7 +46,7 @@ public class Swipe extends SpellCard {
      *
      * @return The boardState is manipulated and returned
 	 */
-	@Override
+	
 	protected HearthTreeNode use_core(
 			PlayerSide side,
 			Minion targetMinion,
diff --git a/src/main/java/com/hearthsim/card/spellcard/concrete/TheCoin.java b/src/main/java/com/hearthsim/card/spellcard/concrete/TheCoin.java
index 30dc963..2269543 100644
--- a/src/main/java/com/hearthsim/card/spellcard/concrete/TheCoin.java
+++ b/src/main/java/com/hearthsim/card/spellcard/concrete/TheCoin.java
@@ -19,12 +19,12 @@ public class TheCoin extends SpellCard {
 		this(false);
 	}
 
-	@Override
+	
 	public Object deepCopy() {
 		return new TheCoin(this.hasBeenUsed());
 	}
 
-	@Override
+	
     public boolean canBeUsedOn(PlayerSide playerSide, Minion minion, BoardModel boardModel) {
         return !(isWaitingPlayer(playerSide) || isNotHero(minion));
     }
@@ -40,7 +40,7 @@ public class TheCoin extends SpellCard {
      *
      * @return The boardState is manipulated and returned
 	 */
-	@Override
+	
 	protected HearthTreeNode use_core(
 			PlayerSide side,
 			Minion targetMinion,
diff --git a/src/main/java/com/hearthsim/card/spellcard/concrete/TotemicMight.java b/src/main/java/com/hearthsim/card/spellcard/concrete/TotemicMight.java
index 4bf84b4..63cda57 100644
--- a/src/main/java/com/hearthsim/card/spellcard/concrete/TotemicMight.java
+++ b/src/main/java/com/hearthsim/card/spellcard/concrete/TotemicMight.java
@@ -28,7 +28,7 @@ public class TotemicMight extends SpellCard {
 		this(false);
 	}
 
-	@Override
+	
 	public Object deepCopy() {
 		return new TotemicMight(this.hasBeenUsed);
 	}
@@ -46,7 +46,7 @@ public class TotemicMight extends SpellCard {
      *
      * @return The boardState is manipulated and returned
 	 */
-	@Override
+	
 	protected HearthTreeNode use_core(
 			PlayerSide side,
 			Minion targetMinion,
diff --git a/src/main/java/com/hearthsim/card/spellcard/concrete/Whirlwind.java b/src/main/java/com/hearthsim/card/spellcard/concrete/Whirlwind.java
index d830ff3..178073e 100644
--- a/src/main/java/com/hearthsim/card/spellcard/concrete/Whirlwind.java
+++ b/src/main/java/com/hearthsim/card/spellcard/concrete/Whirlwind.java
@@ -29,7 +29,7 @@ public class Whirlwind extends SpellCard {
 		this(false);
 	}
 	
-	@Override
+	
 	public Object deepCopy() {
 		return new Whirlwind(this.hasBeenUsed);
 	}
@@ -47,7 +47,7 @@ public class Whirlwind extends SpellCard {
      *
      * @return The boardState is manipulated and returned
 	 */
-	@Override
+	
 	protected HearthTreeNode use_core(
 			PlayerSide side,
 			Minion targetMinion,
diff --git a/src/main/java/com/hearthsim/card/spellcard/concrete/WildGrowth.java b/src/main/java/com/hearthsim/card/spellcard/concrete/WildGrowth.java
index f5f1deb..6dd2767 100644
--- a/src/main/java/com/hearthsim/card/spellcard/concrete/WildGrowth.java
+++ b/src/main/java/com/hearthsim/card/spellcard/concrete/WildGrowth.java
@@ -28,7 +28,7 @@ public class WildGrowth extends SpellCard {
 		this(false);
 	}
 
-	@Override
+	
 	public Object deepCopy() {
 		return new WildGrowth(this.hasBeenUsed);
 	}
@@ -47,7 +47,7 @@ public class WildGrowth extends SpellCard {
      *
      * @return The boardState is manipulated and returned
 	 */
-	@Override
+	
 	protected HearthTreeNode use_core(
 			PlayerSide side,
 			Minion targetMinion,
diff --git a/src/main/java/com/hearthsim/card/spellcard/concrete/Windfury.java b/src/main/java/com/hearthsim/card/spellcard/concrete/Windfury.java
index e1dc3a6..50d290a 100644
--- a/src/main/java/com/hearthsim/card/spellcard/concrete/Windfury.java
+++ b/src/main/java/com/hearthsim/card/spellcard/concrete/Windfury.java
@@ -27,7 +27,7 @@ public class Windfury extends SpellCard {
 		this(false);
 	}
 
-	@Override
+	
 	public Object deepCopy() {
 		return new Windfury(this.hasBeenUsed);
 	}
@@ -45,7 +45,7 @@ public class Windfury extends SpellCard {
      *
      * @return The boardState is manipulated and returned
 	 */
-	@Override
+	
 	protected HearthTreeNode use_core(
 			PlayerSide side,
 			Minion targetMinion,
diff --git a/src/main/java/com/hearthsim/entity/BaseEntity.java b/src/main/java/com/hearthsim/entity/BaseEntity.java
index f6eb13f..4532fb4 100644
--- a/src/main/java/com/hearthsim/entity/BaseEntity.java
+++ b/src/main/java/com/hearthsim/entity/BaseEntity.java
@@ -1,11 +1,26 @@
 package com.hearthsim.entity;
 
+import java.util.EnumSet;
+import java.util.Iterator;
+
+import org.json.JSONObject;
+
 import com.hearthsim.card.Card;
 import com.hearthsim.card.Deck;
 import com.hearthsim.card.ImplementedCardList;
+import com.hearthsim.card.minion.Beast;
+import com.hearthsim.card.minion.Hero;
+import com.hearthsim.card.minion.Minion;
+import com.hearthsim.card.minion.Murloc;
+import com.hearthsim.card.minion.Minion.BattlecryTargetType;
+import com.hearthsim.event.attack.AttackAction;
+import com.hearthsim.event.deathrattle.DeathrattleAction;
 import com.hearthsim.exception.HSException;
+import com.hearthsim.exception.HSInvalidPlayerIndexException;
+import com.hearthsim.model.BoardModel;
 import com.hearthsim.model.PlayerSide;
 import com.hearthsim.util.DeepCopyable;
+import com.hearthsim.util.factory.BoardStateFactoryBase;
 import com.hearthsim.util.tree.HearthTreeNode;
 
 public abstract class BaseEntity extends Card implements DeepCopyable
@@ -13,6 +28,351 @@ public abstract class BaseEntity extends Card implements DeepCopyable
 	protected byte health_;
 	protected byte attack_;
 	
+	//Both hero and minion have this
+	protected boolean windFury_;
+	protected boolean hasAttacked_;
+	protected boolean hasWindFuryAttacked_;
+	protected boolean frozen_;
+	
+	//Might sort out minion/hero exclusive attributes if I have time
+	protected boolean taunt_;
+	protected boolean divineShield_;
+	protected boolean charge_;
+	
+	protected boolean silenced_;
+	protected boolean stealthed_;
+	protected boolean heroTargetable_;
+	
+	protected byte maxHealth_;
+	protected byte baseHealth_;
+	protected byte auraHealth_;
+
+	protected byte baseAttack_;
+	protected byte extraAttackUntilTurnEnd_;
+	protected byte auraAttack_;
+	
+	protected boolean summoned_;
+	protected boolean transformed_;
+	
+	protected boolean destroyOnTurnStart_;
+	protected boolean destroyOnTurnEnd_;
+
+	protected byte spellDamage_;
+
+	protected DeathrattleAction deathrattleAction_;
+	protected AttackAction attackAction_;
+	protected boolean placementImportant_ = false;
+	
+	public BaseEntity(String name, byte mana, byte attack, byte health, byte baseAttack, byte baseHealth, byte maxHealth) {
+		this(
+				name,
+				mana,
+				attack,
+				health,
+				baseAttack,
+				(byte)0,
+				(byte)0,
+				baseHealth,
+				maxHealth,
+				(byte)0,
+				(byte)0,
+				false,
+				false,
+				false,
+				false,
+				false,
+				false,
+				false,
+				false,
+				false,
+				true,
+				false,
+				false,
+				false,
+				false,
+				null,
+				null,
+				true,
+				false);
+	}
+
+	public BaseEntity(	String name,
+					byte mana,
+					byte attack,
+					byte health,
+					byte baseAttack,
+					byte extraAttackUntilTurnEnd,
+					byte auraAttack,
+					byte baseHealth,
+					byte maxHealth,
+					byte auraHealth,
+					byte spellDamage,
+					boolean taunt,
+					boolean divineShield,
+					boolean windFury,
+					boolean charge,
+					boolean hasAttacked,
+					boolean hasWindFuryAttacked,
+					boolean frozen,
+					boolean silenced,
+					boolean stealthed,
+					boolean heroTargetable,
+					boolean summoned,
+					boolean transformed,
+					boolean destroyOnTurnStart,
+					boolean destroyOnTurnEnd,
+					DeathrattleAction deathrattleAction,
+					AttackAction attackAction,
+					boolean isInHand,
+					boolean hasBeenUsed) {
+		super(name, mana, hasBeenUsed, isInHand);
+		attack_ = attack;
+		health_ = health;
+		taunt_ = taunt;
+		divineShield_ = divineShield;
+		windFury_ = windFury;
+		charge_ = charge;
+		hasAttacked_ = hasAttacked;
+		baseAttack_ = baseAttack;
+		extraAttackUntilTurnEnd_ = extraAttackUntilTurnEnd;
+		hasWindFuryAttacked_ = hasWindFuryAttacked;
+		frozen_ = frozen;
+		silenced_ = silenced;
+		baseHealth_ = baseHealth;
+		maxHealth_ = maxHealth;
+		summoned_ = summoned;
+		transformed_ = transformed;
+		destroyOnTurnStart_ = destroyOnTurnStart;
+		destroyOnTurnEnd_ = destroyOnTurnEnd;
+		deathrattleAction_ = deathrattleAction;
+		attackAction_ = attackAction;
+
+		auraAttack_ = auraAttack;
+		auraHealth_ = auraHealth;
+
+		spellDamage_ = spellDamage;
+
+		stealthed_ = stealthed;
+		heroTargetable_ = heroTargetable;
+	}	
+	
+	public boolean getTaunt() {
+		return taunt_;
+	}
+	
+	public void setTaunt(boolean taunt) {
+		taunt_ = taunt;
+	}
+	
+	public byte getHealth() {
+		return health_;
+	}
+	
+	public void setHealth(byte health) {
+		health_ = health;
+	}
+	
+	public void addHealth(byte value) {
+		health_ += value;
+	}
+	
+	public byte getMaxHealth() {
+		return maxHealth_;
+	}
+	
+	public void setMaxHealth(byte health) {
+		maxHealth_ = health;
+	}
+	
+	public void addMaxHealth(byte value) {
+		maxHealth_ += value;
+	}
+	
+	public byte getBaseHealth() {
+		return baseHealth_;
+	}
+	
+	public void setBaseHealth(byte health) {
+		baseHealth_ = health;
+	}
+	
+	public byte getAttack() {
+		return attack_;
+	}
+	
+	public void setAttack(byte attack) {
+		attack_ = attack;
+	}
+	
+	public void addAttack(byte value) {
+		attack_ += value;
+	}
+	
+	public boolean getDivineShield() {
+		return divineShield_;
+	}
+	
+	public void setDivineShield(boolean divineShield) {
+		divineShield_ = divineShield;
+	}
+	
+	public boolean hasAttacked() {
+		return hasAttacked_;
+	}
+	
+	public void hasAttacked(boolean hasAttacked) {
+		hasAttacked_ = hasAttacked;
+	}
+
+	public boolean hasWindFuryAttacked() {
+		return hasWindFuryAttacked_;
+	}
+	
+	public void hasWindFuryAttacked(boolean hasAttacked) {
+		hasWindFuryAttacked_ = hasAttacked;
+	}
+
+	public boolean getCharge() {
+		return charge_;
+	}
+	
+	public void setCharge(boolean value) {
+		charge_ = value;
+	}
+	
+	public boolean getFrozen() {
+		return frozen_;
+	}
+	
+	public void setFrozen(boolean value) {
+		frozen_ = value;
+	}
+	
+	public boolean getWindfury() {
+		return windFury_;
+	}
+	
+	public void setWindfury(boolean value) {
+		windFury_ = value;
+	}
+	
+	public boolean getSummoned() {
+		return summoned_;
+	}
+	
+	public void setSummoned(boolean value) {
+		summoned_ = value;
+	}
+	
+	public boolean getTransformed() {
+		return transformed_;
+	}
+	
+	public void setTransformed(boolean value) {
+		transformed_ = value;
+	}
+	
+	public byte getExtraAttackUntilTurnEnd() {
+		return extraAttackUntilTurnEnd_;
+	}
+	
+	public void setExtraAttackUntilTurnEnd(byte value) {
+		extraAttackUntilTurnEnd_ = value;
+	}
+	
+	public boolean getDestroyOnTurnStart() {
+		return destroyOnTurnStart_;
+	}
+	
+	public void setDestroyOnTurnStart(boolean value) {
+		destroyOnTurnStart_ = value;
+	}
+
+	public boolean getDestroyOnTurnEnd() {
+		return destroyOnTurnEnd_;
+	}
+	
+	public void setDestroyOnTurnEnd(boolean value) {
+		destroyOnTurnEnd_ = value;
+	}
+	
+	public boolean isSilenced() {
+		return silenced_;
+	}
+	
+	public boolean hasDeathrattle() {
+		return deathrattleAction_ != null;
+	}
+
+	public void setDeathrattle(DeathrattleAction action) {
+		deathrattleAction_ = action;
+	}
+	
+	public byte getAuraAttack() {
+		return auraAttack_;
+	}
+
+	public void setAuraAttack(byte value) {
+		auraAttack_ = value;
+	}
+
+	public byte getAuraHealth() {
+		return auraHealth_;
+	}
+
+	public void setAuraHealth(byte value) {
+		auraHealth_ = value;
+	}
+
+	public byte getTotalAttack() {
+		return (byte)(attack_ + auraAttack_ + extraAttackUntilTurnEnd_);
+	}
+	
+	public byte getTotalHealth() {
+		return (byte)(health_ + auraHealth_);
+	}
+	
+	public byte getTotalMaxHealth() {
+		return (byte)(maxHealth_ + auraHealth_);
+	}
+
+	
+	public void addAuraHealth(byte value) {
+		auraHealth_ += value;
+	}
+	
+	public void removeAuraHealth(byte value) {
+		health_ += value;
+		if (health_ > maxHealth_)
+			health_ = maxHealth_;
+		auraHealth_ -= value;
+	}
+	
+	public boolean getStealthed() {
+		return stealthed_;
+	}
+	
+	public void setStealthed(boolean value) {
+		stealthed_ = value;
+	}
+	
+	public boolean getPlacementImportant() {
+		return placementImportant_;
+	}
+	
+	public void setPlacementImportant(boolean value) {
+		placementImportant_ = value;
+	}
+	
+	public boolean isHeroTargetable() {
+		return heroTargetable_;
+	}
+	
+	public void setHeroTargetable(boolean value) {
+		heroTargetable_ = value;
+	}
+	
+	
 	// Empty placeholder constructor
 	public BaseEntity()
 	{
@@ -29,8 +389,106 @@ public abstract class BaseEntity extends Card implements DeepCopyable
 	{
 		super(name,mana,hasBeenUsed,isInHand);
 	}
+
+	public HearthTreeNode attack(
+			PlayerSide targetMinionPlayerSide,
+			BaseEntity targetMinion,
+			HearthTreeNode boardState,
+			Deck deckPlayer0,
+			Deck deckPlayer1)
+		throws HSException
+	{
+		
+		//can't attack a stealthed target
+		if (targetMinion.getStealthed())
+			return null;
+		
+		if (frozen_) {
+			this.hasAttacked_ = true;
+			this.frozen_ = false;
+			return boardState;
+		}
+		
+		//Notify all that an attack is beginning
+		HearthTreeNode toRet = boardState;
+		if (toRet != null) {
+			//Notify all that a minion is created
+			toRet = toRet.data_.getCurrentPlayerHero().minionAttackingEvent(toRet);
+            for (Minion entity : PlayerSide.CURRENT_PLAYER.getPlayer(toRet).getMinions()) {
+                if (!entity.isSilenced())
+                    toRet = entity.minionAttackingEvent(toRet);
+            }
+			toRet = toRet.data_.getWaitingPlayerHero().minionAttackingEvent(toRet);
+            for (Minion entity : PlayerSide.WAITING_PLAYER.getPlayer(toRet).getMinions()) {
+                if (!entity.isSilenced())
+                    toRet = entity.minionAttackingEvent(toRet);
+            }
+		}
+		
+		//Do the actual attack
+		toRet = this.attack_core(targetMinionPlayerSide, targetMinion, boardState, deckPlayer0, deckPlayer1);
+		
+		//check for and remove dead minions
+		if (toRet != null) {
+			toRet = BoardStateFactoryBase.handleDeadMinions(toRet, deckPlayer0, deckPlayer1);
+		}
+		
+		//Attacking means you lose stealth
+		if (toRet != null)
+			this.stealthed_ = false;
+		
+		return toRet;
+	}
 	
-	public abstract HearthTreeNode takeDamage(
+    /**
+	 * Called at the start of the turn
+	 * 
+	 * This function is called at the start of the turn.  Any derived class must override it to implement whatever
+	 * "start of the turn" effect the card has.
+	 */
+	@Override
+	public HearthTreeNode startTurn(PlayerSide thisMinionPlayerIndex, HearthTreeNode boardModel, Deck deckPlayer0, Deck deckPlayer1) throws HSException {
+		HearthTreeNode toRet = boardModel;
+		if (destroyOnTurnStart_) {
+//			toRet = this.destroyed(thisMinionPlayerIndex, toRet, deckPlayer0, deckPlayer1);
+			this.setHealth((byte)-99);
+		}
+		return toRet;
+	}
+	
+	/**
+	 * End the turn and resets the card state
+	 * 
+	 * This function is called at the end of the turn.  Any derived class must override it and remove any 
+	 * temporary buffs that it has.
+	 * 
+	 * This is not the most efficient implementation... luckily, endTurn only happens once per turn
+	 */
+	@Override
+	public HearthTreeNode endTurn(PlayerSide thisMinionPlayerIndex, HearthTreeNode boardModel, Deck deckPlayer0, Deck deckPlayer1) throws HSException {
+		extraAttackUntilTurnEnd_ = 0;
+		HearthTreeNode toRet = boardModel;
+		if (destroyOnTurnEnd_) {
+//			toRet = this.destroyed(thisMinionPlayerIndex, toRet, deckPlayer0, deckPlayer1);
+			this.setHealth((byte)-99);
+		}
+		return toRet;
+	}
+	
+	/**
+	 * Called when this minion takes damage
+	 * 
+	 * Always use this function to take damage... it properly notifies all others of its damage and possibly of its death
+	 *  @param damage The amount of damage to take
+	 * @param attackPlayerSide The player index of the attacker.  This is needed to do things like +spell damage.
+     * @param thisPlayerSide
+     * @param boardState
+     * @param deckPlayer0 The deck of player0
+     * @param isSpellDamage True if this is a spell damage
+     * @param handleMinionDeath Set this to True if you want the death event to trigger when (if) the minion dies from this damage.  Setting this flag to True will also trigger deathrattle immediately.
+     * @throws HSInvalidPlayerIndexException
+	 */
+	public HearthTreeNode takeDamage(
 			byte damage,
 			PlayerSide attackPlayerSide,
 			PlayerSide thisPlayerSide,
@@ -39,5 +497,875 @@ public abstract class BaseEntity extends Card implements DeepCopyable
 			Deck deckPlayer1,
 			boolean isSpellDamage,
 			boolean handleMinionDeath)
-		throws HSException;
+		throws HSException
+	{
+		if (!divineShield_) {
+			byte totalDamage = isSpellDamage ? (byte)(damage + boardState.data_.getSpellDamage(attackPlayerSide)) : damage;
+			health_ = (byte)(health_ - totalDamage);
+			
+			//Notify all that the minion is damaged
+			HearthTreeNode toRet = boardState;
+			toRet = toRet.data_.getCurrentPlayerHero().minionDamagedEvent(PlayerSide.CURRENT_PLAYER, thisPlayerSide, (Minion) this, toRet, deckPlayer0, deckPlayer1);
+			for (int j = 0; j < PlayerSide.CURRENT_PLAYER.getPlayer(toRet).getNumMinions(); ++j) {
+				if (!PlayerSide.CURRENT_PLAYER.getPlayer(toRet).getMinions().get(j).isSilenced())
+					toRet = PlayerSide.CURRENT_PLAYER.getPlayer(toRet).getMinions().get(j).minionDamagedEvent(PlayerSide.CURRENT_PLAYER, thisPlayerSide, (Minion) this, toRet, deckPlayer0, deckPlayer1);
+			}
+			toRet = toRet.data_.getWaitingPlayerHero().minionDamagedEvent(PlayerSide.WAITING_PLAYER, thisPlayerSide, (Minion) this, toRet, deckPlayer0, deckPlayer1);
+			for (int j = 0; j < PlayerSide.WAITING_PLAYER.getPlayer(toRet).getNumMinions(); ++j) {
+				if (!PlayerSide.WAITING_PLAYER.getPlayer(toRet).getMinions().get(j).isSilenced())
+					toRet = PlayerSide.WAITING_PLAYER.getPlayer(toRet).getMinions().get(j).minionDamagedEvent(PlayerSide.WAITING_PLAYER, thisPlayerSide, (Minion) this, toRet, deckPlayer0, deckPlayer1);
+			}
+			
+			return toRet;
+		} else {
+			if (damage > 0)
+				divineShield_ = false;
+			return boardState;
+		}
+	}
+	
+	/**
+	 * Called when this minion dies (destroyed)
+	 * 
+	 * Always use this function to "kill" minions
+	 * 
+	 *
+     *
+     * @param thisPlayerSide
+     * @param boardState
+     * @param deckPlayer0
+     * @param deckPlayer1
+     *
+     * @throws HSInvalidPlayerIndexException
+	 */
+	public HearthTreeNode destroyed(PlayerSide thisPlayerSide, HearthTreeNode boardState, Deck deckPlayer0, Deck deckPlayer1) throws HSException {
+
+        health_ = 0;
+        HearthTreeNode toRet = boardState;
+
+        //perform the deathrattle action if there is one
+        if (deathrattleAction_ != null) {
+            toRet =  deathrattleAction_.performAction((Minion) this, thisPlayerSide, toRet, deckPlayer0, deckPlayer1);
+        }
+
+        //Notify all that it is dead
+        toRet = toRet.data_.getCurrentPlayerHero().minionDeadEvent(PlayerSide.CURRENT_PLAYER, thisPlayerSide, (Minion) this, toRet, deckPlayer0, deckPlayer1);
+        for (int j = 0; j < PlayerSide.CURRENT_PLAYER.getPlayer(toRet).getNumMinions(); ++j) {
+            if (!PlayerSide.CURRENT_PLAYER.getPlayer(toRet).getMinions().get(j).isSilenced())
+                toRet = PlayerSide.CURRENT_PLAYER.getPlayer(toRet).getMinions().get(j).minionDeadEvent(PlayerSide.CURRENT_PLAYER, thisPlayerSide, (Minion) this, toRet, deckPlayer0, deckPlayer1);
+        }
+        toRet = toRet.data_.getWaitingPlayerHero().minionDeadEvent(PlayerSide.WAITING_PLAYER, thisPlayerSide, (Minion) this, toRet, deckPlayer0, deckPlayer1);
+        for (int j = 0; j < PlayerSide.WAITING_PLAYER.getPlayer(toRet).getNumMinions(); ++j) {
+            if (!PlayerSide.WAITING_PLAYER.getPlayer(toRet).getMinions().get(j).isSilenced())
+                toRet = PlayerSide.WAITING_PLAYER.getPlayer(toRet).getMinions().get(j).minionDeadEvent(PlayerSide.WAITING_PLAYER, thisPlayerSide, (Minion) this, toRet, deckPlayer0, deckPlayer1);
+        }
+
+        return toRet;
+
+	}
+
+	
+	public void silenced(PlayerSide thisPlayerSide, HearthTreeNode boardState) throws HSInvalidPlayerIndexException {
+		this.silenced(thisPlayerSide, boardState.data_);
+	}
+	
+	/**
+	 * Called when this minion is silenced
+	 * 
+	 * Always use this function to "silence" minions
+     *
+     * @param thisPlayerSide
+     * @param boardState
+     * @throws HSInvalidPlayerIndexException
+	 */
+	public void silenced(PlayerSide thisPlayerSide, BoardModel boardState) throws HSInvalidPlayerIndexException {
+		if (!silenced_) {
+			boardState.setSpellDamage(PlayerSide.CURRENT_PLAYER, (byte)(boardState.getSpellDamage(PlayerSide.CURRENT_PLAYER) - spellDamage_));
+		}
+
+		divineShield_ = false;
+		taunt_ = false;
+		charge_ = false;
+		frozen_ = false;
+		windFury_ = false;
+		silenced_ = true;
+		deathrattleAction_ = null;
+		stealthed_ = false;
+		heroTargetable_ = true;
+		
+		//Reset the attack and health to base
+		this.attack_ = this.baseAttack_;
+		if (this.maxHealth_ > this.baseHealth_) {
+			this.maxHealth_ = this.baseHealth_;
+			if (this.health_ > this.maxHealth_)
+				this.health_ = this.maxHealth_;
+		}
+	}
+	
+	/**
+	 * Called when this minion is healed
+	 * 
+	 * Always use this function to heal minions
+	 *  @param healAmount The amount of healing to take
+	 * @param thisPlayerSide
+     * @param boardState
+     * @param deckPlayer0 The deck of player0   @throws HSInvalidPlayerIndexException
+     * */
+	public HearthTreeNode takeHeal(byte healAmount, PlayerSide thisPlayerSide, HearthTreeNode boardState, Deck deckPlayer0, Deck deckPlayer1) throws HSInvalidPlayerIndexException {
+		
+		if (health_ < maxHealth_) {
+			if (health_ + healAmount > maxHealth_)
+				health_ = maxHealth_;
+			else
+				health_ = (byte)(health_ + healAmount);
+			
+			//Notify all that it the minion is healed
+			HearthTreeNode toRet = boardState;
+			toRet = toRet.data_.getCurrentPlayerHero().minionHealedEvent(PlayerSide.CURRENT_PLAYER, thisPlayerSide, (Minion) this, toRet, deckPlayer0, deckPlayer1);
+            for (Minion minion : PlayerSide.CURRENT_PLAYER.getPlayer(toRet).getMinions()) {
+                if (!minion.isSilenced())
+                    toRet = minion.minionHealedEvent(PlayerSide.CURRENT_PLAYER, thisPlayerSide, (Minion) this, toRet, deckPlayer0, deckPlayer1);
+            }
+			toRet = toRet.data_.getWaitingPlayerHero().minionHealedEvent(PlayerSide.WAITING_PLAYER, thisPlayerSide, (Minion) this, toRet, deckPlayer0, deckPlayer1);
+            for (Minion minion : PlayerSide.WAITING_PLAYER.getPlayer(toRet).getMinions()) {
+                if (!minion.isSilenced())
+                    toRet = minion.minionHealedEvent(PlayerSide.WAITING_PLAYER, thisPlayerSide, (Minion) this, toRet, deckPlayer0, deckPlayer1);
+            }
+			return toRet;
+		}
+		return boardState;
+	}
+	
+	
+	@Override
+    public boolean canBeUsedOn(PlayerSide playerSide, Minion minion, BoardModel boardModel) {
+        return playerSide != PlayerSide.WAITING_PLAYER && !hasBeenUsed;
+    }
+
+	/**
+	 * Use a targetable battlecry.
+	 * 
+	 * @param side
+	 * @param targetMinion
+	 * @param boardState
+	 * @param deckPlayer0
+	 * @param deckPlayer1
+	 * @return
+	 * @throws HSException
+	 */
+	public HearthTreeNode useTargetableBattlecry(
+			PlayerSide side,
+			BaseEntity targetMinion,
+			HearthTreeNode boardState,
+			Deck deckPlayer0,
+			Deck deckPlayer1
+		) throws HSException
+	{
+		HearthTreeNode node = new HearthTreeNode((BoardModel)boardState.data_.deepCopy());
+		int targetMinionIndex = side.getPlayer(boardState).getMinions().indexOf(targetMinion);
+		if (targetMinionIndex >= 0) {
+			node = this.useTargetableBattlecry_core(side, side.getPlayer(node).getMinions().get(targetMinionIndex), node, deckPlayer0, deckPlayer1);
+		} else if (targetMinion instanceof Hero) {
+			node = this.useTargetableBattlecry_core(side, side.getPlayer(node).getHero(), node, deckPlayer0, deckPlayer1);
+		} else {
+			node = null;
+		}
+		if (node != null) {
+			//Check for dead minions
+			node = BoardStateFactoryBase.handleDeadMinions(node, deckPlayer0, deckPlayer1);
+			//add the new node to the tree
+			boardState.addChild(node);
+		}
+		return boardState;
+	}
+
+	/**
+	 * Derived classes should implement this function for targtable battlecries.
+	 * 
+	 * @param side
+	 * @param targetMinion
+	 * @param boardState
+	 * @param deckPlayer0
+	 * @param deckPlayer1
+	 * @return
+	 * @throws HSException
+	 */
+	public HearthTreeNode useTargetableBattlecry_core(
+			PlayerSide side,
+			BaseEntity targetMinion,
+			HearthTreeNode boardState,
+			Deck deckPlayer0,
+			Deck deckPlayer1
+		) throws HSException
+	{
+		return null;
+	}
+	
+/*	public EnumSet<BattlecryTargetType> getBattlecryTargets() {
+		return EnumSet.of(BattlecryTargetType.NO_BATTLECRY);
+	}*/
+	
+	
+	/**
+	 * Use an untargetable battlecry.  
+	 * 
+	 * @param minionPlacementTarget
+	 * @param boardState
+	 * @param deckPlayer0
+	 * @param deckPlayer1
+	 * @param singleRealizationOnly
+	 * @return
+	 * @throws HSException
+	 */
+	public HearthTreeNode useUntargetableBattlecry(
+			Minion minionPlacementTarget,
+			HearthTreeNode boardState,
+			Deck deckPlayer0,
+			Deck deckPlayer1,
+			boolean singleRealizationOnly
+		) throws HSException
+	{
+		HearthTreeNode toRet = this.useUntargetableBattlecry_core(minionPlacementTarget, boardState, deckPlayer0, deckPlayer1, singleRealizationOnly);
+		if (toRet != null) {
+			//Check for dead minions
+			toRet = BoardStateFactoryBase.handleDeadMinions(toRet, deckPlayer0, deckPlayer1);
+		}
+		return toRet;
+	}
+	
+	public HearthTreeNode useUntargetableBattlecry_core(
+			Minion minionPlacementTarget,
+			HearthTreeNode boardState,
+			Deck deckPlayer0,
+			Deck deckPlayer1,
+			boolean singleRealizationOnly
+		) throws HSException
+	{
+		return null;
+	}	
+	/**
+	 * 
+	 * Places a minion on the board by using the card in hand
+	 * 
+	 *
+     *
+     * @param side
+     * @param targetMinion The target minion (can be a Hero).  The new minion is always placed to the right of (higher index) the target minion.  If the target minion is a hero, then it is placed at the left-most position.
+     * @param boardState The BoardState before this card has performed its action.  It will be manipulated and returned.
+     * @param deckPlayer0 The deck of player0
+     * @return The boardState is manipulated and returned
+	 * @throws HSException 
+	 */
+//	@Override
+//	protected HearthTreeNode use_core(
+//			PlayerSide side,
+//			Minion targetMinion,
+//			HearthTreeNode boardState,
+//			Deck deckPlayer0,
+//			Deck deckPlayer1,
+//			boolean singleRealizationOnly)
+//		throws HSException
+//	{
+//		if (hasBeenUsed) {
+//			//Card is already used, nothing to do
+//			return null;
+//		}
+//		
+//		if (side == PlayerSide.WAITING_PLAYER)
+//			return null;
+//		
+//		HearthTreeNode toRet = this.summonMinion(side, targetMinion, boardState, deckPlayer0, deckPlayer1, false);
+//		if (toRet != null) { //summon succeeded, now let's use up our mana
+//			toRet.data_.getCurrentPlayer().subtractMana(this.mana_);
+//			toRet.data_.removeCard_hand(this);
+//
+//			//Battlecry if available
+//			for (BattlecryTargetType btt : this.getBattlecryTargets()) {
+//				switch  (btt) {
+//				case NO_TARGET:
+//					toRet = this.useUntargetableBattlecry(targetMinion, toRet, deckPlayer0, deckPlayer1, singleRealizationOnly);
+//					break;
+//				case ENEMY_HERO:
+//					toRet = this.useTargetableBattlecry(PlayerSide.WAITING_PLAYER, PlayerSide.WAITING_PLAYER.getPlayer(toRet).getHero(), toRet, deckPlayer0, deckPlayer1);
+//					break;
+//				case FRIENDLY_HERO:
+//					toRet = this.useTargetableBattlecry(PlayerSide.CURRENT_PLAYER, PlayerSide.CURRENT_PLAYER.getPlayer(toRet).getHero(), toRet, deckPlayer0, deckPlayer1);
+//					break;
+//				case ENEMY_MINIONS:
+//					for (Minion minion : PlayerSide.WAITING_PLAYER.getPlayer(toRet).getMinions()) {
+//						toRet = this.useTargetableBattlecry(PlayerSide.WAITING_PLAYER, minion, toRet, deckPlayer0, deckPlayer1);
+//					}
+//					break;
+//				case FRIENDLY_MINIONS:
+//					for (Minion minion : PlayerSide.CURRENT_PLAYER.getPlayer(toRet).getMinions()) {
+//						if (minion != this)
+//							toRet = this.useTargetableBattlecry(PlayerSide.CURRENT_PLAYER, minion, toRet, deckPlayer0, deckPlayer1);
+//					}
+//					break;
+//				case ENEMY_BEASTS:
+//					for (Minion minion : PlayerSide.WAITING_PLAYER.getPlayer(toRet).getMinions()) {
+//						if (minion instanceof Beast)
+//							toRet = this.useTargetableBattlecry(PlayerSide.WAITING_PLAYER, minion, toRet, deckPlayer0, deckPlayer1);
+//					}
+//					break;
+//				case FRIENDLY_BEASTS:
+//					for (Minion minion : PlayerSide.CURRENT_PLAYER.getPlayer(toRet).getMinions()) {
+//						if (minion != this && minion instanceof Beast)
+//							toRet = this.useTargetableBattlecry(PlayerSide.CURRENT_PLAYER, minion, toRet, deckPlayer0, deckPlayer1);
+//					}
+//					break;
+//				case ENEMY_MURLOCS:
+//					for (Minion minion : PlayerSide.WAITING_PLAYER.getPlayer(toRet).getMinions()) {
+//						if (minion instanceof Murloc)
+//							toRet = this.useTargetableBattlecry(PlayerSide.WAITING_PLAYER, minion, toRet, deckPlayer0, deckPlayer1);
+//					}
+//					break;
+//				case FRIENDLY_MURLOCS:
+//					for (Minion minion : PlayerSide.CURRENT_PLAYER.getPlayer(toRet).getMinions()) {
+//						if (minion != this && minion instanceof Murloc)
+//							toRet = this.useTargetableBattlecry(PlayerSide.CURRENT_PLAYER, minion, toRet, deckPlayer0, deckPlayer1);
+//					}
+//					break;
+//				default:
+//					break;
+//				}
+//			}
+//			
+//			
+//			//Notify all that a minion is placed
+//			toRet = toRet.data_.getCurrentPlayerHero().minionPlacedEvent(toRet);
+//			for (Iterator<Minion> iter = toRet.data_.getCurrentPlayer().getMinions().iterator(); iter.hasNext();) {
+//				Minion minion = iter.next();
+//				if (!minion.silenced_)
+//					toRet = minion.minionPlacedEvent(toRet);
+//			}
+//			toRet = toRet.data_.getWaitingPlayerHero().minionPlacedEvent(toRet);
+//			for (Iterator<Minion> iter = toRet.data_.getWaitingPlayer().getMinions().iterator(); iter.hasNext();) {
+//				Minion minion = iter.next();
+//				if (!minion.silenced_)
+//					toRet = minion.minionPlacedEvent(toRet);
+//			}
+//		
+//		}
+//		
+//		return toRet;
+//	}
+	
+	
+	
+	/**
+	 * 
+	 * Places a minion on the board via a summon effect
+	 * 
+	 * This function is meant to be used when summoning minions through means other than a direct card usage.
+	 * 
+	 *
+     * @param targetSide
+     * @param targetMinion The target minion (can be a Hero).  If it is a Hero, then the minion is placed on the last (right most) spot on the board.
+     * @param boardState The BoardState before this card has performed its action.  It will be manipulated and returned.
+     * @param deckPlayer0 The deck of player0
+     * @param deckPlayer1 The deck of player1
+     * @param wasTransformed If the minion was 'summoned' as a result of a transform effect (e.g. Hex, Polymorph), set this to true.
+     *
+     * @return The boardState is manipulated and returned
+	 */
+/*	public HearthTreeNode summonMinion(
+            PlayerSide targetSide,
+            Minion targetMinion,
+            HearthTreeNode boardState,
+            Deck deckPlayer0,
+            Deck deckPlayer1,
+            boolean wasTransformed)
+		throws HSException
+	{
+		HearthTreeNode toRet = this.summonMinion_core(targetSide, targetMinion, boardState, deckPlayer0, deckPlayer1);
+		
+		if (toRet != null) {
+			toRet.data_.addSpellDamage(targetSide, this.spellDamage_);
+			if (!wasTransformed) {
+				//Notify all that a minion is summoned
+
+				toRet = toRet.data_.getCurrentPlayerHero().minionSummonedEvent(PlayerSide.CURRENT_PLAYER, targetSide, this, toRet, deckPlayer0, deckPlayer1);
+                for (Minion minion : PlayerSide.CURRENT_PLAYER.getPlayer(toRet).getMinions()) {
+                    if (!minion.silenced_)
+                        toRet = minion.minionSummonedEvent(PlayerSide.CURRENT_PLAYER, targetSide, this, toRet, deckPlayer0, deckPlayer1);
+                }
+				toRet = toRet.data_.getWaitingPlayerHero().minionSummonedEvent(PlayerSide.WAITING_PLAYER, targetSide, this, toRet, deckPlayer0, deckPlayer1);
+                for (Minion minion : PlayerSide.WAITING_PLAYER.getPlayer(toRet).getMinions()) {
+                    if (!minion.silenced_)
+                        toRet = minion.minionSummonedEvent(PlayerSide.WAITING_PLAYER, targetSide, this, toRet, deckPlayer0, deckPlayer1);
+                }
+			} else {
+				//Notify all that a minion is transformed
+				toRet = toRet.data_.getCurrentPlayerHero().minionTransformedEvent(PlayerSide.CURRENT_PLAYER, targetSide, this, toRet, deckPlayer0, deckPlayer1);
+                for (Minion minion : PlayerSide.CURRENT_PLAYER.getPlayer(toRet).getMinions()) {
+                    if (!minion.silenced_)
+                        toRet = minion.minionTransformedEvent(PlayerSide.CURRENT_PLAYER, targetSide, this, toRet, deckPlayer0, deckPlayer1);
+                }
+				toRet = toRet.data_.getWaitingPlayerHero().minionTransformedEvent(PlayerSide.WAITING_PLAYER, targetSide, this, toRet, deckPlayer0, deckPlayer1);
+                for (Minion minion : PlayerSide.WAITING_PLAYER.getPlayer(toRet).getMinions()) {
+                    if (!minion.silenced_)
+                        toRet = minion.minionTransformedEvent(PlayerSide.WAITING_PLAYER, targetSide, this, toRet, deckPlayer0, deckPlayer1);
+                }
+			}
+		}
+		
+		return toRet;
+	}*/
+	
+	/**
+	 * 
+	 * Places a minion on the board via a summon effect
+	 * 
+	 * This function is meant to be used when summoning minions through means other than a direct card usage.
+	 * 
+	 *
+     * @param targetSide
+     * @param targetMinion The target minion (can be a Hero).  The new minion is always placed to the right of (higher index) the target minion.  If the target minion is a hero, then it is placed at the left-most position.
+     * @param boardState The BoardState before this card has performed its action.  It will be manipulated and returned.
+     * @return The boardState is manipulated and returned
+     * @param deckPlayer0 The deck of player0
+     * @param deckPlayer1 The deck of player1
+	 * @throws HSException 
+	 */
+/*	protected HearthTreeNode summonMinion_core(
+            PlayerSide targetSide,
+			Minion targetMinion,
+			HearthTreeNode boardState,
+            Deck deckPlayer0,
+            Deck deckPlayer1
+			)
+		throws HSException
+	{		
+		if (boardState.data_.modelForSide(targetSide).getNumMinions() < 7) {
+
+			if (!charge_) {
+				hasAttacked_ = true;
+			}
+			hasBeenUsed = true;
+			if (isHero(targetMinion))
+				boardState.data_.placeMinion(targetSide, this, 0);
+			else
+				boardState.data_.placeMinion(targetSide, this, targetSide.getPlayer(boardState).getMinions().indexOf(targetMinion) + 1);
+			return boardState;
+							
+		} else {
+			return null;
+		}
+
+	}*/
+	/**
+	 * 
+	 * Attack with the minion
+	 * 
+	 *
+     *
+     * @param targetMinionPlayerSide
+     * @param targetMinion The target minion
+     * @param boardState The BoardState before this card has performed its action.  It will be manipulated and returned.
+     * @param deckPlayer0 The deck of player0
+     * @return The boardState is manipulated and returned
+	 */
+	public HearthTreeNode attack(
+			PlayerSide targetMinionPlayerSide,
+			Minion targetMinion,
+			HearthTreeNode boardState,
+			Deck deckPlayer0,
+			Deck deckPlayer1)
+		throws HSException
+	{
+		
+		//can't attack a stealthed target
+		if (targetMinion.getStealthed())
+			return null;
+		
+		if (frozen_) {
+			this.hasAttacked_ = true;
+			this.frozen_ = false;
+			return boardState;
+		}
+		
+		//Notify all that an attack is beginning
+		HearthTreeNode toRet = boardState;
+		if (toRet != null) {
+			//Notify all that a minion is created
+			toRet = toRet.data_.getCurrentPlayerHero().minionAttackingEvent(toRet);
+            for (Minion minion : PlayerSide.CURRENT_PLAYER.getPlayer(toRet).getMinions()) {
+                if (!minion.isSilenced())
+                    toRet = minion.minionAttackingEvent(toRet);
+            }
+			toRet = toRet.data_.getWaitingPlayerHero().minionAttackingEvent(toRet);
+            for (Minion minion : PlayerSide.WAITING_PLAYER.getPlayer(toRet).getMinions()) {
+                if (!minion.isSilenced())
+                    toRet = minion.minionAttackingEvent(toRet);
+            }
+		}
+		
+		//Do the actual attack
+		toRet = this.attack_core(targetMinionPlayerSide, targetMinion, boardState, deckPlayer0, deckPlayer1);
+		
+		//check for and remove dead minions
+		if (toRet != null) {
+			toRet = BoardStateFactoryBase.handleDeadMinions(toRet, deckPlayer0, deckPlayer1);
+		}
+		
+		//Attacking means you lose stealth
+		if (toRet != null)
+			this.stealthed_ = false;
+		
+		return toRet;
+	}
+
+	/**
+	 * 
+	 * Attack with the minion
+	 * 
+	 *
+     *
+     * @param targetMinionPlayerSide
+     * @param targetMinion The target minion
+     * @param boardState The BoardState before this card has performed its action.  It will be manipulated and returned.
+     * @param deckPlayer0 The deck of player0
+     * @return The boardState is manipulated and returned
+	 */
+	protected HearthTreeNode attack_core(
+			PlayerSide targetMinionPlayerSide,
+			BaseEntity targetMinion,
+			HearthTreeNode boardState,
+			Deck deckPlayer0,
+			Deck deckPlayer1)
+		throws HSException
+	{
+		
+		if (hasAttacked_) {
+			//minion has already attacked
+            log.debug("trying to attack when card has already attacked.");
+			return null;
+		}
+		
+		if (targetMinionPlayerSide == PlayerSide.CURRENT_PLAYER) {
+            log.debug("trying to attack ourself, derp..");
+			return null;
+		}
+		
+		if (this.getTotalAttack() <= 0) {
+            log.debug("unable to attack with zero attack damage.");
+            return null;
+        }
+
+		
+		HearthTreeNode toRet = boardState;
+		byte origAttack = targetMinion.getTotalAttack();
+		toRet = targetMinion.takeDamage(this.getTotalAttack(), PlayerSide.CURRENT_PLAYER, targetMinionPlayerSide, toRet, deckPlayer0, deckPlayer1, false, false);
+		toRet = this.takeDamage(origAttack, targetMinionPlayerSide, PlayerSide.CURRENT_PLAYER, toRet, deckPlayer0, deckPlayer1, false, false);
+		if (windFury_ && !hasWindFuryAttacked_)
+			hasWindFuryAttacked_ = true;
+		else
+			hasAttacked_ = true;
+		return toRet;
+
+	}
+
+
+	
+	//======================================================================================
+	// Hooks for various events
+	//======================================================================================	
+
+	/**
+	 * 
+	 * Called whenever another minion comes on board
+	 *  @param boardState The BoardState before this card has performed its action.  It will be manipulated and returned.
+     *
+     * */
+	public HearthTreeNode minionPlacedEvent(
+            HearthTreeNode boardState)
+		throws HSInvalidPlayerIndexException
+	{
+		return boardState;
+	}
+
+
+	/**
+	 * 
+	 * Called whenever another minion is summoned using a spell
+	 * 
+	 *
+     * @param thisMinionPlayerSide
+     * @param summonedMinionPlayerSide
+     * @param summonedMinion The summoned minion
+     * @param boardState The BoardState before this card has performed its action.  It will be manipulated and returned.
+     * @param deckPlayer0 The deck of player0    @return The boardState is manipulated and returned
+     * */
+	public HearthTreeNode minionSummonedEvent(
+			PlayerSide thisMinionPlayerSide,
+			PlayerSide summonedMinionPlayerSide,
+			Minion summonedMinion,
+			HearthTreeNode boardState,
+			Deck deckPlayer0,
+			Deck deckPlayer1)
+		throws HSInvalidPlayerIndexException
+	{
+		return boardState;
+	}
+	
+	/**
+	 * 
+	 * Called whenever another minion is summoned using a spell
+	 *  @param thisMinionPlayerSide The player index of this minion
+	 * @param transformedMinionPlayerSide
+     * @param transformedMinion The transformed minion (the minion that resulted from a transformation)
+     * @param boardState The BoardState before this card has performed its action.  It will be manipulated and returned.
+     * @param deckPlayer0 The deck of player0    @return The boardState is manipulated and returned
+     * */
+	public HearthTreeNode minionTransformedEvent(
+			PlayerSide thisMinionPlayerSide,
+			PlayerSide transformedMinionPlayerSide,
+			Minion transformedMinion,
+			HearthTreeNode boardState,
+			Deck deckPlayer0,
+			Deck deckPlayer1)
+		throws HSInvalidPlayerIndexException
+	{
+		return boardState;
+	}
+
+	/**
+	 * 
+	 * Called whenever another minion is attacking another character
+	 * 
+	 *  @param boardState The BoardState before this card has performed its action.  It will be manipulated and returned.
+     *
+     * */
+	public HearthTreeNode minionAttackingEvent(
+            HearthTreeNode boardState)
+		throws HSInvalidPlayerIndexException
+	{
+		return boardState;
+	}
+	
+	/**
+	 * 
+	 * Called whenever another minion is damaged
+	 * 
+	 *
+     * @param thisMinionPlayerSide
+     * @param damagedPlayerSide
+     * @param damagedMinion The damaged minion
+     * @param boardState The BoardState before this card has performed its action.  It will be manipulated and returned.
+     * @param deckPlayer0 The deck of player0    @return The boardState is manipulated and returned
+     * */
+	public HearthTreeNode minionDamagedEvent(
+			PlayerSide thisMinionPlayerSide,
+			PlayerSide damagedPlayerSide,
+			Minion damagedMinion,
+			HearthTreeNode boardState,
+			Deck deckPlayer0,
+			Deck deckPlayer1)
+		throws HSInvalidPlayerIndexException
+	{
+		return boardState;
+	}
+	
+	/**
+	 * 
+	 * Called whenever another minion dies
+	 * 
+	 *
+     * @param thisMinionPlayerSide
+     * @param deadMinionPlayerSide
+     * @param deadMinion The dead minion
+     * @param boardState The BoardState before this card has performed its action.  It will be manipulated and returned.
+     * @param deckPlayer0 The deck of player0    @return The boardState is manipulated and returned
+     * */
+	public HearthTreeNode minionDeadEvent(
+			PlayerSide thisMinionPlayerSide,
+			PlayerSide deadMinionPlayerSide,
+			Minion deadMinion,
+			HearthTreeNode boardState,
+			Deck deckPlayer0,
+			Deck deckPlayer1)
+		throws HSInvalidPlayerIndexException
+	{
+		return boardState;
+	}
+	
+	/**
+	 * 
+	 * Called whenever another character (including the hero) is healed
+	 * 
+	 *
+     * @param thisMinionPlayerSide
+     * @param healedMinionPlayerSide
+     * @param healedMinion The healed minion
+     * @param boardState The BoardState before this card has performed its action.  It will be manipulated and returned.
+     * @param deckPlayer0 The deck of player0    @return The boardState is manipulated and returned
+     * */
+	public HearthTreeNode minionHealedEvent(
+			PlayerSide thisMinionPlayerSide,
+			PlayerSide healedMinionPlayerSide,
+			Minion healedMinion,
+			HearthTreeNode boardState,
+			Deck deckPlayer0,
+			Deck deckPlayer1)
+		throws HSInvalidPlayerIndexException
+	{
+		return boardState;
+	}
+
+	
+	@Override
+	public JSONObject toJSON() {
+		JSONObject json = super.toJSON();
+		json.put("attack", attack_);
+		json.put("baseAttack", baseAttack_);
+		json.put("health", health_);
+		json.put("baseHealth", baseHealth_);
+		json.put("maxHealth", maxHealth_);
+		json.put("taunt", taunt_);
+		json.put("divineShield", divineShield_);
+		json.put("windFury", windFury_);
+		json.put("charge", charge_);
+		json.put("frozen", frozen_);
+		json.put("silenced", silenced_);
+		json.put("hasAttacked", hasAttacked_);
+		return json;
+	}
+	
+	/**
+	 * Deep copy of the object
+	 * 
+	 * Note: the event actions are not actually deep copied.
+	 */
+	@Override
+	public Object deepCopy() {
+
+        BaseEntity baseEntity = null;
+        try {
+        	baseEntity = getClass().newInstance();
+        } catch (InstantiationException e) {
+            log.error("instantiation error", e);
+        } catch (IllegalAccessException e) {
+            log.error("illegal access error", e);
+        }
+        if (baseEntity == null) {
+            throw new RuntimeException("unable to instantiate minion.");
+        }
+
+
+        baseEntity.name_ = name_;
+        baseEntity.mana_ = mana_;
+        baseEntity.attack_ = attack_;
+        baseEntity.health_ = health_;
+        baseEntity.baseAttack_ = baseAttack_;
+        baseEntity.extraAttackUntilTurnEnd_ = extraAttackUntilTurnEnd_;
+        baseEntity.auraAttack_ = auraAttack_;
+        baseEntity.baseHealth_ = baseHealth_;
+        baseEntity.maxHealth_ = maxHealth_;
+        baseEntity.auraHealth_ = auraHealth_;
+        baseEntity.spellDamage_ = spellDamage_;
+        baseEntity.taunt_ = taunt_;
+        baseEntity.divineShield_ = divineShield_;
+        baseEntity.windFury_ = windFury_;
+        baseEntity.charge_ = charge_;
+        baseEntity.hasAttacked_ = hasAttacked_;
+        baseEntity.hasWindFuryAttacked_ = hasWindFuryAttacked_;
+        baseEntity.frozen_ = frozen_;
+        baseEntity.silenced_ = silenced_;
+        baseEntity.stealthed_ = stealthed_;
+        baseEntity.heroTargetable_ = heroTargetable_;
+        baseEntity.summoned_ = summoned_;
+        baseEntity.transformed_ = transformed_;
+        baseEntity.destroyOnTurnStart_ = destroyOnTurnStart_;
+        baseEntity.destroyOnTurnEnd_ = destroyOnTurnEnd_;
+        baseEntity.deathrattleAction_ = deathrattleAction_;
+        baseEntity.attackAction_ = attackAction_;
+        baseEntity.isInHand_ = isInHand_;
+        baseEntity.hasBeenUsed = hasBeenUsed;
+        //to do: continue here.
+
+
+        return baseEntity;
+    }
+
+    @Override
+	public boolean equals(Object other) {
+		if (!super.equals(other)) {
+			return false;
+		}
+		
+		BaseEntity otherEntity = (BaseEntity)other;
+		if (health_ != otherEntity.health_) return false;
+		if (maxHealth_ != otherEntity.maxHealth_) return false;
+		if (baseHealth_ != otherEntity.baseHealth_) return false;
+		if (auraHealth_ != otherEntity.auraHealth_) return false;
+
+		if (attack_ != otherEntity.attack_) return false;
+		if (baseAttack_ != otherEntity.baseAttack_) return false;
+		if (extraAttackUntilTurnEnd_ != otherEntity.extraAttackUntilTurnEnd_) return false;
+		if (auraAttack_ != otherEntity.auraAttack_) return false;
+
+		if (taunt_ != otherEntity.taunt_) return false;
+		if (divineShield_ != otherEntity.divineShield_) return false;
+		if (windFury_ != otherEntity.windFury_) return false;
+		if (charge_ != otherEntity.charge_) return false;
+		if (stealthed_ != otherEntity.stealthed_) return false;
+		if (hasAttacked_ != otherEntity.hasAttacked_) return false;
+		if (heroTargetable_ != otherEntity.heroTargetable_) return false;
+		if (hasWindFuryAttacked_ != otherEntity.hasWindFuryAttacked_) return false;
+		if (frozen_ != otherEntity.frozen_) return false;
+		if (silenced_ != otherEntity.silenced_) return false;
+		if (summoned_ != otherEntity.summoned_) return false;
+		if (transformed_ != otherEntity.transformed_) return false;
+		if (destroyOnTurnStart_ != otherEntity.destroyOnTurnStart_) return false;
+		if (destroyOnTurnEnd_ != otherEntity.destroyOnTurnEnd_) return false;
+		
+		if (spellDamage_ != otherEntity.spellDamage_) return false;
+
+		//This is checked for reference equality
+		if (deathrattleAction_ != ((BaseEntity)other).deathrattleAction_)
+			return false;
+		
+		//This is checked for reference equality
+		if (attackAction_ != ((BaseEntity)other).attackAction_)
+			return false;
+		
+		return true;
+	}
+
+    @Override
+    public int hashCode() {
+        int result = super.hashCode();
+        result = 31 * result + (taunt_ ? 1 : 0);
+        result = 31 * result + (divineShield_ ? 1 : 0);
+        result = 31 * result + (windFury_ ? 1 : 0);
+        result = 31 * result + (charge_ ? 1 : 0);
+        result = 31 * result + (hasAttacked_ ? 1 : 0);
+        result = 31 * result + (hasWindFuryAttacked_ ? 1 : 0);
+        result = 31 * result + (frozen_ ? 1 : 0);
+        result = 31 * result + (silenced_ ? 1 : 0);
+        result = 31 * result + (stealthed_ ? 1 : 0);
+        result = 31 * result + (heroTargetable_ ? 1 : 0);
+        result = 31 * result + (int) health_;
+        result = 31 * result + (int) maxHealth_;
+        result = 31 * result + (int) baseHealth_;
+        result = 31 * result + (int) auraHealth_;
+        result = 31 * result + (int) attack_;
+        result = 31 * result + (int) baseAttack_;
+        result = 31 * result + (int) extraAttackUntilTurnEnd_;
+        result = 31 * result + (int) auraAttack_;
+        result = 31 * result + (summoned_ ? 1 : 0);
+        result = 31 * result + (transformed_ ? 1 : 0);
+        result = 31 * result + (destroyOnTurnStart_ ? 1 : 0);
+        result = 31 * result + (destroyOnTurnEnd_ ? 1 : 0);
+        result = 31 * result + (int) spellDamage_;
+        result = 31 * result + (deathrattleAction_ != null ? deathrattleAction_.hashCode() : 0);
+        result = 31 * result + (attackAction_ != null ? attackAction_.hashCode() : 0);
+        result = 31 * result + (placementImportant_ ? 1 : 0);
+        return result;
+    }
+
+    public boolean currentPlayerBoardFull(HearthTreeNode boardState) {
+        return PlayerSide.CURRENT_PLAYER.getPlayer(boardState).getNumMinions() >= 7;
+    }
 }
\ No newline at end of file
diff --git a/src/main/java/com/hearthsim/model/BoardModel.java b/src/main/java/com/hearthsim/model/BoardModel.java
index 0c1dd2e..724a2cb 100644
--- a/src/main/java/com/hearthsim/model/BoardModel.java
+++ b/src/main/java/com/hearthsim/model/BoardModel.java
@@ -1,5 +1,6 @@
 package com.hearthsim.model;
 
+import com.hearthsim.entity.BaseEntity;
 import com.hearthsim.card.Card;
 import com.hearthsim.card.Deck;
 import com.hearthsim.card.minion.Hero;
@@ -155,9 +156,9 @@ public class BoardModel implements DeepCopyable {
         return waitingPlayer.getHand().get(index);
     }
 
-    public Minion getCharacter(PlayerSide playerSide, int index) throws HSInvalidPlayerIndexException {
+    public BaseEntity getCharacter(PlayerSide playerSide, int index) throws HSInvalidPlayerIndexException {
         PlayerModel playerModel = modelForSide(playerSide);
-        return index == 0 ? playerModel.getHero() : playerModel.getMinions().get(index - 1);
+        return (BaseEntity) (index == 0 ? playerModel.getHero() : playerModel.getMinions().get(index - 1));
     }
 
     public Minion getCurrentPlayerCharacter(int index) {
@@ -170,7 +171,7 @@ public class BoardModel implements DeepCopyable {
 
     public Minion getMinionForCharacter(PlayerSide playerSide, int index) {
         PlayerModel playerModel = modelForSide(playerSide);
-        return index == 0 ? playerModel.getHero() : playerModel.getMinions().get(index - 1);
+        return (Minion) (index == 0 ? playerModel.getHero() : playerModel.getMinions().get(index - 1));
     }
 
     //-----------------------------------------------------------------------------------
@@ -189,12 +190,18 @@ public class BoardModel implements DeepCopyable {
      * @param position The position to place the minion.  The new minion goes to the "left" (lower index) of the postinion index.
      * @throws HSInvalidPlayerIndexException
      */
+/*    public void placeMinion(PlayerSide playerSide, Minion minion, int position) throws HSInvalidPlayerIndexException {
+        PlayerModel playerModel = modelForSide(playerSide);
+        playerModel.getMinions().add(position, minion);
+
+        this.allMinionsFIFOList_.add(new MinionPlayerPair(minion, playerModel));
+        minion.isInHand(false);*/
     public void placeMinion(PlayerSide playerSide, Minion minion, int position) throws HSInvalidPlayerIndexException {
         PlayerModel playerModel = modelForSide(playerSide);
         playerModel.getMinions().add(position, minion);
 
         this.allMinionsFIFOList_.add(new MinionPlayerPair(minion, playerModel));
-        minion.isInHand(false);
+        minion.isInHand(false);       
     }
 
 
diff --git a/src/test/java/com/hearthsim/test/card/TestKillCommand.java b/src/test/java/com/hearthsim/test/card/TestKillCommand.java
index 56c0974..0e79f7b 100644
--- a/src/test/java/com/hearthsim/test/card/TestKillCommand.java
+++ b/src/test/java/com/hearthsim/test/card/TestKillCommand.java
@@ -2,10 +2,12 @@ package com.hearthsim.test.card;
 
 import com.hearthsim.card.Card;
 import com.hearthsim.card.Deck;
+import com.hearthsim.card.minion.Hero;
 import com.hearthsim.card.minion.Minion;
 import com.hearthsim.card.minion.concrete.IronfurGrizzly;
 import com.hearthsim.card.spellcard.concrete.KillCommand;
 import com.hearthsim.card.spellcard.concrete.TheCoin;
+import com.hearthsim.entity.BaseEntity;
 import com.hearthsim.exception.HSException;
 import com.hearthsim.model.BoardModel;
 import com.hearthsim.model.PlayerSide;
@@ -62,7 +64,7 @@ public class TestKillCommand {
 	@Test
 	public void test0() throws HSException {
 		
-		Minion target = board.data_.getCharacter(PlayerSide.WAITING_PLAYER, 0);
+		BaseEntity target = board.data_.getCharacter(PlayerSide.WAITING_PLAYER, 0);
 		Card theCard = board.data_.getCurrentPlayerCardHand(0);
 		HearthTreeNode ret = theCard.useOn(PlayerSide.WAITING_PLAYER, target, board, deck, null);
 		
@@ -83,12 +85,13 @@ public class TestKillCommand {
 	@Test
 	public void test1() throws HSException {
 		
-		Minion target = board.data_.getCharacter(PlayerSide.WAITING_PLAYER, 1);
+		BaseEntity target = board.data_.getCharacter(PlayerSide.WAITING_PLAYER, 1);
 		Card theCard = board.data_.getCurrentPlayerCardHand(0);
 		HearthTreeNode ret = theCard.useOn(PlayerSide.WAITING_PLAYER, target, board, deck, null);
 		
 		assertFalse(ret == null);
 		assertEquals(board.data_.getNumCards_hand(), 0);
+		System.out.println(PlayerSide.WAITING_PLAYER.getPlayer(board).getNumMinions());
 		assertEquals(PlayerSide.CURRENT_PLAYER.getPlayer(board).getNumMinions(), 2);
 		assertEquals(PlayerSide.WAITING_PLAYER.getPlayer(board).getNumMinions(), 1);
 		assertEquals(board.data_.getCurrentPlayer().getMana(), 4);
@@ -105,7 +108,7 @@ public class TestKillCommand {
 	public void test2() throws HSException {
 		
 		board.data_.placeMinion(PlayerSide.CURRENT_PLAYER, new IronfurGrizzly());
-		Minion target = board.data_.getCharacter(PlayerSide.WAITING_PLAYER, 0);
+		Hero target = board.data_.getCharacter(PlayerSide.WAITING_PLAYER, 0);
 		Card theCard = board.data_.getCurrentPlayerCardHand(0);
 		HearthTreeNode ret = theCard.useOn(PlayerSide.WAITING_PLAYER, target, board, deck, null);
 		
diff --git a/src/test/java/com/hearthsim/test/heroes/TestBaseEntity.java b/src/test/java/com/hearthsim/test/heroes/TestBaseEntity.java
new file mode 100644
index 0000000..ed440fe
--- /dev/null
+++ b/src/test/java/com/hearthsim/test/heroes/TestBaseEntity.java
@@ -0,0 +1,78 @@
+/*package com.hearthsim.test.heroes;
+
+import com.hearthsim.util.tree.HearthTreeNode;
+import com.hearthsim.card.Card;
+import com.hearthsim.card.Deck;
+import com.hearthsim.card.minion.Hero;
+import com.hearthsim.card.minion.Minion;
+import com.hearthsim.card.minion.concrete.BoulderfistOgre;
+import com.hearthsim.card.minion.concrete.RaidLeader;
+import com.hearthsim.card.minion.heroes.Druid;
+import com.hearthsim.card.spellcard.concrete.TheCoin;
+import com.hearthsim.card.spellcard.concrete.WildGrowth;
+import com.hearthsim.exception.HSException;
+import com.hearthsim.model.BoardModel;
+import com.hearthsim.model.PlayerSide;
+import com.hearthsim.util.tree.HearthTreeNode;
+import org.junit.Before;
+import org.junit.Test;
+import static org.junit.Assert.*;
+
+public class TestBaseEntity
+{
+	private HearthTreeNode board;
+	private Deck deck;
+	
+	@Before
+	public void setup() {
+		board = new HearthTreeNode(new BoardModel(new Druid(), new Hero()));
+
+		Minion minion0_0 = new BoulderfistOgre();
+		Minion minion0_1 = new RaidLeader();
+		Minion minion1_0 = new BoulderfistOgre();
+		Minion minion1_1 = new RaidLeader();
+		
+		board.data_.placeCardHandCurrentPlayer(minion0_0);
+		board.data_.placeCardHandCurrentPlayer(minion0_1);
+				
+		board.data_.placeCardHandWaitingPlayer(minion1_0);
+		board.data_.placeCardHandWaitingPlayer(minion1_1);
+
+		Card cards[] = new Card[10];
+		for (int index = 0; index < 10; ++index) {
+			cards[index] = new TheCoin();
+		}
+	
+		deck = new Deck(cards);
+
+		Card fb = new WildGrowth();
+		board.data_.placeCardHandCurrentPlayer(fb);
+
+		board.data_.getCurrentPlayer().setMana((byte)8);
+		board.data_.getWaitingPlayer().setMana((byte)8);
+		
+		board.data_.getCurrentPlayer().setMaxMana((byte)8);
+		board.data_.getWaitingPlayer().setMaxMana((byte)8);
+		
+		HearthTreeNode tmpBoard = new HearthTreeNode(board.data_.flipPlayers());
+		try {
+			tmpBoard.data_.getCurrentPlayerCardHand(0).useOn(PlayerSide.CURRENT_PLAYER, tmpBoard.data_.getCurrentPlayerHero(), tmpBoard, deck, null);
+			tmpBoard.data_.getCurrentPlayerCardHand(0).useOn(PlayerSide.CURRENT_PLAYER, tmpBoard.data_.getCurrentPlayerHero(), tmpBoard, deck, null);
+		} catch (HSException e) {
+			// TODO Auto-generated catch block
+			e.printStackTrace();
+		}
+		board = new HearthTreeNode(tmpBoard.data_.flipPlayers());
+		try {
+			board.data_.getCurrentPlayerCardHand(0).useOn(PlayerSide.CURRENT_PLAYER, board.data_.getCurrentPlayerHero(), board, deck, null);
+			board.data_.getCurrentPlayerCardHand(0).useOn(PlayerSide.CURRENT_PLAYER, board.data_.getCurrentPlayerHero(), board, deck, null);
+		} catch (HSException e) {
+			// TODO Auto-generated catch block
+			e.printStackTrace();
+		}
+		board.data_.resetMana();
+		board.data_.resetMinions();
+		
+	}
+}
+*/
\ No newline at end of file
-- 
1.8.4.msysgit.0

